<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Fundamentals: Type Systems - High Assurance Rust: Developing Secure and Robust Software</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="../highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="../tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->

        <!-- MathJax -->
        <script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "../";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">High Assurance Rust: Developing Secure and Robust Software</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/tnballo/high-assurance-rust" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        <a href="https://highassurance.rs/engage.html#submit-feedback-questions-issues-or-prs" title="Suggest an edit" aria-label="Suggest an edit">
                            <i id="git-edit-button" class="fa fa-edit"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <meta name="title" content="High Assurance Rust">
<meta name="description" content="Developing Secure and Robust Software">
<meta property="og:title" content="High Assurance Rust">
<meta property="og:description" content="Developing Secure and Robust Software">
<meta property="og:type" content="article">
<meta property="og:url" content="https://highassurance.rs/">
<meta property="og:image" content="https://highassurance.rs/img/har_logo_social.png">
<meta name="twitter:title" content="High Assurance Rust">
<meta name="twitter:description" content="Developing Secure and Robust Software">
<meta name="twitter:url" content="https://highassurance.rs/">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://highassurance.rs/img/har_logo_social.png">
<h1 id="fundamentals-type-systems"><a class="header" href="#fundamentals-type-systems">Fundamentals: Type Systems</a></h1>
<blockquote>
<p><strong>Note:</strong> This section is a work-in-progress. It may be expanded or revised to cover more formal aspects, like type rules, in the future.</p>
</blockquote>
<p>Rust's secret sauce is its type system.
So we should discuss types.
This is a dense topic whose dedicated field, type theory, predates computer programming.
We won't do it justice in a handful of pages.</p>
<p>Static type systems are perhaps the most widespread and powerful form of static analysis in existence.
Let's think of types as having two jobs:</p>
<h2 id="1-mapping-abstract-data-to-a-physical-machine"><a class="header" href="#1-mapping-abstract-data-to-a-physical-machine">1. Mapping abstract data to a physical machine</a></h2>
<p>Types are specifications for how data is read and written.
At the mechanical level of hardware.
In memory, every construct is just a bit pattern - a sequence of <code>0</code>s and <code>1</code>s.
Types provide language-level overlays suited to human reasoning.</p>
<p>For example: integer types interpret sequences of bits, 64 at time on modern "64-bit" machines, as whole numbers.
They can be operated on mathematically (addition, subtraction, multiplication, etc) when stored in "registers" (think tiny, readily-accessible, CPU-specific chunks).</p>
<p>Let's revisit the <code>incr</code> function from Chapter 2.
We had a function taking pointers to integers as arguments.
In C, the below code couldn't guarantee that pointers <code>a</code> and <code>b</code> don't alias.
Or that either pointer refers to a valid memory location.</p>
<pre><code class="language-c">void incr(int* a, int* b) {
    *a += *b;
}
</code></pre>
<p>The Rust port eliminated both of those problems:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn incr(a: &amp;mut isize, b: &amp;isize) {
    *a += *b;
}
<span class="boring">}</span></code></pre></pre>
<p>Both languages have type systems that do semantic superimposition.
They map source code operations to physical hardware operations:</p>
<ol>
<li>
<p>Read bit-patterns from RAM address (values of integers types <code>a</code> and <code>b</code>) into registers (dereference reads).</p>
</li>
<li>
<p>Add the values of the two CPU registers, as if whole numbers, using a CPU instruction (mathematical operation).</p>
</li>
<li>
<p>Writes the result back to memory (dereference write).</p>
</li>
</ol>
<h2 id="2-verifying-program-behavior-by-elimination"><a class="header" href="#2-verifying-program-behavior-by-elimination">2. Verifying program behavior by elimination</a></h2>
<p>Types have another job in addition to, or perhaps in unison with, working out how the hardware sausage is made.
They verify what programs will do, by elimination.
A seminal textbook on the subject<sup class="footnote-reference" id="fr-TPL-1"><a href="#footnote-TPL">1</a></sup> suggests:</p>
<blockquote>
<p>A type system is a tractable syntactic method for proving the absence of certain program behaviors by classifying phrases according to the kinds of values they compute.</p>
</blockquote>
<p>That essentially means types can constrain possible behaviors, so you can be confident certain things won't happen.
In the case of the Rust <code>incr</code> function, that means eliminating two problem states (aliasing and invalid pointers) completely.</p>
<p>How do we prove absence of certain behaviors?
At a high level: by <em>grouping</em> values based on desired behavior.
For example:</p>
<ul>
<li>
<p><strong>Grouping:</strong> Values <code>0</code>, <code>1</code>, <code>2</code>, ..., <code>255</code> can be grouped into the type <code>u8</code> (8-bit unsigned integer).</p>
</li>
<li>
<p><strong>Proving absence of a behavior:</strong> The <code>+</code> operator applied to <code>u8</code> operands performs <em>addition</em>, not <em>concatenation</em>. Thus we guarantee the program will never concatenate two unsigned bytes - that operation has no meaning in the language.</p>
</li>
</ul>
<p>The difference between two broad classes of type systems, static and dynamic, comes down to <em>how</em> we do that proving of absence:</p>
<ul>
<li>
<p><strong>Static typing</strong> does the proving at compile-time. Guaranteeing the program will never exhibit a behavior at runtime.</p>
<ul>
<li>Variables have types. As a consequence, so do values. And types are known at compile-time, for every possible execution.</li>
</ul>
</li>
<li>
<p><strong>Dynamic typing</strong> tags values with types at runtime. The legality of operations is checked during program execution. If the check fails, the program may terminate or throw an exception.</p>
<ul>
<li>Values have types, variables do not. And the type of a value is only known at runtime.</li>
</ul>
</li>
</ul>
<h2 id="case-study-dynamic-typing"><a class="header" href="#case-study-dynamic-typing">Case Study: Dynamic Typing</a></h2>
<p>Sometimes the best way to internalize an idea is to look at a counter example.
Contrast can be illuminating.
Let's step away from Rust's static types for a minute.</p>
<p>Python is a scripting language with a beginner-friendly syntax and a large professional user base.
Unlike Rust, it's dynamically typed.
For many projects, this reduces development friction and improves prototyping speed.
The interpreter's abstractions allow developers to focus on the product they ship - not the machine they run it on.</p>
<p>But there's a world of use cases, from low-power embedded sensing to high-performance distributed workloads, for which Python is wholly unsuitable.
High assurance applications are one subset.
The relatively sluggish performance is a factor, but poor reliability is the bigger downside.
Let's see why.</p>
<p>Start by firing up the Python Read Execute Print Loop (REPL) with the command:</p>
<pre><code class="language-ignore">python3
</code></pre>
<p>The REPL allows us to execute programs as we enter them, a convenient workflow enabled by dynamic typing.
Declare two variables, <code>word</code> and <code>x</code>, and inspect their types:</p>
<pre><code class="language-python">&gt;&gt;&gt; word = "Hello"
&gt;&gt;&gt; print(type(word))
&lt;class 'str'&gt;
&gt;&gt;&gt; x = 3
&gt;&gt;&gt; print(type(x))
&lt;class 'int'&gt;
</code></pre>
<p>Multiplying <code>word</code> (a string) by <code>x</code> (an integer) is legal.
Here's the result:</p>
<pre><code class="language-python">&gt;&gt;&gt; print(word*x)
HelloHelloHello
</code></pre>
<p>But consider multiplying a string by a string (<code>word</code> by itself).
That doesn't generally make sense, so it will result in an error.
Rust will catch this error at compile time, long before we ship our code.
But Python throws it at <em>runtime</em>, and only if that particular line gets executed:</p>
<pre><code class="language-python">&gt;&gt;&gt; print(word*word)
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
TypeError: can't multiply sequence by non-int of type 'str'
</code></pre>
<p>For high assurance software, that's too late.
A single type error, hit on a code path not covered in our test suite, means service degradation or outage.
Without a static type system, executing uncommon or untested paths through a program is akin to "flying by the seat of your pants".
And if we refactor dynamically typed code against an incomplete test suite, we might actually be adding those rare paths.</p>
<blockquote>
<p><strong>Can't we just get 100% test coverage?</strong></p>
<p>Achieving 100% coverage can be impractical for large projects.
Even if we could, the state-space of a program (set of all possible states) isn't necessarily correlated with its coverage (set of statements executed).
That means we could pass tests with full coverage and still hit a type error at runtime, in production.</p>
</blockquote>
<h2 id="goldilocks-assurance-contrast"><a class="header" href="#goldilocks-assurance-contrast">Goldilocks Assurance Contrast</a></h2>
<p>In the 1970s, compilers for industrial applications were largely uncharted waters.
Most compile-time verification we take for granted today was still decades of research away.
Runtime checks were prohibitively expensive without a compiler sophisticated enough to know where they're not needed.
Thus, C's <strong>weak, static typing</strong> means subdued safety enforcement.
C types can be converted, or cast, implicitly - and thus often erroneously.</p>
<p>Weak typing, coupled with other design choices, has resulted in a language which allows for a devastating amount of <strong>Undefined Behavior (UB)</strong><sup class="footnote-reference" id="fr-UndefResearch-1"><a href="#footnote-UndefResearch">2</a></sup>: C programs can exhibit unpredictable behavior at runtime.
Due to "gaps" in the language specification, not problems with the implementation of any specific compiler.
And these gaps can't be fixed retro-actively, that might break existing C programs we all rely on.</p>
<p>The "Goldilocks Principle"<sup class="footnote-reference" id="fr-GoldiPrin-1"><a href="#footnote-GoldiPrin">3</a></sup>, named after a child's fable<sup class="footnote-reference" id="fr-Goldi-1"><a href="#footnote-Goldi">4</a></sup>, reflects a cross-domain understanding: we want to optimize for "just the right amount" of a property.
For us, that property is assurance under performance constraints.
Our three bears are C, Python, and Rust.
A rough high-level comparison:</p>
<div class="table-wrapper"><table><thead><tr><th></th><th>C</th><th>Python</th><th><strong>Rust</strong></th></tr></thead><tbody>
<tr><td><em>Type-safe?</em></td><td>No (Weak, <strong>Static</strong>)</td><td>No (<strong>Strong</strong>, Dynamic)</td><td><strong>Yes</strong> (<strong>Strong</strong>, <strong>Static</strong>)</td></tr>
<tr><td><em>Memory-safe?</em></td><td>No</td><td><strong>Yes</strong></td><td><strong>Yes</strong></td></tr>
<tr><td><em>Fast?</em></td><td><strong>Yes</strong></td><td>No</td><td><strong>Yes</strong></td></tr>
</tbody></table>
</div>
<blockquote>
<p><strong>Doesn't Python support optional static typing?</strong></p>
<p>A peer-reviewed, large-scale analysis<sup class="footnote-reference" id="fr-Py3Types-1"><a href="#footnote-Py3Types">5</a></sup> of real-world Python projects found that a small minority use type annotations (3.8%), those that do rarely use them correctly enough to pass a type check (15% of the 3.8%), and that popular type checkers (<code>MyPy</code> and <code>PyType</code>) produce false positives (44-49% of the time).</p>
<p>Worse yet, Python type checkers often disagree with each other.
Optional typing isn't a viable substitute for a compiler-enforced static type system - especially in a high assurance context.</p>
</blockquote>
<p>There's a great deal of nuance which the table doesn't capture.
But we'll use it to wrap up this aside on types and reliability.</p>
<blockquote>
<p><strong>How about Go?</strong></p>
<p>Go is a popular, modern, statically-typed, natively-compiled programming language.
It has fantastic concurrency support.
But garbage collection makes it unsuitable for a wide range of systems programming tasks.
Go has to "pause" your entire program at unpredictable intervals and execute an algorithm to clean up memory.
This is often unacceptable for real-time and low-latency systems.</p>
<p>Rust helps you wrangle memory at compile time, inserting allocation/deallocation logic based on variable scope.
The result is predictable performance.
Discord, makers of a popular chat application, found that Go's garbage collection wasn't compatible with a service's performance targets.
They re-wrote the service in Rust to eliminate latency spikes<sup class="footnote-reference" id="fr-DiscGo-1"><a href="#footnote-DiscGo">6</a></sup>.</p>
</blockquote>
<h2 id="takeaway"><a class="header" href="#takeaway">Takeaway</a></h2>
<p>At a mechanical level, type systems power the machinery by which data is read and written.
At a more abstract level, type systems ensure certain undesirable outcomes don't occur - so long as programmers don't introduce typecasting bugs.</p>
<p>Dynamically typed languages, which do type checking at runtime, introduce a reliability risk.
Previously explored paths and states can introduce crashes or exceptions.</p>
<p>Weak static typing, where type casting with little restriction is tolerated, is similarly risky.
It can introduce UB.
Whose consequences include crashes, incorrect results, and security vulnerabilities.</p>
<hr>
<ol class="footnote-definition"><li id="footnote-TPL">
<p><a href="https://www.cis.upenn.edu/~bcpierce/tapl/"><em>Types and Programming Languages</em></a>. Benjamin C. Pierce (2002). <a href="#fr-TPL-1">↩</a></p>
</li>
<li id="footnote-UndefResearch">
<p><a href="https://people.csail.mit.edu/nickolai/papers/wang-undef-2012-08-21.pdf"><em>Undefined Behavior: What Happened to My Code?</em></a>. Xi Wang, Haogang Chen, Alvin Cheung, Zhihao Jia, Nickolai Zeldovich, M. Frans Kaashoek (2012). <a href="#fr-UndefResearch-1">↩</a></p>
</li>
<li id="footnote-GoldiPrin">
<p><a href="https://en.wikipedia.org/wiki/Goldilocks_principle"><em>Goldilocks principle</em></a>. Wikipedia (2021) <a href="#fr-GoldiPrin-1">↩</a></p>
</li>
<li id="footnote-Goldi">
<p><a href="https://en.wikipedia.org/wiki/Goldilocks_and_the_Three_Bears"><em>Goldilocks and the Three Bears</em></a>. Robert Southey (1837). <a href="#fr-Goldi-1">↩</a></p>
</li>
<li id="footnote-Py3Types">
<p><a href="https://www.cs.rpi.edu/~milanova/docs/dls2020.pdf"><em>Python 3 Types in the Wild: A Tale of Two Type Systems</em></a>. Ingkarat Rak-amnouykit, Daniel McCrevan, Ana Milanova, Martin Hirzel, Julian Dolby (2020). <a href="#fr-Py3Types-1">↩</a></p>
</li>
<li id="footnote-DiscGo">
<p><a href="https://blog.discord.com/why-discord-is-switching-from-go-to-rust-a190bbca2b1f"><em>Why Discord is switching from Go to Rust</em></a>. Jesse Howarth (2020). <a href="#fr-DiscGo-1">↩</a></p>
</li>
</ol>
                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../chp16_appendix/crypto.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../chp16_appendix/components.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../chp16_appendix/crypto.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../chp16_appendix/components.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
