<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Interface-relevant Traits - High Assurance Rust: Developing Secure and Robust Software</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="../highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="../tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->

        <!-- MathJax -->
        <script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "../";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">High Assurance Rust: Developing Secure and Robust Software</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/tnballo/high-assurance-rust" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        <a href="https://highassurance.rs/engage.html#submit-feedback-questions-issues-or-prs" title="Suggest an edit" aria-label="Suggest an edit">
                            <i id="git-edit-button" class="fa fa-edit"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <meta name="title" content="High Assurance Rust">
<meta name="description" content="Developing Secure and Robust Software">
<meta property="og:title" content="High Assurance Rust">
<meta property="og:description" content="Developing Secure and Robust Software">
<meta property="og:type" content="article">
<meta property="og:url" content="https://highassurance.rs/">
<meta property="og:image" content="https://highassurance.rs/img/har_logo_social.png">
<meta name="twitter:title" content="High Assurance Rust">
<meta name="twitter:description" content="Developing Secure and Robust Software">
<meta name="twitter:url" content="https://highassurance.rs/">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://highassurance.rs/img/har_logo_social.png">
<h1 id="interface-relevant-traits"><a class="header" href="#interface-relevant-traits">Interface-relevant Traits</a></h1>
<p>The library we're building is an alternative to two collections in Rust's standard library: <code>BTreeSet</code><sup class="footnote-reference" id="fr-BTreeSet-1"><a href="#footnote-BTreeSet">1</a></sup> and <code>BTreeMap</code><sup class="footnote-reference" id="fr-BTreeMap-1"><a href="#footnote-BTreeMap">2</a></sup>.
Our goal is to provide the same well-known, idiomatic APIs but with maximal safety (for any system) and bare metal portability (for firmware and/or tiny microcontrollers).</p>
<p>To get there, we need to understand a bit about the design of the standard library's APIs.
Specifically the <em>traits</em> these APIs bind to their <em>generic</em> arguments.
These design decisions shape an interplay of usability and resource management.</p>
<p>API design is a concern orthogonal to the algorithms of our particular data structure, so let's tackle it first.
To achieve feature-parity with the standard library, we'll deepen our understanding of how Rust works "under-the-hood".</p>
<blockquote>
<p><strong>What are generics and traits, again?</strong></p>
<p>We introduced the concepts and syntax in chapter 3.
To jog your memory:</p>
<ul>
<li>
<p><strong>Generics</strong> (e.g. <code>T</code> standing in for concrete type <code>u64</code> or <code>u32</code>) eliminate the need for code duplication. A single function's source code can be used, by the compiler, to generate one machine-code equivalent for each concrete type that function is called with (monomorphization).</p>
</li>
<li>
<p><strong>Traits</strong> (e.g <code>T: Ord</code> for a type that can be sorted and compared) define behavior shared among different types. They're similar to interfaces and abstract bases classes of other languages.</p>
</li>
</ul>
<p>We often combine the two by binding traits to generic arguments and/or return values.
This allows us to write a single function that our users can leverage for any [generic] type implementing some behavior (one or more specific traits). Even custom types that haven't been invented yet!</p>
</blockquote>
<h2 id="the-map-get-api"><a class="header" href="#the-map-get-api">The Map <code>get</code> API</a></h2>
<p>A <em>map</em> (aka an <em>associative array</em> or <em>symbol table</em>) is a data structure that stores key-value pairs.
Keys are unique and values can be quickly looked up by key.</p>
<p>Rust's <code>BTreeMap</code><sup class="footnote-reference" id="fr-BTreeMap-2"><a href="#footnote-BTreeMap">2</a></sup> is an <em>ordered map</em>, it supports any key type that has a notion of <em>total order</em><sup class="footnote-reference" id="fr-TotalOrder-1"><a href="#footnote-TotalOrder">3</a></sup>.
Colloquially, that means keys can be compared with logical operators (<code>&gt;</code>, <code>&lt;=</code>, <code>==</code>, etc) and sorted.
Because they implement the <code>Ord</code> trait.
If keys can't be ordered but are hashable, you'd want to use a <code>HashMap</code><sup class="footnote-reference" id="fr-HashMap-1"><a href="#footnote-HashMap">4</a></sup> instead.</p>
<p>Say we want to perform a lookup in an ordered map - to get the value associated with a given key, if any.
A <code>get</code> method should take a reference to a key as input, and return an <code>Option</code> (containing a value reference for the <code>Some</code> case, when the key is found).</p>
<p>That's how the standard library works, here's the official example<sup class="footnote-reference" id="fr-BTreeMapGet1-1"><a href="#footnote-BTreeMapGet1">5</a></sup>:</p>
<pre><code class="language-rust noplaypen">use std::collections::BTreeMap;

let mut map = BTreeMap::new();
map.insert(1, "a");
assert_eq!(map.get(&amp;1), Some(&amp;"a"));
assert_eq!(map.get(&amp;2), None);</code></pre>
<p>Based on the above, you might expect the <code>get</code> method's signature to look like this for <code>BTreeMap&lt;K, V&gt;</code>:</p>
<pre><code class="language-rust ignore">impl&lt;K, V&gt; BTreeMap&lt;K, V&gt; {
    /// Returns a reference to the value corresponding to the key.
    pub fn get(&amp;self, key: &amp;K) -&gt; Option&lt;&amp;V&gt;
    where
        K: Ord
    {
        // ...function body here...
    }
    // ... rest of the methods
}
</code></pre>
<p>But it doesn't.
The real <code>get</code> method has this signature<sup class="footnote-reference" id="fr-BTreeMapGet2-1"><a href="#footnote-BTreeMapGet2">6</a></sup>:</p>
<pre><code class="language-rust ignore">impl&lt;K, V&gt; BTreeMap&lt;K, V&gt; {
    /// Returns a reference to the value corresponding to the key.
    pub fn get&lt;Q&gt;(&amp;self, key: &amp;Q) -&gt; Option&lt;&amp;V&gt;
    where
        K: Borrow&lt;Q&gt; + Ord,
        Q: Ord + ?Sized,
    {
        // ...function body here...
    }
    // ... rest of the methods
}</code></pre>
<p>Why are there two different generics types at play?
And what are all those strange looking trait bounds?</p>
<p>Let's build our way up to answering those questions by explaining each trait individually.
If you can understand this API, you're well on your way to understanding idiomatic use of traits in general.</p>
<h3 id="the-ord-trait"><a class="header" href="#the-ord-trait">The <code>Ord</code> Trait</a></h3>
<p><code>Ord</code><sup class="footnote-reference" id="fr-Ord-1"><a href="#footnote-Ord">7</a></sup> is the simplest of the three traits in <code>get</code>'s signature, and one we've already discussed.
When a type implements <code>Ord</code>, it can be ordered<sup class="footnote-reference" id="fr-TotalOrd-1"><a href="#footnote-TotalOrd">8</a></sup>.
We can compare one value of this type to another and determine if the two are equal or if one is greater than the other.
This enables us to sort values.</p>
<p>Back in Chapter 3, we implemented the <code>Ord</code> trait for a structure representing an OS process.
This allowed sorting a list of processes by a specific definition of priority (the process's current state, in our case).</p>
<h3 id="the-sized-trait"><a class="header" href="#the-sized-trait">The <code>Sized</code> Trait</a></h3>
<p><code>Sized</code><sup class="footnote-reference" id="fr-Sized-1"><a href="#footnote-Sized">9</a></sup> is something known as a <em>marker trait</em>.
Unlike <code>Ord</code>, there's no "interface" methods to implement because <code>Sized</code> has no behavior of its own.
Marker traits <em>mark a property</em> instead of <em>specifying behavior</em> (plot twist!).</p>
<p>The trait bounds <code>T: Sized</code> tells the compiler that all values of type <code>T</code> have the same size in memory and that this size is known at compile time<sup class="footnote-reference" id="fr-Sizedness-1"><a href="#footnote-Sizedness">10</a></sup>.
For example, a <code>u32</code> is always 4 bytes long.</p>
<p>Here's where things get interesting: <code>T: ?Sized</code>, the binding used in the above signature (note the leading <code>?</code>), means values of type <code>T</code> are <em>optionally sized</em> - they <em>may or may not</em> be <code>Sized</code>.
Doesn't that seem weirdly ambiguous?</p>
<p>Turns out the ambiguity buys flexibility without introducing any UB.
The standard library designers wanted to handle both the common case and the exception.
The majority of types in Rust are sized, but a handful aren't.
Examples of unsized types include:</p>
<ul>
<li>
<p><strong>Slices:</strong> An slice, <code>[T]</code>, can contain zero or more contiguous <code>T</code>s - thus different slice values could have different sizes.</p>
<ul>
<li>Note that <code>&amp;[T]</code>, a reference to a slice, is always the size of a <em>fat</em> pointer (regular pointer plus slice length metadata).</li>
</ul>
</li>
<li>
<p><strong>Trait Objects:</strong> Rust has a mechanism for <em>dynamic dispatch</em><sup class="footnote-reference" id="fr-DynDis-1"><a href="#footnote-DynDis">11</a></sup>. The <code>dyn</code> keyword indicates a <em>trait object</em>: a value that implements a given trait. That value can be <em>any type</em> and have <em>any size</em>, so long as it implements the trait.</p>
<ul>
<li><code>Box&lt;dyn Error&gt;</code>, for example, is a pointer to an instance of any type implementing <code>Error</code> trait.</li>
</ul>
</li>
</ul>
<p>Now values <em>stored</em> in a collection, like <code>BTreeMap</code> must be <code>Sized</code>.
Otherwise we wouldn't know how to store them in memory.</p>
<p>But because <code>get</code> supports both sized and unsized types as a parameter (<code>Q: ?Sized</code>), <em>searching</em> <code>BTreeMap</code> is flexible.
We can find values associated with <em>sized keys</em> using <em>unsized keys</em> of a corresponding type.
We'll see a concrete example toward the end of this section.</p>
<h3 id="the-borrow-trait"><a class="header" href="#the-borrow-trait">The <code>Borrow</code> Trait</a></h3>
<p>A type that implements <code>Borrow&lt;T&gt;</code><sup class="footnote-reference" id="fr-Borrow-1"><a href="#footnote-Borrow">12</a></sup> can <em>borrow</em> a <em>reference</em>, <code>&amp;T</code>.
Unlike the similar trait <code>AsRef</code><sup class="footnote-reference" id="fr-AsRef-1"><a href="#footnote-AsRef">13</a></sup>, <code>Borrow</code> requires that the borrowed <code>&amp;T</code> have the same comparison and hash semantics as <code>T</code>.
Sounds relevant to <code>BTreeMap</code> (lookup via a sequence of comparisons) and <code>HashMap</code>s (lookup via a hash), right?</p>
<p>It very much is - the <code>Borrow</code> trait is designed to make collection lookups easier and more efficient.
In fact, the standard library includes a "blanket implementation" (always pre-implemented trait) for all types <code>T</code> to be able to borrow themselves (meaning we get <code>T: Borrow&lt;T&gt;</code> for "free").</p>
<p>This enables key lookups without having to create a copy of the key in memory.
So no need for additional heap allocations if searching a <code>BTreeMap&lt;String, T&gt;</code> by a key of type <code>&amp;str</code>.</p>
<h2 id="putting-it-all-together"><a class="header" href="#putting-it-all-together">Putting it all together</a></h2>
<p>To really grok how <code>Ord</code>, <code>Sized</code>, and <code>Borrow</code> impact API usage in combination, let's walk through an example.</p>
<p>Say we store 8-byte hexspeak<sup class="footnote-reference" id="fr-Hexspeak-1"><a href="#footnote-Hexspeak">14</a></sup> words, e.g. values of type <code>[u8; 8]</code>, in a set.
We later get a list of user-provided hexspeak words of varying sizes, e.g. values of type <code>Vec&lt;u8&gt;</code>.
Some may be 8 bytes long, others may not.</p>
<p>We want to be able to use the <code>get</code> method to check if any user-provided words are already in our set.
Luckily, <code>get</code> lets us search for <em>slices</em> (unsized <code>[u8]</code>).
We can use the arbitrarily-sized, user-provided words as search keys for our set of fixed-size (8-byte words)!</p>
<pre><code class="language-rust noplaypen">use std::collections::BTreeSet;

// Two hexspeak words
let bad_code: [u8; 8] = [0xB, 0xA, 0xA, 0xD, 0xC, 0x0, 0xD, 0xE];
let bad_food: [u8; 8] = [0xB, 0xA, 0xA, 0xD, 0xF, 0x0, 0x0, 0xD];

// Note we're about to store uniformly sized values in our set
assert_eq!(std::mem::size_of_val(&amp;bad_code), 8);
assert_eq!(std::mem::size_of_val(&amp;bad_food), 8);

// Store the two words in our set
let mut set = BTreeSet::new();
set.insert(bad_code);
set.insert(bad_food);

// Vec&lt;u8&gt; is sized, it's actually a fat pointer to a heap buffer.
// But slices of the vec are unsized! For example:
//     &amp;my_vec[0..5] is the first 5 elements
//     &amp;my_vec[1..] is all but the first element
//     &amp;my_vec[..] is all elements
let bad_food_vec: Vec&lt;u8&gt; = vec![0xB, 0xA, 0xA, 0xD, 0xF, 0x0, 0x0, 0xD];
let bad_dude_vec: Vec&lt;u8&gt; = vec![0xB, 0xA, 0xA, 0xD, 0xD, 0x0, 0x0, 0xD];
let cafe_bad_food_vec: Vec&lt;u8&gt; = vec![
    0xC, 0xA, 0xF, 0xE, 0xB, 0xA, 0xA, 0xD, 0xF, 0x0, 0x0, 0xD
];

// Search for a [u8; 8] present
assert_eq!(
    set.get(&amp;bad_food_vec[..]),         // 0xBAADFOOD
    Some(&amp;[0xB, 0xA, 0xA, 0xD, 0xF, 0x0, 0x0, 0xD])
);

// Search for a [u8; 4] not present
assert_eq!(
    set.get(&amp;bad_food_vec[..4]),        // 0xBAAD
    None
);

// Search for an [u8; 8] not present
assert_eq!(
    set.get(&amp;bad_dude_vec[..]),         // 0xBAADDUDE
    None
);

// Search for a [u8; 8] present
assert_eq!(
    set.get(&amp;cafe_bad_food_vec[4..]),   // 0xBAADF00D
    Some(&amp;[0xB, 0xA, 0xA, 0xD, 0xF, 0x0, 0x0, 0xD]),
);

// Search for a [u8; 12] not present
assert_eq!(
    set.get(&amp;cafe_bad_food_vec[..]),    // 0xCAFEBAADF00D
    None
);</code></pre>
<p>So what happened to enable searching fixed-length set elements (<code>[u8; 8]</code>) using arbitrary length (<code>[u8]</code>) keys?
Consider what the compiler converted our generic <code>get</code> callsites into, through the magic of monomorphization:</p>
<pre><code class="language-rust ignore">pub fn get(&amp;self, key: &amp;[u8]) -&gt; Option&lt;&amp;[u8; 8]&gt;
{
    // ...function body of code in our compiled binary...
}</code></pre>
<ul>
<li>
<p><strong><code>Ord</code> and <code>Sized</code></strong> - The trait bound <code>Q: Ord + ?Sized</code> means we're free to search using an arbitrarily sized slice, so long as the slice's contents can be sorted. <code>[u8]</code> meets that criteria. In the above, we converted user-provided vectors into slices.</p>
</li>
<li>
<p><strong><code>Ord</code> and <code>Borrow</code></strong> - The trait bound <code>K: Borrow&lt;Q&gt; + Ord</code> enables that conversion. We can search using any key that can borrow the aforementioned arbitrarily-sized-and-sortable slice. A <code>Vec</code> can view its elements as a contiguous slice, regardless of how many are stored. Since <code>Vec&lt;T&gt;</code> implements <code>Borrow&lt;[T]&gt;</code>, <code>Vec</code> can also borrow that slice from itself (no data copied!). Thus <code>&amp;my_vec[..]</code> (slicing notation shorthand for <code>my_vec.as_slice()</code>) lets us pass in an <code>&amp;[u8]</code> key to search for.</p>
</li>
</ul>
<p>In conclusion, <code>BTreeMaps</code>'s <code>get</code> combines three traits (<code>Ord</code>, <code>?Sized</code>, and <code>Borrow</code>) to enable flexible, efficient APIs.</p>
<h3 id="taking-it-a-step-further-the-default-trait"><a class="header" href="#taking-it-a-step-further-the-default-trait">Taking It a Step Further: The <code>Default</code> Trait</a></h3>
<p>The library we build will bring a fourth trait into the mix: <code>Default</code><sup class="footnote-reference" id="fr-Default-1"><a href="#footnote-Default">15</a></sup>.
Like it sounds, this trait is for types that have a default value.
For example:</p>
<ul>
<li>
<p>The default for <code>isize</code> is <code>0</code>.</p>
</li>
<li>
<p>The default for <code>Option</code> is <code>None</code>.</p>
</li>
<li>
<p>The default for any dynamic collection (<code>Vec</code>, <code>BTreeSet</code>, <code>HashMap</code>, etc) is an empty instance of that collection.</p>
</li>
</ul>
<p>Our API will look like this:</p>
<pre><code class="language-rust ignore">/// Returns a reference to the value corresponding to the key.
pub fn get&lt;Q&gt;(&amp;self, key: &amp;Q) -&gt; Option&lt;&amp;V&gt;
where
    K: Borrow&lt;Q&gt; + Ord + Default,
    Q: Ord + Default + ?Sized,
{
    // ...function body here...
}</code></pre>
<p>Don't worry, it's easier to use than to read.
Yet the choice to require <code>Default</code> for keys and values is restrictive, users of our library have to ensure the trait is implemented for any custom type they want to store in one of our collections.</p>
<p>Why enforce that sort of limitation?
<code>Default</code> is like a "no argument constructor", it <em>ensures</em> that values of a type are <em>always safely initialized</em>.</p>
<p>It's a requirement for elements stored in <code>tinyvec</code><sup class="footnote-reference" id="fr-TinyVec-1"><a href="#footnote-TinyVec">16</a></sup>, the 3rd party <code>#![forbid(unsafe_code)]</code> library we used for our arena allocator in the previous chapter.
So the <code>Default</code> restriction is inherited from a dependency.</p>
<p>Imposing it is an assurance tradeoff.
We ask a little more of our users in exchange for a 100% safe binary, the guarantee that all our code and all dependencies of our code (e.g. the full library <em>supply chain</em>) maximizes memory safety.</p>
<p>If you are morally opposed to requiring <code>Default</code> and want to remain exactly API-compatible with the standard library, feel free to swap <code>tinyvec</code> for <code>smallvec</code><sup class="footnote-reference" id="fr-SmallVec-1"><a href="#footnote-SmallVec">17</a></sup> in your allocator now and adjust all non-test code for the remainder of this book.
<code>smallvec</code> is another stack-based <code>Vec</code> alternative.
It's used in Mozilla's Servo browser engine.</p>
<p>Unfortunately, <code>smallvec</code> contains <code>unsafe</code> code.
Security researchers have discovered multiple memory safety vulnerabilities in <code>smallvec</code>, for which CVEs have been assigned (e.g. CVE-2021-25900, CVE-2019-15554, CVE-2018-20991, etc).</p>
<p>While <code>smallvec</code> is popular and well-vetted, we can make no guarantee about the number of <em>undiscovered</em> memory safety vulnerabilities still present.
<code>tinyvec</code>, by contrast, will never fall victim to any memory corruption attacks - it's <code>#![forbid(unsafe_code)]</code>.</p>
<blockquote>
<p><strong>Any other traits should I know about?</strong></p>
<p>There isn't an official list of traits every Rust programmer should know.
But you'll almost certainly run into three traits related to memory allocation and deallocation: <code>Clone</code>, <code>Copy</code>, and <code>Drop</code>.
We've touched on some of these before, but they're worth revisiting.</p>
<ul>
<li>
<p><code>Clone</code><sup class="footnote-reference" id="fr-TraitClone-1"><a href="#footnote-TraitClone">18</a></sup> defines <em>deep</em> copy logic. <code>Clone</code> types must be <code>Sized</code>. Cloning could be expensive if the original needs to be recursively traversed - we have to allocate a counterpart to everything it owns.</p>
<ul>
<li>
<p>For example, copying <code>Vec&lt;String&gt;</code> means copying each <code>String</code>. <code>String</code> is a <code>Vec&lt;u8&gt;</code> internally, so copying each <code>String</code> means copying each <code>u8</code>. That was only 2 levels of recursion, but <code>Clone</code> could require arbitrarily many.</p>
</li>
<li>
<p>If your code is littered with <code>my_structure.clone()</code> calls, removing them <em>might</em> be a "low-hanging fruit" performance optimization. If you can refactor flows of ownership to process primarily references (e.g. replace <code>String</code> with <code>&amp;str</code>), you <em>might</em> save a precious time and memory. "Might" stems from the fact that performance optimizations need to be data driven, not premature. We'll cover micro-benchmarking in Chapter 12.</p>
</li>
</ul>
</li>
<li>
<p><code>Copy</code><sup class="footnote-reference" id="fr-TraitCopy-1"><a href="#footnote-TraitCopy">19</a></sup> is a marker trait for types that can be fully cloned with only a <em>shallow</em> byte-by-byte copy. That means there's no pointers to follow or external resources to duplicate a handle to.</p>
<ul>
<li>
<p>Consider <code>isize</code>, the platform-specific signed integer type. If we duplicate the small chunk of fixed-sized, consecutive bytes that encodes the integer's value then we get a complete replica of the original.</p>
</li>
<li>
<p><code>Copy</code> should be implemented sparingly. It means the assignment operator, <code>=</code>, will copy bytes (implicit "copy semantics") instead of just transferring ownership ("move semantics").</p>
</li>
</ul>
</li>
<li>
<p><code>Drop</code><sup class="footnote-reference" id="fr-TraitDrop-1"><a href="#footnote-TraitDrop">20</a></sup> defines a "destructor". User-definable deallocation logic, called when a variable of the implementing type goes out of scope. All memory and shared resources must be freed. Types that implement <code>Copy</code> are not allowed to implement <code>Drop</code> (these should be mutually exclusive - bitwise copyable memory can be bitwise erased).</p>
<ul>
<li>Note that if the scope of a variable's binding depends on conditional statements, move semantics will be tracked at runtime. The value can be moved here and there, based on which branch is taken, as the program runs. But in the end Rust will only drop it <em>once</em> - when the last-moved location goes out of scope.</li>
</ul>
</li>
</ul>
</blockquote>
<h2 id="takeaway"><a class="header" href="#takeaway">Takeaway</a></h2>
<p>As mere users of the standard library's <code>BTreeSet</code>/<code>BTreeMap</code>, the nuances of <code>Ord</code>, <code>?Sized</code>, and <code>Borrow</code> would likely be lost on us.
We could have long and prosperous careers without ever having to think about why a map <code>get</code> signature looks like it does.</p>
<p>But as designers and implementers of an API-compatible alternative, we want to empower our users with the same flexible abstractions the standard library provides.
That entails understanding these traits and how they interact.</p>
<p>The hexspeak example above wouldn't even have compiled if the standard library used the more intuitive signature we started this section with (<code>pub fn get&lt;K: Ord&gt;(&amp;self, key: &amp;K) -&gt; Option&lt;&amp;V&gt;</code>).
So the complexity we've covered has a major payoff: the same code seamlessly supports a broader range of use cases.</p>
<p>With all that trait binding background behind us, we know how and why specific interfaces are designed a certain way.
Now let's tackle the logic backing them: the core operations of our self-balancing scapegoat tree.</p>
<hr>
<ol class="footnote-definition"><li id="footnote-BTreeSet">
<p><a href="https://doc.rust-lang.org/stable/std/collections/struct.BTreeSet.html"><em>Struct <code>std::collections::BTreeSet</code></em></a>. The Rust Team (Accessed 2022). <a href="#fr-BTreeSet-1">↩</a></p>
</li>
<li id="footnote-BTreeMap">
<p><a href="https://doc.rust-lang.org/std/collections/struct.BTreeMap.html"><em>Struct <code>std::collections::BTreeMap</code></em></a>. The Rust Team (Accessed 2022). <a href="#fr-BTreeMap-1">↩</a> <a href="#fr-BTreeMap-2">↩2</a></p>
</li>
<li id="footnote-TotalOrder">
<p><a href="https://en.wikipedia.org/wiki/Total_order">Total order</a> Wikipedia (Accessed 2022). <a href="#fr-TotalOrder-1">↩</a></p>
</li>
<li id="footnote-HashMap">
<p><a href="https://doc.rust-lang.org/std/collections/struct.HashMap.html"><em>Struct <code>std::collections::HashMap</code></em></a>. The Rust Team (Accessed 2022). <a href="#fr-HashMap-1">↩</a></p>
</li>
<li id="footnote-BTreeMapGet1">
<p><a href="https://doc.rust-lang.org/std/collections/struct.BTreeMap.html#examples-3"><em><code>BTreeMap</code> <code>get</code> API example</em></a>. The Rust Team (Accessed 2022). <a href="#fr-BTreeMapGet1-1">↩</a></p>
</li>
<li id="footnote-BTreeMapGet2">
<p><a href="https://doc.rust-lang.org/std/collections/struct.BTreeMap.html#method.get"><em><code>BTreeMap</code> <code>get</code> API</em></a>. The Rust Team (Accessed 2022). <a href="#fr-BTreeMapGet2-1">↩</a></p>
</li>
<li id="footnote-Ord">
<p><a href="https://doc.rust-lang.org/std/cmp/trait.Ord.html"><em>Trait <code>std::cmp::Ord</code></em></a>. The Rust Team (Accessed 2022). <a href="#fr-Ord-1">↩</a></p>
</li>
<li id="footnote-TotalOrd">
<p><a href="https://en.wikipedia.org/wiki/Total_order">Total order</a> Wikipedia (Accessed 2022). <a href="#fr-TotalOrd-1">↩</a></p>
</li>
<li id="footnote-Sized">
<p><a href="https://doc.rust-lang.org/std/marker/trait.Sized.html"><em>Trait <code>std::marker::Sized</code></em></a>. The Rust Team (Accessed 2022). <a href="#fr-Sized-1">↩</a></p>
</li>
<li id="footnote-Sizedness">
<p><a href="https://github.com/pretzelhammer/rust-blog/blob/master/posts/sizedness-in-rust.md"><em>Sizedness in Rust</em></a>.  pretzelhammer (2020). <a href="#fr-Sizedness-1">↩</a></p>
</li>
<li id="footnote-DynDis">
<p><a href="https://en.wikipedia.org/wiki/Dynamic_dispatch">Dynamic dispatch</a>. Wikipedia (Accessed 2022). One use case for dynamic dispatch is enabling <em>heterogeneous collections</em>. <code>Vec&lt;Box&lt;dyn Error&gt;&gt;</code>, for example, allows us to store a vector of <code>Error</code> objects, potentially of varying types. <a href="#fr-DynDis-1">↩</a></p>
</li>
<li id="footnote-Borrow">
<p><a href="https://doc.rust-lang.org/std/borrow/trait.Borrow.html"><em>Trait <code>std::borrow::Borrow</code></em></a>. The Rust Team (Accessed 2022). <a href="#fr-Borrow-1">↩</a></p>
</li>
<li id="footnote-AsRef">
<p><a href="https://doc.rust-lang.org/std/convert/trait.AsRef.html"><em>Trait <code>std::convert::AsRef</code></em></a>. The Rust Team (Accessed 2022). <a href="#fr-AsRef-1">↩</a></p>
</li>
<li id="footnote-Hexspeak">
<p><a href="https://en.wikipedia.org/wiki/Hexspeak">Hexspeak</a>. Wikipedia (Accessed 2022). <a href="#fr-Hexspeak-1">↩</a></p>
</li>
<li id="footnote-Default">
<p><a href="https://doc.rust-lang.org/std/default/trait.Default.html"><em>Trait <code>std::default::Default</code></em></a>. The Rust Team (Accessed 2022). <a href="#fr-Default-1">↩</a></p>
</li>
<li id="footnote-TinyVec">
<p><a href="https://crates.io/crates/tinyvec"><em><code>tinyvec</code></em></a>. Lokathor (Accessed 2022). <a href="#fr-TinyVec-1">↩</a></p>
</li>
<li id="footnote-SmallVec">
<p><a href="https://crates.io/crates/smallvec"><em><code>smallvec</code></em></a>. Simon Sapin, Ms2ger, Servo project (Accessed 2022). <a href="#fr-SmallVec-1">↩</a></p>
</li>
<li id="footnote-TraitClone">
<p><a href="https://doc.rust-lang.org/std/clone/trait.Clone.html"><em>Trait <code>std::clone::Clone</code></em></a>. The Rust Team (Accessed 2022). <a href="#fr-TraitClone-1">↩</a></p>
</li>
<li id="footnote-TraitCopy">
<p><a href="https://doc.rust-lang.org/std/marker/trait.Copy.html"><em>Trait <code>std::marker::Copy</code></em></a>. The Rust Team (Accessed 2022). <a href="#fr-TraitCopy-1">↩</a></p>
</li>
<li id="footnote-TraitDrop">
<p><a href="https://doc.rust-lang.org/std/ops/trait.Drop.html"><em>Trait <code>std::ops::Drop</code></em></a>. The Rust Team (Accessed 2022). <a href="#fr-TraitDrop-1">↩</a></p>
</li>
</ol>
                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../chp4/safe_rust_PLACEHOLDER.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../chp12/diff_fuzz_PLACEHOLDER.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../chp4/safe_rust_PLACEHOLDER.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../chp12/diff_fuzz_PLACEHOLDER.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
