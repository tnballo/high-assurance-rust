<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Dynamic Assurance (2/3) - High Assurance Rust: Developing Secure and Robust Software</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="../highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="../tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->

        <!-- MathJax -->
        <script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "../";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">High Assurance Rust: Developing Secure and Robust Software</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/tnballo/high-assurance-rust" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        <a href="https://highassurance.rs/engage.html#submit-feedback-questions-issues-or-prs" title="Suggest an edit" aria-label="Suggest an edit">
                            <i id="git-edit-button" class="fa fa-edit"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <meta name="title" content="High Assurance Rust">
<meta name="description" content="Developing Secure and Robust Software">
<meta property="og:title" content="High Assurance Rust">
<meta property="og:description" content="Developing Secure and Robust Software">
<meta property="og:type" content="article">
<meta property="og:url" content="https://highassurance.rs/">
<meta property="og:image" content="https://highassurance.rs/img/har_logo_social.png">
<meta name="twitter:title" content="High Assurance Rust">
<meta name="twitter:description" content="Developing Secure and Robust Software">
<meta name="twitter:url" content="https://highassurance.rs/">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://highassurance.rs/img/har_logo_social.png">
<h1 id="dynamic-assurance-2-of-3"><a class="header" href="#dynamic-assurance-2-of-3">Dynamic Assurance (2 of 3)</a></h1>
<p>Like any stream cipher, RC4 needs to generate a <em>keystream</em> and bitwise XOR it with <em>plaintext</em> to create <em>ciphertext</em>. That's how encryption works.</p>
<ul>
<li>
<p><em>Keystream</em> - data that is reproducible but indistinguishable from random.</p>
</li>
<li>
<p><em>Plaintext</em> - unencrypted data.</p>
</li>
<li>
<p><em>Ciphertext</em> - encrypted data.</p>
</li>
</ul>
<p>Keystream generation is implemented using a buffer to represent <em>cipher state</em>.
Mechanically, RC4's cipher state is a 256 byte array, named <code>s</code>, and indexed with two variables, <code>i</code> and <code>j</code>.
Our first step is creating a structure to store this ever-changing state and the current values of its indexes.
We'll want to add the following at the top of <code>crypto_tool/rc4/src/lib.rs</code>:</p>
<pre><code class="language-rust ignore">#![cfg_attr(not(test), no_std)]
#![forbid(unsafe_code)]

#[derive(Debug)]
pub struct Rc4 {
    s: [u8; 256],
    i: u8,
    j: u8,
}</code></pre>
<ul>
<li>
<p>The first 2 lines are <em>attributes</em>: they communicate with the compiler to configure our project.</p>
</li>
<li>
<p><code>#![cfg_attr(not(test), no_std)]</code> is a conditional attribute. It applies to the whole crate and informs the compiler that, unless doing a <code>test</code> build, our library makes no assumptions about the system it's going to run on.</p>
<ul>
<li><code>no_std</code> roughly translates to "don't depend on a standard library or runtime support being available". Although this restricts us to a set of core Rust features, it makes our code portable for embedded use cases: firmware, bootloaders, kernels, etc. We'll discuss <code>#![no_std]</code> more thoroughly in Chapter 4.</li>
</ul>
</li>
<li>
<p><code>#![forbid(unsafe_code)]</code> is an unconditional attribute. It again applies to the entire crate, telling the compiler to <em>ensure</em> the library has no <code>unsafe</code> code blocks. This allows our code to maximize Rust's memory safety guarantees, even if we refactor it or add new features later.</p>
<ul>
<li>We'll discuss <code>unsafe</code> throughout the book, but won't use this keyword in our main project.</li>
</ul>
</li>
<li>
<p><code>#[derive(Debug)]</code> is a <em>derive macro</em> for something called a <em>trait</em> (definition of shared behavior, explained in Chapter 3). Macros generate additional code. Writing macros is an advanced topic, but you can leverage existing macros even as a beginner<sup class="footnote-reference" id="fr-BeginMacro-1"><a href="#footnote-BeginMacro">1</a></sup>.</p>
<ul>
<li>Notice how <code>#[derive(Debug)]</code> sits atop the <code>Rc4</code> structure? It only applies to this structure, telling the compiler how to pretty print its contents to a console<sup class="footnote-reference" id="fr-TraitDebug-1"><a href="#footnote-TraitDebug">2</a></sup>. Using this macro makes our stream cipher convenient to visually debug in test builds.</li>
</ul>
</li>
<li>
<p>The <code>Rc4</code> structure is the most important part of the above code. Though not an <em>object</em> in the traditional sense<sup class="footnote-reference" id="fr-Obj-1"><a href="#footnote-Obj">3</a></sup>, our structure encapsulates private data and we're going to define methods that operate on that data next. <code>Rc4</code>'s three fields are:</p>
<ul>
<li>
<p><code>s</code>: cipher state, an array of 256 bytes (unsigned, 8-bit integers - hence <code>u8</code>).</p>
</li>
<li>
<p><code>i</code>: "incrementing" index for key stream generation.</p>
</li>
<li>
<p><code>j</code>: "jumping" index for key stream generation.</p>
</li>
</ul>
</li>
</ul>
<p>We're now ready to implement the two halves of RC4's logic: KSA and PRGA.</p>
<blockquote>
<p><strong>WARNING! RC4 is insecure.</strong></p>
<p>Real-world projects need to select a well-audited implementation of a modern, well-tested cipher.
Remember, we've chosen RC4 for this chapter's example because it's relatively easy to implement.
RC4 isn't suitable for professional projects.</p>
</blockquote>
<h2 id="1-the-key-scheduling-algorithm-ksa"><a class="header" href="#1-the-key-scheduling-algorithm-ksa">1. The Key-Scheduling Algorithm (KSA)</a></h2>
<p>The goal of RC4's KSA step is initializing the cipher state array by computing a <em>permutation</em> influenced by a variable-length (40 to 2,048 bit) secret key.</p>
<p>It's best to put this logic in <code>Rc4</code>'s constructor.
So that a library user doesn't have to remember to call a special initialization function before encrypting data.
The cipher instance returned by the constructor will already be initialized.</p>
<blockquote>
<p><strong>Function-related Terminology</strong></p>
<p>This section will use two technical terms.
The concepts aren't unique to Rust, but the terms have specific meaning in Rust programs:<sup class="footnote-reference" id="fr-AssocMeth-1"><a href="#footnote-AssocMeth">4</a></sup></p>
<ul>
<li>
<p><strong>Associated function:</strong> A function that is defined on a structure, but <em>does not</em> take <code>&amp;self</code> (reference to instance of structure) as its first parameter. It doesn't read or write structure fields.</p>
</li>
<li>
<p><strong>Method:</strong> A function defined on a structure that <em>does</em> take <code>&amp;self</code> or <code>&amp;mut self</code> as the first parameter. It reads and/or writes fields on a specific instance of a structure.</p>
</li>
</ul>
</blockquote>
<p>By convention, Rust constructors are <em>associated functions</em> (no <code>self</code> parameter) named <code>new</code> that return an instance of the structure being constructed.</p>
<p>Let's add one that performs KSA, right below the <code>Rc4</code> structure definition.
Notice we define <code>new</code> inside an <code>impl Rc4</code> block, tying it to the structure of the same name:</p>
<pre><code class="language-rust ignore">impl Rc4 {
    /// Init a new Rc4 stream cipher instance
    pub fn new(key: &amp;[u8]) -&gt; Self {
        // Verify valid key length (40 to 2048 bits)
        assert!(5 &lt;= key.len() &amp;&amp; key.len() &lt;= 256);

        // Zero-init our struct
        let mut rc4 = Rc4 {
            s: [0; 256],
            i: 0,
            j: 0,
        };

        // Cipher state identity permutation
        for (i, b) in rc4.s.iter_mut().enumerate() {
            // s[i] = i
            *b = i as u8;
        }

        // Process for 256 iterations, get starting cipher state permutation
        let mut j: u8 = 0;
        for i in 0..256 {
            // j = (j + s[i] + key[i % key_len]) % 256
            j = j.wrapping_add(rc4.s[i]).wrapping_add(key[i % key.len()]);

            // Swap values of s[i] and s[j]
            rc4.s.swap(i, j as usize);
        }

        // Return our initialized Rc4
        rc4
    }
}</code></pre>
<p>The above code might make you a little uncomfortable.
That's OK.
Learning any new language involves squinting at code you don't fully understand.
And that's usually not a great feeling.</p>
<p>To make matters worse, cryptographic code is just its own weird thing - regardless of the implementation language.
Let's double down and try to make sense of it:</p>
<ul>
<li>
<p><code>new</code> takes a single parameter, <code>key</code>, which is a <em>reference to a slice of bytes</em>. This signature makes passing in key data efficient<sup class="footnote-reference" id="fr-SliceEff-1"><a href="#footnote-SliceEff">5</a></sup> and flexible<sup class="footnote-reference" id="fr-SliceFlex-1"><a href="#footnote-SliceFlex">6</a></sup>. We'll cover slices in Chapter 3.</p>
</li>
<li>
<p>The <code>assert!</code> statement, another macro, ensures the user of our API provides a key of valid length. If not, our program will terminate at this line. That's an aggressive way to handle errors. We'll talk about other options later.</p>
</li>
<li>
<p><code>let mut rc4 = ...</code> creates a <em>mutable</em> instance of our <code>Rc4</code> structure with all fields zero initialized. Variables are immutable by default in Rust. But we'll be setting up cipher state (the <code>s</code> array), we need the <code>mut</code> keyword here.</p>
</li>
<li>
<p>The next bit of code, a <code>for</code> loop identity permutation<sup class="footnote-reference" id="fr-IDPerm-1"><a href="#footnote-IDPerm">7</a></sup>, is just a fancy way to set <code>s[0] = 0, s[1] = 1, s[2] = 2, ..., s[255] = 255</code>. It uses <em>iterators</em>. We'll implement our own iterators in Chapter 10, so let's not dwell on the syntax right now.</p>
</li>
<li>
<p>The subsequent <code>for</code> loop <em>further permutes</em> the cipher state <code>s</code>. Three details worth pointing out:</p>
<ul>
<li>
<p>We have to use the <code>wrapping_add</code> function instead of the addition operator (<code>+</code>) in cryptographic code because we want <em>integer overflow</em> (explanation coming in Chapter 3) to emulate modular arithmetic<sup class="footnote-reference" id="fr-ModArith-1"><a href="#footnote-ModArith">8</a></sup>.</p>
</li>
<li>
<p>Have you ever swapped two variables using a third (probably named <code>temp</code>)? If your answer is "good God, a hundred times" then you'll appreciate how <code>swap</code> is a built-in method for arrays in Rust.</p>
</li>
<li>
<p>Indexes are always register-width unsigned integers in Rust. So, in the call to <code>swap</code>, we promote <code>j</code> (a lowly <code>u8</code>) to a <code>usize</code> with the <code>as</code> keyword. Think of this minor detail as a "safe cast"<sup class="footnote-reference" id="fr-Cast-1"><a href="#footnote-Cast">9</a></sup>.</p>
</li>
</ul>
</li>
<li>
<p>The final line of the <code>new</code> function returns an initialized instance of an <code>Rc4</code> structure. Rust functions don't need the <code>return</code> keyword unless you want to return early (e.g. halfway through the function body) for some reason.</p>
<ul>
<li>The return type of the function (specified right after <code>-&gt;</code>) is <code>Self</code>. Because <code>new</code> is inside an <code>impl Rc4</code> block, this is shorthand for returning an instance of an <code>Rc4</code> structure.</li>
</ul>
</li>
</ul>
<p>Visualizing a round of permutation might make the concept more tangible.
Every loop iteration, <code>i</code> and <code>j</code> change (with <code>j</code> being influenced by the key) and <code>rc4.s.swap(i, j as usize)</code> just switches two values within <code>s</code>:</p>
<br>
<p align="center">
  <img width="100%" src="rc4_1.svg">
  <figure>
  <br>
  <figcaption><center>Visualization of swapping <i><b>s[i]</i></b> and <i><b>s[j]</i></b></center></figcaption><br>
  </figure>
</p>
<h2 id="2-pseudo-random-generation-algorithm-prga"><a class="header" href="#2-pseudo-random-generation-algorithm-prga">2. Pseudo-Random Generation Algorithm (PRGA)</a></h2>
<p>The <code>new</code> function creates and initializes an instance of the <code>Rc4</code> cipher.
We need another function that uses an <code>Rc4</code> instance to generate a keystream.
Once we have a keystream, we can encrypt data with it.</p>
<p><code>prga_next</code> is our keystream generation function, it outputs a single keystream byte each time it's called.
We'll add it right after the <code>new</code> function, inside the same <code>impl Rc4</code> block.</p>
<p>Unlike the <code>new</code> <em>associated function</em>, <code>prga_next</code> is a <em>method</em>.
Methods always take a reference to <code>self</code>, an instance of the structure they're being called on, as their first parameter.</p>
<pre><code class="language-rust ignore">impl Rc4 {
    // ..new() definition omitted..

    /// Output the next byte of the keystream
    pub fn prga_next(&amp;mut self) -&gt; u8 {
        // i = (i + 1) mod 256
        self.i = self.i.wrapping_add(1);

        // j = (j + s[i]) mod 256
        self.j = self.j.wrapping_add(self.s[self.i as usize]);

        // Swap values of s[i] and s[j]
        self.s.swap(self.i as usize, self.j as usize);

        // k = s[(s[i] + s[j]) mod 256]
        self.s[(self.s[self.i as usize].wrapping_add(self.s[self.j as usize])) as usize]
    }
}</code></pre>
<p>This function performs similar operations to the <code>new</code> function, so we don't need to go over it in detail.
We're concerned with getting a taste of Rust, not with the specific operations RC4's design dictates.
There is, however, one detail worth pointing out:</p>
<ul>
<li><code>prga_next</code>'s sole parameter is <code>&amp;mut self</code>, a <em>mutable reference</em> to the <code>Rc4</code> structure on which it will be called. We need the <code>mut</code> keyword here again because this function makes changes to an <code>Rc4</code> struct - it writes indexes <code>i</code> and <code>j</code>, and swaps bytes inside the cipher state buffer <code>s</code>.</li>
</ul>
<p>As an aside - we can visualize that line, outputing <code>k</code>, like so:<sup class="footnote-reference" id="fr-RC4Wiki-1"><a href="#footnote-RC4Wiki">10</a></sup></p>
<br>
<p align="center">
  <img width="100%" src="rc4_2.svg">
  <figure>
  <br>
  <figcaption><center>Visualization of <i><b>k = s[(s[i] + s[j]) mod 256]</i></b></center></figcaption><br>
  </figure>
</p>
<h2 id="3-endecryption"><a class="header" href="#3-endecryption">3. {En,De}cryption</a></h2>
<h3 id="the-classic-flexible-interface"><a class="header" href="#the-classic-flexible-interface">The Classic Flexible Interface</a></h3>
<p>We implement encryption by XORing each <code>prga_next</code> output byte (keystream) with each byte of the plaintext.
Since XOR is reversible, the same function also works for decryption!</p>
<pre><code class="language-rust ignore">impl Rc4 {
    // ..new() definition omitted..

    /// Stateful, in-place en/decryption (current keystream XORed with data).
    /// Use if plaintext/ciphertext is transmitted in chunks.
    pub fn apply_keystream(&amp;mut self, data: &amp;mut [u8]) {
        for b_ptr in data {
            *b_ptr ^= self.prga_next();
        }
    }

    // ..prga_next() definition omitted..
}</code></pre>
<p>Implementing encryption within a <em>method</em> maximizes flexibility: if we receive data in [potentially variable length] chunks, a single instance of <code>Rc4</code> can perform "running" encryption across multiple chunks like so (the below is an API usage example, not part of our <code>Rc4</code> implementation):</p>
<pre><code class="language-rust ignore">let key = [0x1, 0x2, 0x3, 0x4, 0x5];

let msg_1 = [0x48, 0x65, 0x6c, 0x6c, 0x6f]; // "Hello"
let msg_2 = [0x20, 0x57, 0x6f, 0x72, 0x6c, 0x64, 0x21]; // " World!"

// Encrypt in-place
let mut rc4 = Rc4::new(&amp;key);
rc4.apply_keystream(&amp;mut msg_1);
rc4.apply_keystream(&amp;mut msg_2);

// Decrypt in-place
let mut rc4 = Rc4::new(&amp;key);
rc4.apply_keystream(&amp;mut msg_1);
rc4.apply_keystream(&amp;mut msg_2);</code></pre>
<p>Most real-world stream cipher libraries use an API like this one.
But it entails subtle complexity: <code>rc4</code> is stateful and must be re-constructed prior to decryption with <code>new</code>.
Moreover, the order of parameters to <code>apply_keystream</code> matters - decryption would produce the incorrect result if we accidentally called <code>rc4.apply_keystream(&amp;mut msg_2)</code> before <code>rc4.apply_keystream(&amp;mut msg_1)</code> in the above.</p>
<h3 id="making-the-common-case-easier"><a class="header" href="#making-the-common-case-easier">Making the Common Case Easier</a></h3>
<p>Implementing encryption within an <em>associated function</em> provides a simpler interface, so long as all the data is in memory at once.
Which might be the case reasonably often.
Notice it's really just a wrapper that hides state from the caller:</p>
<pre><code class="language-rust ignore">impl Rc4 {
    // ..new() definition omitted..

    // ..apply_keystream() definition omitted..

    /// Stateless, in-place en/decryption (keystream XORed with data).
    /// Use if entire plaintext/ciphertext is in-memory at once.
    pub fn apply_keystream_static(key: &amp;[u8], data: &amp;mut [u8]) {
        let mut rc4 = Rc4::new(key);
        rc4.apply_keystream(data);
    }

    // ..prga_next() definition omitted..
}</code></pre>
<p>Now we can en/decrypt with a single method call, no need to worry about the state of an <code>Rc4</code> instance (API usage example below):</p>
<pre><code class="language-rust ignore">let key = [0x1, 0x2, 0x3, 0x4, 0x5];

let msg = [
    0x48, 0x65, 0x6c, 0x6c, 0x6f, 0x20, 0x57, 0x6f,
    0x72, 0x6c, 0x64, 0x21,
]; // "Hello World!"

// Encrypt in-place
Rc4::apply_keystream_static(&amp;key, &amp;mut msg);

// Decrypt in-place
Rc4::apply_keystream_static(&amp;key, &amp;mut msg);</code></pre>
<p>With our two en/decryption functions done, we've now finished implementation.
Time for validation.
Cryptography software really needs to be correct, we can't stop here.
Let's put this code through its paces!</p>
<blockquote>
<p><strong>How can encryption and decryption be the same operation?</strong></p>
<p>In short, because XOR is both reversible and, due to the nature of the keystream, unpredictable:</p>
<ul>
<li>
<p>First, <code>cipher_text = plain_text ^ key_stream</code> (encryption).</p>
</li>
<li>
<p>Then, <code>plain_text = cipher_text ^ key_stream</code> (decryption).</p>
</li>
<li>
<p>The key stream can flip any bit in the plaintext as if by 50/50 random chance.</p>
</li>
</ul>
<p>For a more mathematically principled treatment, we recommend the proof on page 32 of Paar and Pelzl's <em>Understanding Cryptography</em><sup class="footnote-reference" id="fr-UnderstandingCrypto-1"><a href="#footnote-UnderstandingCrypto">11</a></sup>.
While it's a university textbook, the formalisms are lightweight and precise.
It's an excellent introduction to the field of cryptography.
And the book is supplemented by free video lectures<sup class="footnote-reference" id="fr-UnderstandingCryptoVideo-1"><a href="#footnote-UnderstandingCryptoVideo">12</a></sup>.</p>
</blockquote>
<hr>
<ol class="footnote-definition"><li id="footnote-BeginMacro">
<p>Unlike C macros, Rust macros are <em>hygienic</em>: they won't cause subtle problems by capturing identifiers. This is part of what makes them so easy to use. In fact, <code>println!</code> is a macro. So you already used a macro when running the "Hello world!" program at the end of Chapter 1. <a href="#fr-BeginMacro-1">↩</a></p>
</li>
<li id="footnote-TraitDebug">
<p><a href="https://doc.rust-lang.org/std/fmt/trait.Debug.html"><em>Trait <code>std::fmt::Debug</code></em></a>. The Rust Team (Accessed 2022). <a href="#fr-TraitDebug-1">↩</a></p>
</li>
<li id="footnote-Obj">
<p>In Rust, shared behavior is defined by <em>trait composition</em>, not by <em>object-oriented inheritance</em>. There's no "class hierarchy", like in C++ or Java. We'll cover traits in Chapter 3. <a href="#fr-Obj-1">↩</a></p>
</li>
<li id="footnote-AssocMeth">
<p>Technically, per the Rust reference<sup class="footnote-reference" id="fr-RustRef-1"><a href="#footnote-RustRef">13</a></sup>, "Associated functions are functions associated with a type" and "Associated functions whose first parameter is named <code>self</code> are called methods...". But that's pretty in the weeds. We treat <em>associated functions</em> and <em>methods</em> as distinct in this section for clarity. <a href="#fr-AssocMeth-1">↩</a></p>
</li>
<li id="footnote-SliceEff">
<p>Slice references are "fat pointers" (tuple of pointer and element count), they allow us to pass variable-length data without copying it (recall "pass-by-reference", from when we first talked about pointers). <a href="#fr-SliceEff-1">↩</a></p>
</li>
<li id="footnote-SliceFlex">
<p>Slices are flexible because different kinds of collections (say, a fixed-size array or dynamically-sized vector) can be "viewed" through a slice. So you'll encounter them often in idiomatic Rust code. <a href="#fr-SliceFlex-1">↩</a></p>
</li>
<li id="footnote-IDPerm">
<p><a href="https://en.wikipedia.org/wiki/Permutation_group#Neutral_element_and_inverses"><em>Neutral element and inverses</em></a>. Wikipedia (Accessed 2022). <a href="#fr-IDPerm-1">↩</a></p>
</li>
<li id="footnote-ModArith">
<p><a href="https://en.wikipedia.org/wiki/Modular_arithmetic"><em>Modular arithmetic</em></a>. Wikipedia (Accessed 2022). <a href="#fr-ModArith-1">↩</a></p>
</li>
<li id="footnote-Cast">
<p>There are best practices related to casting in Rust. Namely using traits <code>From</code> and <code>Into</code> for <em>infallible</em> conversions between types, and <code>TryFrom</code> and <code>TryInto</code> for <em>fallible</em> conversions. We'll discus this topic in detail later. <a href="#fr-Cast-1">↩</a></p>
</li>
<li id="footnote-RC4Wiki">
<p><a href="https://en.wikipedia.org/wiki/RC4"><em>RC4</em></a>. Wikipedia (Accessed 2022). <a href="#fr-RC4Wiki-1">↩</a></p>
</li>
<li id="footnote-UnderstandingCrypto">
<p><a href="https://amzn.to/3IEYuNd"><em><strong>[PERSONAL FAVORITE]</strong> Understanding Cryptography</em></a>. Christof Paar, Jan Pelzl (2009). <a href="#fr-UnderstandingCrypto-1">↩</a></p>
</li>
<li id="footnote-UnderstandingCryptoVideo">
<p><a href="https://www.crypto-textbook.com/movies.php"><em>Online Cryptography Course</em></a>. Christof Paar, Jan Pelzl (2009). <a href="#fr-UnderstandingCryptoVideo-1">↩</a></p>
</li>
<li id="footnote-RustRef">
<p><a href="https://doc.rust-lang.org/reference/items/associated-items.html"><em>The Rust Reference: Associated Items</em></a>. The Rust Team (2021). <a href="#fr-RustRef-1">↩</a></p>
</li>
</ol>
                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../chp2/dynamic_assurance_1.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../chp2/dynamic_assurance_3.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../chp2/dynamic_assurance_1.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../chp2/dynamic_assurance_3.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
