<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Rust: High-Level Data (2/6) - High Assurance Rust: Developing Secure and Robust Software</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="../highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="../tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->

        <!-- MathJax -->
        <script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "../";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">High Assurance Rust: Developing Secure and Robust Software</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/tnballo/high-assurance-rust" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        <a href="https://highassurance.rs/engage.html#submit-feedback-questions-issues-or-prs" title="Suggest an edit" aria-label="Suggest an edit">
                            <i id="git-edit-button" class="fa fa-edit"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <meta name="title" content="High Assurance Rust">
<meta name="description" content="Developing Secure and Robust Software">
<meta property="og:title" content="High Assurance Rust">
<meta property="og:description" content="Developing Secure and Robust Software">
<meta property="og:type" content="article">
<meta property="og:url" content="https://highassurance.rs/">
<meta property="og:image" content="https://highassurance.rs/img/har_logo_social.png">
<meta name="twitter:title" content="High Assurance Rust">
<meta name="twitter:description" content="Developing Secure and Robust Software">
<meta name="twitter:url" content="https://highassurance.rs/">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://highassurance.rs/img/har_logo_social.png">
<h1 id="rust-high-level-data-2-of-6"><a class="header" href="#rust-high-level-data-2-of-6">Rust: High-Level Data (2 of 6)</a></h1>
<p>We saw low-level fundamentals in the last section.
They're important and common.
But where Rust really starts to shine is the higher-level constructs: "custom" data types that map more closely to our problem domain.</p>
<p>Rust draws influence from functional languages like ML, OCaml, and Haskell - among others<sup class="footnote-reference" id="fr-RustInfluence-1"><a href="#footnote-RustInfluence">1</a></sup>.
It brings to the table some interesting, perhaps even exotic, constructs.
Features we don't often see in performant systems languages.</p>
<p>We'll ease our way into some of these constructs in this section, assuming no prior familiarity with functional languages.</p>
<h2 id="enums"><a class="header" href="#enums">Enums</a></h2>
<p>Enumerations, "enums" for short, let you define a type whose possible values are a set of named constants.
In their most basic usage, Rust enums are similar to enums present in most other languages.</p>
<p>We're going to be using a running example for the next handful of sections - that of an Operating System (OS) capable of running several processes (in-memory, isolated instances of programs).
To show how constructs of Rust code can map to a specific domain<sup class="footnote-reference" id="fr-TockOS-1"><a href="#footnote-TockOS">2</a></sup>.
And to learn or review a few OS concepts along the way.</p>
<p>Let's assume a process can, at any given time, be in one of three states:</p>
<ol>
<li>
<p><strong>Running</strong> - Currently executing on a CPU core.</p>
</li>
<li>
<p><strong>Stopped</strong> - Suspended indefinitely (perhaps the user pressed <code>Ctrl+Z</code>).</p>
</li>
<li>
<p><strong>Sleeping</strong> - Suspended temporarily (perhaps it's waiting for data, like user input, to become available).</p>
</li>
</ol>
<p>Enums are a natural way to express mutually exclusive but related possibilities.
We can declare a <code>State</code> enum with three <em>variants</em> (named constants <code>Running</code>, <code>Stopped</code>, and <code>Sleeping</code>):</p>
<pre><code class="language-rust noplaypen">pub enum State {
    Running,
    Stopped,
    Sleeping,
}</code></pre>
<p>An OS needs to take different actions depending on what state a process is currently in.
For example, when an internal timer goes off (e.g. an "interrupt fires"), it may be time to stop a currently running process, save its state, and run/restore a different process.
CPU time is a shared resource, processes need to take turns.</p>
<p>Rust supports <em>pattern matching</em> as a means to conditionally decide which logic should be executed.
One common use is matching on the variant of an enum.
For example, the OS could execute a different function depending on the state of a process:</p>
<pre><code class="language-rust ignore">fn manage_process(curr_state: State) {
    match curr_state {
        State::Running =&gt; stop_and_schedule_another_process(),
        State::Stopped =&gt; assign_to_available_cpu_core(),
        State::Sleeping =&gt; check_if_data_ready_and_wake_if_so(),
    }
}</code></pre>
<p>Each line inside the <code>match</code> brackets is called an <em>arm</em>.
The <em>pattern</em> is to the left of the arrow operator (<code>=&gt;</code>) and the code executed if the pattern <em>matches</em> is to the right.
We'll discuss pattern matching in more detail in the next section, which covers control flow.</p>
<p>What differentiates Rust enums from those of C, C++, and many other languages is their ability to encapsulate additional data of varying types.
This ability makes Rust enums akin to "sum types" in functional languages (which are a specific kind of "algebraic data type").
In practice, what that means is we have the flexibility to store arbitrary data in each variant.
That data could even be another enum!</p>
<p>Let's say we had design requirements for a more granular process state representation.
Specifically, say an OS needs to:</p>
<ul>
<li>
<p>Track two kinds of stop requests: those that can be ignored by the process and those that can't.</p>
</li>
<li>
<p>Record a start timestamp for sleeping processes, to later calculate how long a sleeping process has been inactive.</p>
</li>
</ul>
<p>We could replace our <code>State</code> enum with a <code>DetailedState</code> that reflects the new requirements:</p>
<pre><code class="language-rust noplaypen">#[derive(Debug, PartialEq, Eq, PartialOrd, Ord)]
pub enum StopKind {
    Mandatory, // Linux SIGSTOP
    Ignorable, // Linux SIGTSTP
}

pub enum DetailedState {
    Running,
    Stopped { reason: StopKind },
    Sleeping { start_time: u64 },
}</code></pre>
<p>Notice how the <code>Stopped</code> variant now contains another enum (<code>StopKind</code> - ignore the <code>#[derive(...</code> above it for now) and the <code>Sleeping</code> variant now contains a <code>u64</code> timestamp (akin to UNIX's epoch representation<sup class="footnote-reference" id="fr-Epoch-1"><a href="#footnote-Epoch">3</a></sup>).
Yet the <code>Running</code> variant remains empty.</p>
<p>We can freely choose data types encapsulated within variants and can still "pull out" the inner type when matching.
The below snippet is a test where the first arm checks the <code>Stopped</code> variant's inner data.
The second arm uses a wildcard (<code>_</code>) to assert that this test won't match against any other variants (since <code>state</code> is hardcoded).</p>
<pre><code class="language-rust ignore">#[test]
fn test_detailed_stop_match() {
    let state = DetailedState::Stopped {
        reason: StopKind::Mandatory,
    };
    match state {
        DetailedState::Stopped { reason } =&gt; {
            assert_eq!(reason, StopKind::Mandatory);
        }
        _ =&gt; unreachable!(), // Will panic at runtime if reached
    }
}</code></pre>
<p>One devilish detail: the in-memory size of an enum is determined by its largest variant.
An instance of the <code>Running</code> variant is the same size as an instance of <code>Sleeping</code> variant, despite the latter holding more information.
Memory layout isn't something you'll need to think about often, but it's worth noting.
We may be using fancy sum types, but we're still writing low-level code.</p>
<h2 id="structures"><a class="header" href="#structures">Structures</a></h2>
<p>Structures, specifically name-field structs like the below, are the primary way you'll represent data in most Rust programs.
Rust structs serve the same purpose as Python classes or Java objects - they're a way to group data and functions that operate on that data<sup class="footnote-reference" id="fr-EnumAside-1"><a href="#footnote-EnumAside">4</a></sup>.</p>
<p>One of main responsibilities of an OS kernel is <em>task scheduling</em> - deciding which process (or its threads) should be running on which CPU core and for how long.
Many programs are composed of multiple processes, a <em>parent process</em> can create one or more <em>child processes</em>.</p>
<p>If we were implementing an OS, we'd likely want to group process-relevant data into a struct.
A simplified example<sup class="footnote-reference" id="fr-LinuxTaskStruct-1"><a href="#footnote-LinuxTaskStruct">5</a></sup> could look like this:</p>
<pre><code class="language-rust ignore">pub struct Proc {
    pid: u32,           // Process ID (unsigned integer)
    state: State,       // Current state (enum)
    children: Vec&lt;u32&gt;, // Child IDs (dynamic list)
}</code></pre>
<blockquote>
<p><strong>How do multiprocess programs work?</strong></p>
<p>One program (parent process) can start (e.g. "spawn") a second helper program (child process).
If the helper is doing independent work, they can both run <em>simultaneously</em> on a modern, multi-core system.
The parent runs on one core while the child runs on another.</p>
<p>That's what helps your web browser feel faster and more responsive.
By default, the Chromium runs one process per website connected to<sup class="footnote-reference" id="fr-ChromeProc-1"><a href="#footnote-ChromeProc">6</a></sup>.</p>
</blockquote>
<p>The <code>Proc</code> struct represents a concept from our problem domain (the idea of an OS-managed process) as typed data.
To make working with the data easier, we'd likely add methods (have <code>self</code> parameter) and associated functions (no <code>self</code> parameter) - just like we did with the <code>Rc4</code> struct in the last chapter.
Both types of functions must be defined within a struct's <code>impl</code> block.
For example:</p>
<pre><code class="language-rust ignore">impl Proc {
    /// Associated function (constructor)
    pub fn new(pid: u32) -&gt; Self {
        Proc {
            pid,
            state: State::Stopped,
            children: Vec::new()
        }
    }

    /// Method (takes self, mutable setter in this case)
    pub fn set_state(&amp;mut self, new_state: State) {
        self.state = new_state;
    }

    // ...more methods/functions here
}</code></pre>
<p>Note that named fields (<code>pid</code>, <code>state</code>, and <code>children</code>) are private by default.
They can only be accessed by code in the <em>module</em> in which the struct is defined.
Modules are a way to group related code, think of them as Rust's version of namespaces.</p>
<p>If this code were in another module that imported <code>Proc</code>, it would not compile because the private field <code>state</code> cannot be assigned to:</p>
<pre><code class="language-rust ignore">use my_os_module::Proc;

let mut my_proc = Proc::new(0);
my_proc.state = State::Running;</code></pre>
<p>That's why we defined a setter method, the below would work:</p>
<pre><code class="language-rust ignore">use my_os_module::Proc;

let mut my_proc = Proc::new(0);
my_proc.set_state(State::Running);</code></pre>
<p>This manner of <em>data encapsulation</em><sup class="footnote-reference" id="fr-DataEncap-1"><a href="#footnote-DataEncap">7</a></sup> is considered a best practice for public APIs.
But it's not required, nor is it always appropriate.
If we wanted <code>state</code> to be writable by external code (e.g. <code>my_proc.state = State::Running;</code> to work), we could use the <code>pub</code> visibility specifier at declaration:</p>
<pre><code class="language-rust ignore">pub struct Proc {
    pid: u32,           // Process ID (unsigned integer)
    pub state: State,   // Current state (enum)
    children: Vec&lt;u32&gt;, // Child IDs (dynamic list)
}</code></pre>
<p>We'll discuss modules and visibility later in this chapter.</p>
<p>Notice how Rust takes a conservative approach: external visibility, mutability, and unsafety all require explicit opt-in.
This is a conscious design choice that helps reduce potential sources of error in large programs.</p>
<h2 id="generics"><a class="header" href="#generics">Generics</a></h2>
<p>We've already used a generic library: standard's <code>Vec</code>.
It's defined as <code>Vec&lt;T&gt;</code>, where <code>T</code> is a generic type.
That's why we can have both a vector of unsigned integers (<code>Vec&lt;usize&gt;</code>) and a vector of strings (<code>Vec&lt;String&gt;</code>), without needing to use a different library API for each type of item we want to store.</p>
<p>Imagine that instead of writing a single hobby OS for yourself, you're actually writing a reusable scheduling library - code that can potentially be leveraged by anyone writing an OS.
This is where <em>generics</em> would come in.
Instead of creating a specific instance of a structure or function, you can define a <em>template</em> that users of your code can plug <em>types</em> into.
Including custom types defined in by external code written in the future!</p>
<p>Maybe some of your users are writing an OS for tiny embedded devices that will never have more than 100 processes running simultaneously.
They need to save precious memory by using a <code>u8</code> to represent <code>pid</code>, instead of a <code>u32</code>.
But we can't just change <code>pid</code>'s type to a <code>u8</code> - other users need to represent thousands of processes.
Updating <code>Proc</code>'s definition and implementation to be generic lets us accommodate both groups:</p>
<pre><code class="language-rust ignore">pub struct Proc&lt;T&gt; {
    pid: T,             // Process ID (generic)
    pub state: State,   // Current state (enum)
    children: Vec&lt;T&gt;,   // Child IDs (dynamic list, generic)
}

impl&lt;T&gt; Proc&lt;T&gt; {
    // Associated function (constructor)
    pub fn new(pid: T) -&gt; Self {
        Proc {
            pid,
            state: State::Stopped,
            children: Vec::new()
        }
    }

    // ...more methods/functions here
}</code></pre>
<p>The resource-constrained users can specify <code>let mut my_proc: Proc&lt;u8&gt; = Proc::new(0);</code>, others can use <code>let mut my_proc: Proc&lt;u32&gt; = Proc::new(0);</code>.
Our code becomes flexible enough to work for either.</p>
<blockquote>
<p><strong>How do generics work in the final binary?</strong></p>
<p>The Rust compiler implements generics via <em>monomorphization</em>.
For each concrete type (like <code>u8</code>) used at any callsite, the compiler generates specialized code in the output binary.
So generics have no runtime cost - each unique <code>T</code> "template" creates one "stamp" (unique code) in the final executable.</p>
</blockquote>
<p>Generics are a core feature of Rust, you'll see them often.
Coupled with traits, they enable the creation of reusable, maintainable software components.</p>
<h2 id="traits"><a class="header" href="#traits">Traits</a></h2>
<p>The constructs we've discussed thus far haven't been that drastic a departure from the mainstream.
Rust's enums and pattern matching likely feel like an extension of language features you're already familiar with.
Traits are where, for many readers, Rust will start to feel significantly different.</p>
<p>We previously said that Rust structs fill the same role as Python classes and Java objects.
But unlike both of those languages, Rust doesn't support <em>inheritance</em>.
There are no class hierarchies, a struct can't inherit fields or methods from a parent.</p>
<p>Instead, shared behavior is defined by <em>composition</em>, via <em>traits</em>.
Some consider this approach a best practice, even in object-oriented languages<sup class="footnote-reference" id="fr-Composition-1"><a href="#footnote-Composition">8</a></sup>.</p>
<p>In terms of code-level mechanics, a trait is akin to an "abstract base class" in an object-oriented language.
Meaning it defines an interface (set of APIs) that any type implementing the trait must support.</p>
<p>Types can implement one or more traits, and doing so allows the type to be used in any context in which that trait is appropriate.</p>
<blockquote>
<p><strong>What is inheritance, again?</strong></p>
<p>Inheritance, a kind of "subtype polymorphism", allows us to perform limited substitution of two types.</p>
<p>Say a <code>Vehicle</code> class has the method <code>accelerate(int speed_mph)</code> and both <code>Car</code> and <code>Plane</code> subclasses inherit it.
We want to write code that processes an array of <code>Vehicle</code> derivatives, calling <code>accelerate</code> on both <code>Car</code>s and <code>Plane</code>s.
There's two ways for inheritance to achieve that goal, most languages offer both:</p>
<ul>
<li>
<p><strong>Interface Inheritance:</strong> <code>Car</code> and <code>Plane</code> share the public method interface of <code>Vehicle</code> but override the actual <code>accelerate</code> implementation with their respective customizations. Here, <code>Vehicle</code> acts as an "abstract base class". Rust's traits embody this best practice.</p>
</li>
<li>
<p><strong>Implementation Inheritance:</strong> <code>Car</code> and <code>Plane</code> share the data and implementation of <code>Vehicle</code>'s generic <code>accelerate</code> method. This pattern is widely used in real-world programs, but the tight coupling of base and derived classes can make code more difficult to maintain and extend.</p>
</li>
</ul>
</blockquote>
<p>So what kind of behavior can traits specify?
And how do we make use of them?
We'll add two traits to our <code>Proc</code> struct to find out.</p>
<h3 id="deriving-trait-debug"><a class="header" href="#deriving-trait-debug">Deriving Trait <code>Debug</code></a></h3>
<p>Being able to print out a text representation of a struct is useful for debugging.
In fact, it's a need so common that Rust provides a default format specifier specifically for this purpose: <code>{:?}</code>.
Let's try using it to print the original, non-generic <code>Proc</code> struct:</p>
<pre><code class="language-rust ignore">pub enum State {
    Running,
    Stopped,
    Sleeping,
}

pub struct Proc {
    pid: u32,           // Process ID (unsigned integer)
    state: State,       // Current state (enum)
    children: Vec&lt;u32&gt;, // Child IDs (dynamic list)
}

fn main() {
    let my_proc = Proc {
        pid: 1,
        state: State::Stopped,
        children: Vec::new(),
    };

    println!("{:?}", my_proc);
}</code></pre>
<p>We get this error (some lines omitted):</p>
<pre><code class="language-ignore">error[E0277]: `Proc` doesn't implement `Debug`
  --&gt; src/main.rs:20:22
   |
20 |     println!("{:?}", my_proc);
   |                      ^^^^^^^ `Proc` cannot be formatted using `{:?}`
   |
   = help: the trait `Debug` is not implemented for `Proc`
   = note: add `#[derive(Debug)]` to `Proc` or manually `impl Debug for Proc`
</code></pre>
<p>If we want to use <code>{:?}</code>, compiler needs <code>Proc</code> to implement the <code>Debug</code> trait<sup class="footnote-reference" id="fr-TraitDebug-1"><a href="#footnote-TraitDebug">9</a></sup>.
This trait defines how its implementor should be printed to the console, a common and desirable <em>behavior</em>.
At this point we have two options:</p>
<ol>
<li>
<p>Review the documentation<sup class="footnote-reference" id="fr-TraitDebug-2"><a href="#footnote-TraitDebug">9</a></sup> for <code>std::fmt::Debug</code> to understand the interface it requires (in this case it's only one function) and implement the interface within a <code>impl Debug for Proc { ... }</code> block.</p>
</li>
<li>
<p>Attempt to <em>derive</em> the trait automatically, with the derive macro <code>#[derive(Debug)]</code>.</p>
</li>
</ol>
<p>The latter option is easier, and is the route recommended by the documentation<sup class="footnote-reference" id="fr-TraitDebug-3"><a href="#footnote-TraitDebug">9</a></sup>.</p>
<blockquote>
<p><strong>Getting familiar with Rust documentation</strong></p>
<p>If you haven't done so already, take a second to review the documentation for the <code>Debug</code> trait<sup class="footnote-reference" id="fr-TraitDebug-4"><a href="#footnote-TraitDebug">9</a></sup> now.
Although you won't understand the entirety of the function signature yet, you can still get a sense of the broad strokes.</p>
<p>Understanding library documentation is a key skill for any developer, but it's especially useful for Rust programming.
Popular libraries tend to be well-documented because Rust has a built-in, 1st party document generator (which we'll cover soon!).</p>
</blockquote>
<p>Let's make the suggested update:</p>
<pre><code class="language-rust ignore">#[derive(Debug)]
pub struct Proc {
    pid: u32,           // Process ID (unsigned integer)
    state: State,       // Current state (enum)
    children: Vec&lt;u32&gt;, // Child IDs (dynamic list)
}</code></pre>
<p>We now get a new error (aka a programmer's definition of "progress"):</p>
<pre><code class="language-ignore">error[E0277]: `State` doesn't implement `Debug`
  --&gt; src/main.rs:10:5
   |
7  | #[derive(Debug)]
   |          ----- in this derive macro expansion
...
10 |     state: State,       // Current state (enum)
   |     ^^^^^^^^^^^^ `State` cannot be formatted using `{:?}`
   |
   = help: the trait `Debug` is not implemented for `State`
   = note: add `#[derive(Debug)]` to `State` or manually `impl Debug for State`
</code></pre>
<p>Well, not entirely new. It's the same error as before, but this time for the <code>state</code> <em>field</em> of <code>Proc</code>.
Remember the idea of defining behavior by <em>composition</em>?</p>
<p>If every individual field of a struct implements the <code>Debug</code> trait, then deriving it for the entire struct is trivial - the behavior is simply a composite of the individual behaviors of each field.
We can build up powerful abstractions and reuse existing code, without the need to fit everything into a strict hierarchy.</p>
<p>Per this second error, our only remaining blocker is that the <code>State</code> type doesn't implement <code>Debug</code>.
Let's correct that:</p>
<pre><code class="language-rust noplaypen">#[derive(Debug)]
pub enum State {
    Running,
    Stopped,
    Sleeping,
}</code></pre>
<p>The program will now compile and run.
We get the desired print output:</p>
<pre><code class="language-ignore">Proc { pid: 1, state: Stopped, children: [] }
</code></pre>
<blockquote>
<p><strong>Quick Tip for <code>Debug</code> Printing</strong></p>
<p>For debugging systems code, it's often useful to print structs with hexadecimal numerical values and one field per line.
If we update the last line of <code>main</code> to <code>println!("{:#x?}", my_proc);</code>, the program prints:</p>
<pre><code class="language-ignore">Proc {
  pid: 0x1,
  state: Stopped,
  children: [],
}
</code></pre>
</blockquote>
<h3 id="implementing-trait-ord"><a class="header" href="#implementing-trait-ord">Implementing Trait <code>Ord</code></a></h3>
<p>Sometimes a trait can't be derived automatically.
Take, for example, the <code>Aead</code> trait<sup class="footnote-reference" id="fr-TraitAead-1"><a href="#footnote-TraitAead">10</a></sup>.
It's defined in a 3rd party library and specifies an [unofficial] interface for Authenticated Encryption with Associated Data (AEAD) ciphers.
Recall from the previous chapter that this is a family of cryptographic algorithms providing both message <em>confidentiality</em> and <em>integrity</em><sup class="footnote-reference" id="fr-AEAD-1"><a href="#footnote-AEAD">11</a></sup>.</p>
<p>Rust's trait system is powerful, but a derive macro isn't going to synthesize cryptographic code for us.
Traits are just interfaces, and we often need to implement the backing logic ourselves.</p>
<p>Moreover, even if a trait is derivable, the default behavior may not be what we want.
Say an OS needs to maintain a sorted list of process structures.
Sorting requires a notion of "order".
What mathematicians call "total order"<sup class="footnote-reference" id="fr-TotalOrder-1"><a href="#footnote-TotalOrder">12</a></sup>.
The underlying idea is that we want to use logical comparison operators (<code>==</code>, <code>&gt;</code>, <code>&lt;=</code>, etc) to sort, and we must be able to make these comparisons unambiguously.</p>
<p>Rust's standard library includes a trait specifically for ordering: <code>Ord</code><sup class="footnote-reference" id="fr-Ord-1"><a href="#footnote-Ord">13</a></sup>.
Any type that implements it becomes comparable to items of the same type, and collections of it can be sorted.
In many contexts, that's an incredibly useful behavior to support.</p>
<p>Can we derive <code>Ord</code> for <code>Proc</code>?
Yes.
But, per the documentation<sup class="footnote-reference" id="fr-Ord-2"><a href="#footnote-Ord">13</a></sup>, <code>Ord</code> depends on other traits: <code>PartialEq</code>, <code>Eq</code>, <code>PartialOrd</code>.
Because traits themselves can be defined by composition!</p>
<p>Let's not split hairs with the distinctions between these four order-related traits.
Instead consider what happens if we derive them:</p>
<pre><pre class="playground"><code class="language-rust">#[derive(Debug, PartialEq, Eq, PartialOrd, Ord)]
pub enum State {
    Running,
    Stopped,
    Sleeping,
}

#[derive(Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct Proc {
    pid: u32,           // Process ID (unsigned integer)
    state: State,       // Current state (enum)
    children: Vec&lt;u32&gt;, // Child IDs (dynamic list)
}

fn main() {
    let my_proc_stopped = Proc {
        pid: 1,
        state: State::Stopped,
        children: Vec::new(),
    };

    let my_proc_sleeping = Proc {
        pid: 3,
        state: State::Sleeping,
        children: Vec::new(),
    };

    let my_proc_running = Proc {
        pid: 2,
        state: State::Running,
        children: Vec::new(),
    };

    let mut proc_queue = vec![
        my_proc_stopped,
        my_proc_sleeping,
        my_proc_running,
    ];

    proc_queue.sort();

    println!("{:#?}", proc_queue);
}</code></pre></pre>
<p>The above creates a <code>Vec</code> of three processes (<code>proc_queue</code>) and sorts it.
Why is calling <code>proc_queue.sort()</code> possible?
Consider the function signature for <code>sort</code> from <code>Vec&lt;T&gt;</code>'s documentation<sup class="footnote-reference" id="fr-VecSort-1"><a href="#footnote-VecSort">14</a></sup>:</p>
<pre><code class="language-rust ignore">pub fn sort(&amp;mut self)
where
    T: Ord,
{
    // ...code here
}</code></pre>
<p><code>where T: Ord</code> is a <em>trait bound</em>.
It stipulates what behavior <code>T</code> needs to support for the function to work.
That means <code>sort</code> is available on any <code>Vec&lt;T&gt;</code>, but <em>only if</em> <code>T</code> is a type implementing <code>Ord</code>.
The above code works because:</p>
<ol>
<li>
<p>Type inference filled in <code>let mut proc_queue: Vec&lt;Proc&gt; = ...</code>.</p>
</li>
<li>
<p>The <code>Proc</code> struct derived the <code>Ord</code> trait.</p>
</li>
</ol>
<p>Trait bounds major ramifications for code reuse and library composability.
<code>Vec</code> is a generic container (will work even for types that haven't been invented yet) and offers additional functionality for items that support specific behaviors (like sorting types that can be ordered).</p>
<p>But <code>Vec</code> isn't some one-off that only the official standard library can implement.
Any Rust developer can similarly use generics and traits to implement equally useful data structures.
We'll write an API-compatible alternative to another standard library collection in this book.</p>
<p>Trait bounds enable you to rapidly and confidently compose disparate components into large, harmonious systems.
They're a powerful high-level construct.</p>
<blockquote>
<p><strong>Reading Rust Syntax</strong></p>
<p>It'll take time to get comfortable reading Rust, the syntax is complex.
The <code>where</code> keyword is actually a readability convenience, the above <code>sort</code> signature is equivalent to:</p>
<pre><code class="language-rust ignore">pub fn sort&lt;T: Ord&gt;(&amp;mut self) {
   // ...code here
}</code></pre>
<p>But where did <code>T</code> come from?
Neither <code>sort</code> variation is a stand-alone function, both exist within the <code>impl</code> block for <code>Vec&lt;T&gt;</code>.
We omitted that detail for brevity, but it's consequential:</p>
<pre><code class="language-rust ignore">impl&lt;T&gt; Vec&lt;T&gt; {
  pub fn sort&lt;T: Ord&gt;(&amp;mut self) {
      // ...code here
  }

  // ...other functions here
}</code></pre>
</blockquote>
<p>So, due to trait bounds, the call to <code>sort()</code> works.
But does it work <em>well</em>?
That's debatable, the output shows we've sorted by <code>pid</code>:</p>
<pre><code class="language-ignore">[
    Proc {
        pid: 1,
        state: Stopped,
        children: [],
    },
    Proc {
        pid: 2,
        state: Running,
        children: [],
    },
    Proc {
        pid: 3,
        state: Sleeping,
        children: [],
    },
]
</code></pre>
<p>The derived composite behavior will attempt to sort by the 1st field of the struct (<code>pid</code>).
If the values happen to be equal, it will sort by the 2nd field (<code>state</code>, which also derives <code>Ord</code>).
If those values happen to be equal, then it will sort by the 3rd field (<code>children</code>), etc.</p>
<p>This compiled and ran, but it isn't quite the behavior we want.
Imagine our OS uses this list of processes as a scheduling queue, to decide which process to run next.
We'd need to sort them via some notion of priority, not <code>pid</code>-first.</p>
<p>Real-world scheduling algorithms can be complex<sup class="footnote-reference" id="fr-SchedAlg-1"><a href="#footnote-SchedAlg">15</a></sup>.
For simplicity, let's assume we have three priorities based solely on the current <code>State</code>.
Any <code>Sleeping</code> process should be the highest priority for execution, followed by <code>Stopped</code> processes.
<code>Running</code> processes are, by definition, already running - they're the lowest priority.
We want them at the back of the list.
It's time to implement <code>Ord</code> the hard way!</p>
<p>First, we need to understand a little more about how the <code>State</code> enum works under-the-hood.
In memory, each variant starts with a <em>discriminant</em> - an integer number.
It's like a tag unique to the variant.</p>
<p>Had two <code>pid</code>s been equal, we'd need to break the sorting tie by looking at <code>state</code>.
Thus this discriminant integer would have come into play for sorting.
Let's keep the derived <code>Ord</code> on <code>State</code> but overwrite the default values to reflect our chosen priorities:</p>
<pre><code class="language-rust noplaypen">#[derive(Debug, PartialEq, Eq, PartialOrd, Ord)]
pub enum State {
    Running = 3,    // 0 by default
    Stopped = 2,    // 1 by default
    Sleeping = 1,   // 2 by default
}</code></pre>
<p>For the <code>Proc</code> struct, we'll now implement the actual functions required by the <code>Ord</code><sup class="footnote-reference" id="fr-TraitOrd-1"><a href="#footnote-TraitOrd">16</a></sup>, <code>PartialOrd</code><sup class="footnote-reference" id="fr-TraitPartialOrd-1"><a href="#footnote-TraitPartialOrd">17</a></sup>, and <code>PartialEq</code><sup class="footnote-reference" id="fr-TraitPartialEq-1"><a href="#footnote-TraitPartialEq">18</a></sup> traits - per the respective documentation.
We can still derive <code>Eq</code><sup class="footnote-reference" id="fr-TraitEq-1"><a href="#footnote-TraitEq">19</a></sup>, because it's implied by <code>PartialEq</code> and has no methods of its own (a technicality that doesn't generalize to other traits):</p>
<pre><code class="language-rust ignore">use std::cmp::Ordering;

#[derive(Debug, Eq)]
pub struct Proc {
    pid: u32,           // Process ID (unsigned integer)
    state: State,       // Current state (enum)
    children: Vec&lt;u32&gt;, // Child IDs (dynamic list)
}

impl Ord for Proc {
    fn cmp(&amp;self, other: &amp;Self) -&gt; Ordering {
        self.state.cmp(&amp;other.state)
    }
}

impl PartialOrd for Proc {
    fn partial_cmp(&amp;self, other: &amp;Self) -&gt; Option&lt;Ordering&gt; {
        Some(self.cmp(other))
    }
}

impl PartialEq for Proc {
    fn eq(&amp;self, other: &amp;Self) -&gt; bool {
        self.state == other.state
    }
}</code></pre>
<p>The details of the above code aren't as important as the implication: now the language, at a very fundamental level, will <em>only</em> consider the <code>state</code> field when ordering <code>Proc</code> structs.
By implementing a few specific traits, we've prescribed how the struct will <em>behave</em> in a range of contexts - like sorting and comparison.</p>
<p>With this new implementation of <code>Ord</code> and the traits it relies on, <code>println!("{:#?}", proc_queue);</code> will now output the <code>state</code>-prioritized order we desire:</p>
<pre><code class="language-ignore">[
    Proc {
        pid: 3,
        state: Sleeping,
        children: [],
    },
    Proc {
        pid: 1,
        state: Stopped,
        children: [],
    },
    Proc {
        pid: 2,
        state: Running,
        children: [],
    },
]
</code></pre>
<blockquote>
<p><strong>Be careful, traits are powerful!</strong></p>
<p>In implementing a trait manually, we've changed not only how <code>Proc</code> structs should be ordered for sorting but also what it means for two <code>Proc</code> structs to be equal!</p>
<p>Now, any two structs with the same <code>state</code> are considered logically equivalent as far as the <code>==</code> operator is concerned, even if they have different <code>pid</code>s and <code>children</code>.</p>
<p>Whenever you manually implement a trait, it's important to ensure all of the ramifications of that implementation are indeed appropriate for your program.</p>
<p>In this case, trait implementation is actually overkill (we did it just to illustrate important concepts).
Instead, we could've used <code>Vec</code>'s <code>sort_by_key</code> function<sup class="footnote-reference" id="fr-VecSortByKey-1"><a href="#footnote-VecSortByKey">20</a></sup> after updating the enum discriminants:</p>
<pre><code class="language-rust ignore">proc_queue.sort_by_key(|p| p.state);</code></pre>
</blockquote>
<h2 id="takeaway"><a class="header" href="#takeaway">Takeaway</a></h2>
<p>Rust's facilities for expressing high-level constructs include enums, structs, generics, and traits.
To recap:</p>
<ul>
<li>
<p>Enums are useful for representing a finite set of possible values, but may also carry additional data.</p>
</li>
<li>
<p>Structs are a way to group related data and functions that operate on it, akin to classes or objects in other languages.</p>
</li>
<li>
<p>Generics enable code reuse: functions and structures can be written only once yet support different types. While merely handy for avoiding code duplication, it's a truly killer feature for library design.</p>
</li>
<li>
<p>Traits enable shared behavior via composition. They define specific interfaces, can be derived or implemented, and become especially useful when <em>bound</em> to generic parameters.</p>
</li>
</ul>
<p>Let's take a breather to talk about a simpler topic, control flow, before we delve into ownership.</p>
<blockquote>
<p><strong>Can we encode domain-specific invariants directly into the type system?</strong></p>
<p>In a limited yet potent fashion, yes.
Sometimes important, domain-specific behavior can be modeled as a <em>state machine</em>.
A structure that transitions through a sequence of states, in which certain operations can only be performed in certain states.
And only certain transitions are legal.</p>
<p>The <em>typestate pattern</em> is a way of encoding a structure's possible <em>runtime</em> states at <em>compile-time</em>.
It can eliminate both state-related errors (static correctness) and the need for some runtime checks (performance). The former benefit is amenable to:</p>
<p><strong>[RR, Directive 4.13]</strong> Functions operating on a resource must be called in the correct sequence<sup class="footnote-reference" id="fr-MISRA_2012-1"><a href="#footnote-MISRA_2012">21</a></sup></p>
<p>We'll cover Rust implementation of the typestate pattern in a future appendix section.</p>
</blockquote>
<hr>
<ol class="footnote-definition"><li id="footnote-RustInfluence">
<p><a href="https://doc.rust-lang.org/reference/influences.html"><em>The Rust Reference: Influences</em></a>. The Rust Team (2021). <a href="#fr-RustInfluence-1">↩</a></p>
</li>
<li id="footnote-TockOS">
<p><a href="https://www.tockos.org/"><em>Tock</em></a>. Tock OS (Accessed 2022). Operating systems, perhaps the quintessential example of systems software, are a domain for which Rust is well-suited. There are several OSs written in Rust, Tock is one of them. <a href="#fr-TockOS-1">↩</a></p>
</li>
<li id="footnote-Epoch">
<p><a href="https://www.unixtimestamp.com/"><em>The Current Epoch Unix Timestamp</em></a>. Dan's Tools (Accessed 2022). <a href="#fr-Epoch-1">↩</a></p>
</li>
<li id="footnote-EnumAside">
<p>Rust also lets us define methods and associated functions on enums - we're not restricted to structs. But structs are more commonly used, many programming problems don't require representing groups of data that have multiple distinct variants. <a href="#fr-EnumAside-1">↩</a></p>
</li>
<li id="footnote-LinuxTaskStruct">
<p>Real OSs have much more complex task structures, our examples in this section are greatly simplified. If interested, you can check out the source code for Linux's <code>task_struct</code> <a href="https://github.com/torvalds/linux/blob/4f12b742eb2b3a850ac8be7dc4ed52976fc6cb0b/include/linux/sched.h#L728">here</a>. <a href="#fr-LinuxTaskStruct-1">↩</a></p>
</li>
<li id="footnote-ChromeProc">
<p><a href="https://dev.chromium.org/developers/design-documents/process-models"><em>Process Models</em></a>. The Chromium Project (Accessed 2022). <a href="#fr-ChromeProc-1">↩</a></p>
</li>
<li id="footnote-DataEncap">
<p><a href="https://en.wikipedia.org/wiki/Data_encapsulation"><em>Data encapsulation</em></a>. Wikipedia (Accessed 2022). <a href="#fr-DataEncap-1">↩</a></p>
</li>
<li id="footnote-Composition">
<p><a href="https://en.wikipedia.org/wiki/Composition_over_inheritance"><em>Composition over inheritance</em></a>. Wikipedia (Accessed 2022). <a href="#fr-Composition-1">↩</a></p>
</li>
<li id="footnote-TraitDebug">
<p><a href="https://doc.rust-lang.org/std/fmt/trait.Debug.html"><em>Trait <code>std::fmt::Debug</code></em></a>. The Rust Team (Accessed 2022). <a href="#fr-TraitDebug-1">↩</a> <a href="#fr-TraitDebug-2">↩2</a> <a href="#fr-TraitDebug-3">↩3</a> <a href="#fr-TraitDebug-4">↩4</a></p>
</li>
<li id="footnote-TraitAead">
<p><a href="https://docs.rs/aead/latest/aead/trait.Aead.html"><em>Trait <code>aead::Aead</code></em></a>. RustCrypto organization (Accessed 2022). <a href="#fr-TraitAead-1">↩</a></p>
</li>
<li id="footnote-AEAD">
<p><a href="https://en.wikipedia.org/wiki/Authenticated_encryption"><em>Authenticated encryption</em></a>. Wikipedia (Accessed 2022). <a href="#fr-AEAD-1">↩</a></p>
</li>
<li id="footnote-TotalOrder">
<p><a href="https://en.wikipedia.org/wiki/Total_order">Total order</a> Wikipedia (Accessed 2022). <a href="#fr-TotalOrder-1">↩</a></p>
</li>
<li id="footnote-Ord">
<p><a href="https://doc.rust-lang.org/std/cmp/trait.Eq.html"><em>Trait <code>std::cmp::Ord</code></em></a>. The Rust Team (Accessed 2022). <a href="#fr-Ord-1">↩</a> <a href="#fr-Ord-2">↩2</a></p>
</li>
<li id="footnote-VecSort">
<p><a href="https://doc.rust-lang.org/std/vec/struct.Vec.html#method.sort"><em><code>sort</code></em></a>. The Rust Team (Accessed 2022). <a href="#fr-VecSort-1">↩</a></p>
</li>
<li id="footnote-SchedAlg">
<p><a href="https://wiki.osdev.org/Scheduling_Algorithms"><em>Scheduling Algorithms</em></a>. OSDev Wiki (2021). <a href="#fr-SchedAlg-1">↩</a></p>
</li>
<li id="footnote-TraitOrd">
<p><a href="https://doc.rust-lang.org/std/cmp/trait.Eq.html"><em>Trait <code>std::cmp::Ord</code></em></a>. The Rust Team (Accessed 2022). <a href="#fr-TraitOrd-1">↩</a></p>
</li>
<li id="footnote-TraitPartialOrd">
<p><a href="https://doc.rust-lang.org/std/cmp/trait.PartialOrd.html"><em>Trait <code>std::cmp::PartialOrd</code></em></a>. The Rust Team (Accessed 2022). <a href="#fr-TraitPartialOrd-1">↩</a></p>
</li>
<li id="footnote-TraitPartialEq">
<p><a href="https://doc.rust-lang.org/std/cmp/trait.PartialEq.html"><em>Trait <code>std::cmp::PartialEq</code></em></a>. The Rust Team (Accessed 2022). <a href="#fr-TraitPartialEq-1">↩</a></p>
</li>
<li id="footnote-TraitEq">
<p><a href="https://doc.rust-lang.org/std/cmp/trait.Eq.html"><em>Trait <code>std::cmp::Eq</code></em></a>. The Rust Team (Accessed 2022). <a href="#fr-TraitEq-1">↩</a></p>
</li>
<li id="footnote-VecSortByKey">
<p><a href="https://doc.rust-lang.org/std/primitive.slice.html#method.sort_by_key"><em><code>sort_by_key</code></em></a>. The Rust Team (Accessed 2022). <a href="#fr-VecSortByKey-1">↩</a></p>
</li>
<li id="footnote-MISRA_2012">
<p><em>MISRA C: 2012 Guidelines for the use of the C language in critical systems (3rd edition)</em>. MISRA (2019). <a href="#fr-MISRA_2012-1">↩</a></p>
</li>
</ol>
                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../chp3/rust_1_low_data_rep.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../chp3/rust_3_ctrl_flow.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../chp3/rust_1_low_data_rep.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../chp3/rust_3_ctrl_flow.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
