<!DOCTYPE HTML>
<html lang="en" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Rust: Low-Level Data (1/6) - High Assurance Rust: Developing Secure and Robust Software</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->

        <!-- MathJax -->
        <script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="../landing.html">High Assurance Rust</a></li><li class="chapter-item expanded affix "><a href="../faq.html">Frequently Asked Questions (FAQ)</a></li><li class="chapter-item expanded affix "><a href="../engage.html">Engage with this Book!</a></li><li class="chapter-item expanded affix "><a href="../cfp.html">Sponsor Call for Proposals (CFP)</a></li><li class="chapter-item expanded affix "><a href="../download.html">Download</a></li><li class="chapter-item expanded affix "><a href="../changelog.html">Changelog</a></li><li class="chapter-item expanded affix "><a href="../license.html">License</a></li><li class="chapter-item expanded affix "><li class="part-title">Novice: Systems Security</li><li class="spacer"></li><li class="chapter-item expanded "><a href="../chp1/_index.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../chp1/why_this_book.html"><strong aria-hidden="true">1.1.</strong> Why this book?</a></li><li class="chapter-item expanded "><a href="../chp1/how_is_this_book_structured.html"><strong aria-hidden="true">1.2.</strong> How is this book structured?</a></li><li class="chapter-item expanded "><a href="../chp1/challenges.html"><strong aria-hidden="true">1.3.</strong> Hands-on Learning</a></li><li class="chapter-item expanded "><a href="../chp1/about_the_team.html"><strong aria-hidden="true">1.4.</strong> About the Team</a></li><li class="chapter-item expanded "><a href="../chp1/_hands_on.html"><strong aria-hidden="true">1.5.</strong> Warmup: Environment Setup</a></li></ol></li><li class="chapter-item expanded "><a href="../chp2/_index.html"><strong aria-hidden="true">2.</strong> Software Assurance</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../chp2/static_vs_dynamic.html"><strong aria-hidden="true">2.1.</strong> Static vs. Dynamic Tools</a></li><li class="chapter-item expanded "><a href="../chp2/static_assurance_1.html"><strong aria-hidden="true">2.2.</strong> Static Assurance (1/2)</a></li><li class="chapter-item expanded "><a href="../chp2/static_assurance_2.html"><strong aria-hidden="true">2.3.</strong> Static Assurance (2/2)</a></li><li class="chapter-item expanded "><a href="../chp2/dynamic_assurance_1.html"><strong aria-hidden="true">2.4.</strong> Dynamic Assurance (1/3)</a></li><li class="chapter-item expanded "><a href="../chp2/dynamic_assurance_2.html"><strong aria-hidden="true">2.5.</strong> Dynamic Assurance (2/3)</a></li><li class="chapter-item expanded "><a href="../chp2/dynamic_assurance_3.html"><strong aria-hidden="true">2.6.</strong> Dynamic Assurance (3/3)</a></li><li class="chapter-item expanded "><a href="../chp2/limits.html"><strong aria-hidden="true">2.7.</strong> Limitations and Threat Modeling</a></li><li class="chapter-item expanded "><a href="../chp2/cli.html"><strong aria-hidden="true">2.8.</strong> DIY CLI Encryption Tool</a></li><li class="chapter-item expanded "><a href="../chp2/operational_assurance_1.html"><strong aria-hidden="true">2.9.</strong> Operational Assurance (1/2)</a></li><li class="chapter-item expanded "><a href="../chp2/operational_assurance_2.html"><strong aria-hidden="true">2.10.</strong> Operational Assurance (2/2)</a></li><li class="chapter-item expanded "><a href="../chp2/_hands_on.html"><strong aria-hidden="true">2.11.</strong> Challenge: Extend the CLI Tool</a></li></ol></li><li class="chapter-item expanded "><a href="../chp3/_index.html"><strong aria-hidden="true">3.</strong> Rust Zero-Crash Course</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../chp3/undef.html"><strong aria-hidden="true">3.1.</strong> On Undefined Behavior</a></li><li class="chapter-item expanded "><a href="../chp3/rust_1_low_data_rep.html" class="active"><strong aria-hidden="true">3.2.</strong> Rust: Low-Level Data (1/6)</a></li><li class="chapter-item expanded "><a href="../chp3/rust_2_high_data_rep.html"><strong aria-hidden="true">3.3.</strong> Rust: High-Level Data (2/6)</a></li><li class="chapter-item expanded "><a href="../chp3/rust_3_ctrl_flow.html"><strong aria-hidden="true">3.4.</strong> Rust: Control Flow (3/6)</a></li><li class="chapter-item expanded "><a href="../chp3/rust_4_own_1.html"><strong aria-hidden="true">3.5.</strong> Rust: Ownership Principles (4/6)</a></li><li class="chapter-item expanded "><a href="../chp3/rust_5_own_2.html"><strong aria-hidden="true">3.6.</strong> Rust: Ownership in Practice (5/6)</a></li><li class="chapter-item expanded "><a href="../chp3/rust_6_error.html"><strong aria-hidden="true">3.7.</strong> Rust: Error Handling (6/6)</a></li><li class="chapter-item expanded "><a href="../chp3/modules.html"><strong aria-hidden="true">3.8.</strong> The Module System</a></li><li class="chapter-item expanded "><a href="../chp3/tooling.html"><strong aria-hidden="true">3.9.</strong> Recommended Tooling</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">3.10.</strong> Rust's Release Cycle</div></li><li class="chapter-item expanded "><a href="../chp3/_hands_on.html"><strong aria-hidden="true">3.11.</strong> Challenge: Port a Program</a></li></ol></li><li class="chapter-item expanded "><a href="../chp4/_index.html"><strong aria-hidden="true">4.</strong> Understanding Memory Safety and Exploitation</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../chp4/sw_stack_1.html"><strong aria-hidden="true">4.1.</strong> Software Perspective: CPU to Process</a></li><li class="chapter-item expanded "><a href="../chp4/assure_stack_1.html"><strong aria-hidden="true">4.2.</strong> Assurance Perspective: Stack Safety</a></li><li class="chapter-item expanded "><a href="../chp4/attack_1.html"><strong aria-hidden="true">4.3.</strong> Attacker's Perspective: Breaking Safety (1/2)</a></li><li class="chapter-item expanded "><a href="../chp4/attack_2.html"><strong aria-hidden="true">4.4.</strong> Attacker's Perspective: Unifying Theory (2/2)</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">4.5.</strong> Debugging DIY Secret Obfuscation</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">4.6.</strong> Stack Exploitation</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">4.7.</strong> Software Perspective: Heap (1/2)</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">4.8.</strong> Software Perspective: Heap (2/2)</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">4.9.</strong> Heap Exploitation</div></li><li class="chapter-item expanded "><a href="../chp4/safe_rust_PLACEHOLDER.html"><strong aria-hidden="true">4.10.</strong> Rust's Memory Safety Guarantees (1/2)</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">4.11.</strong> Rust's Memory Safety Guarantees (2/2)</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">4.12.</strong> Language-agnostic Mitigations</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">4.13.</strong> Case Study: Real-world Rust CVEs</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">4.14.</strong> Challenge: Vulnerability Research</div></li></ol></li><li class="chapter-item expanded "><li class="part-title">Advanced Beginner: Core Project</li><li class="spacer"></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.</strong> Binary Search Tree (BST) Basics</div></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">5.1.</strong> Core BST Operations in Python</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.2.</strong> Problems Translating to Rust</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.3.</strong> The Importance of Balance</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.4.</strong> TODO</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.5.</strong> Challenge: TODO</div></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">6.</strong> Building an Arena Allocator</div></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">6.1.</strong> Let's Talk Allocators</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">6.2.</strong> A Stack-Only Arena</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">6.3.</strong> Index-based Data Structures</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">6.4.</strong> TODO</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">6.5.</strong> Challenge: TODO</div></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">7.</strong> A Self-balancing BST</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="../chp7/traits.html"><strong aria-hidden="true">7.1.</strong> Interface-relevant Traits</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">7.2.</strong> Scapegoat Trees</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">7.3.</strong> Insert</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">7.4.</strong> Remove</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">7.5.</strong> Find</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">7.6.</strong> Challenge: TODO</div></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">8.</strong> Digital Twin Testing</div></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">8.1.</strong> Basic QEMU Internals</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">8.2.</strong> How Semi-hosting Works</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">8.3.</strong> CLI REPL Harness</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">8.4.</strong> Limitations</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">8.5.</strong> TODO</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">8.6.</strong> Challenge: TODO</div></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">9.</strong> Building Maps and Sets</div></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">9.1.</strong> TODO</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">9.2.</strong> Challenge: TODO</div></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">10.</strong> Implementing Iterators</div></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">10.1.</strong> TODO</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">10.2.</strong> Challenge: TODO</div></li></ol></li><li class="chapter-item expanded "><li class="part-title">Competent: Validation and Deployment</li><li class="spacer"></li><li class="chapter-item expanded "><div><strong aria-hidden="true">11.</strong> Static Verification</div></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">11.1.</strong> An Introduction to 1st Order Logic</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">11.2.</strong> Proving Absence of Panics</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">11.3.</strong> Deductively Verifying our Arena Allocator</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">11.4.</strong> Model Checking for unsafe Code</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">11.5.</strong> TODO</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">11.6.</strong> Challenge: Prove a Sorting Algorithm</div></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">12.</strong> Dynamic Testing</div></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">12.1.</strong> Introduction to Coverage-Guided Fuzzing</div></li><li class="chapter-item expanded "><a href="../chp12/diff_fuzz_PLACEHOLDER.html"><strong aria-hidden="true">12.2.</strong> Building a Differential Fuzzing Harness</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">12.3.</strong> Using Miri to Detect Undefined Behavior</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">12.4.</strong> Benchmarking and Optimization</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">12.5.</strong> TODO</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">12.6.</strong> Challenge: Bug-hunting with Fuzzers</div></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">13.</strong> Operational Deployment</div></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">13.1.</strong> Understanding unsafe (1/3)</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">13.2.</strong> Understanding unsafe (2/3)</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">13.3.</strong> Understanding unsafe (3/3)</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">13.4.</strong> CFFI 101</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">13.5.</strong> C99 Interoperability</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">13.6.</strong> Python3 Interoperability</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">13.7.</strong> Runtime Balance Reconfiguration</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">13.8.</strong> TODO</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">13.9.</strong> Challenge: TODO</div></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">14.</strong> Maximizing Assurance</div></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">14.1.</strong> Rust Security Research</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">14.2.</strong> Rust's Limitations</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">14.3.</strong> Best Practices Beyond Rust</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">14.4.</strong> TODO</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">14.5.</strong> Challenge: TODO</div></li></ol></li><li class="chapter-item expanded "><li class="part-title">Conclusion</li><li class="spacer"></li><li class="chapter-item expanded "><div><strong aria-hidden="true">15.</strong> Review</div></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">15.1.</strong> Key Concepts</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">15.2.</strong> Key Blue-Team Skills</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">15.3.</strong> Key Red-Team Skills</div></li></ol></li><li class="chapter-item expanded "><a href="../chp16_appendix/_index.html"><strong aria-hidden="true">16.</strong> Appendix</a></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">16.1.</strong> Setup: Using our Docker Container</div></li><li class="chapter-item expanded "><a href="../chp16_appendix/tools.html"><strong aria-hidden="true">16.2.</strong> Inventory: Tools of the Trade</a></li><li class="chapter-item expanded "><a href="../chp16_appendix/books.html"><strong aria-hidden="true">16.3.</strong> Inventory: Recommended Reading</a></li><li class="chapter-item expanded "><a href="../chp16_appendix/resources.html"><strong aria-hidden="true">16.4.</strong> Inventory: Additional Resources</a></li><li class="chapter-item expanded "><a href="../chp16_appendix/crypto.html"><strong aria-hidden="true">16.5.</strong> Fundamentals: Stream Ciphers</a></li><li class="chapter-item expanded "><a href="../chp16_appendix/types.html"><strong aria-hidden="true">16.6.</strong> Fundamentals: Type Systems</a></li><li class="chapter-item expanded "><a href="../chp16_appendix/components.html"><strong aria-hidden="true">16.7.</strong> Fundamentals: Component-Based Design</a></li><li class="chapter-item expanded "><a href="../chp16_appendix/mem_hierarch.html"><strong aria-hidden="true">16.8.</strong> Fundamentals: Memory Hierarchy</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">16.9.</strong> Fundamentals: Dynamic Linking</div></li><li class="chapter-item expanded "><a href="../chp16_appendix/icfg.html"><strong aria-hidden="true">16.10.</strong> Theory: Inter-procedural CFGs</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">16.11.</strong> Misc: Size Optimization</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">16.12.</strong> Misc: The Typestate Pattern</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">16.13.</strong> Misc: C++ Interoperability</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">16.14.</strong> Misc: Compile-time Metaprogramming</div></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">High Assurance Rust: Developing Secure and Robust Software</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/tnballo/high-assurance-rust" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        <a href="https://highassurance.rs/engage.html#submit-feedback-questions-issues-or-prs" title="Suggest an edit" aria-label="Suggest an edit">
                            <i id="git-edit-button" class="fa fa-edit"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <meta name="title" content="High Assurance Rust">
<meta name="description" content="Developing Secure and Robust Software">
<meta property="og:title" content="High Assurance Rust">
<meta property="og:description" content="Developing Secure and Robust Software">
<meta property="og:type" content="article">
<meta property="og:url" content="https://highassurance.rs/">
<meta property="og:image" content="https://highassurance.rs/img/har_logo_social.png">
<meta name="twitter:title" content="High Assurance Rust">
<meta name="twitter:description" content="Developing Secure and Robust Software">
<meta name="twitter:url" content="https://highassurance.rs/">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://highassurance.rs/img/har_logo_social.png">
<h1 id="rust-low-level-data-1-of-6"><a class="header" href="#rust-low-level-data-1-of-6">Rust: Low-Level Data (1 of 6)</a></h1>
<p>Thus far we've discussed Rust's type system in the context of static assurance.
Specifically preventing mutable aliasing and eliminating UB.</p>
<p>But, for the majority of day-to-day development, one could argue that these are secondary benefits.
And that the true value of Rust's type system lies in its expressiveness, in the ability to map our problem domain to flexible constructs.</p>
<p>This line of argument quickly becomes subjective, you should form your own opinions of Rust over time.
But the first step in solving a programming problem is typically representing data to process.
So we'll sample the options Rust affords us.</p>
<h2 id="primitive-types"><a class="header" href="#primitive-types">Primitive Types</a></h2>
<p>Rust's primitive types are similar to almost any programming language you're familiar with - it has the usual booleans, integers, floats, characters, strings, etc.</p>
<p>One key difference, relative to higher-level interpreted languages, is that integers and floats have a fixed width.
This is a hallmark of high-performance systems languages, where individual numbers need to be stored in CPU registers (like C) and not as structures in heap memory (like Python).</p>
<p>This hardware-level concern has two important implications: bounded ranges and host-specific widths.</p>
<h3 id="1-bounded-numeric-ranges"><a class="header" href="#1-bounded-numeric-ranges">1) Bounded Numeric Ranges</a></h3>
<p>Rust has 12 primitive numeric types:</p>
<ul>
<li>
<p>5 unsigned integer types: <code>u8</code>, <code>u16</code>, <code>u32</code>, <code>u64</code>, <code>u128</code>, and <code>usize</code>.</p>
</li>
<li>
<p>5 signed integer types: <code>i8</code>, <code>i16</code>, <code>i32</code>, <code>i64</code>, <code>i128</code>, and <code>isize</code>.</p>
</li>
<li>
<p>2 IEEE-compliant floats: <code>f32</code> (at least 6 decimal digits precision) and <code>f64</code> (at least 15 decimal digits).</p>
</li>
</ul>
<p>The postfix in the type name indicates bit-width, e.g. a <code>u128</code> is 128 bits (16 bytes) wide.
Here's the important implication: the range of values a given integer type can represent is finite.
Upper and lower bounds are determined by both signedness and width.
Consider the below table (non-exhaustive):</p>
<div class="table-wrapper"><table><thead><tr><th>Type</th><th>Width</th><th>Lower Bound</th><th>Upper Bound</th></tr></thead><tbody>
<tr><td>u8</td><td>1 byte</td><td>0</td><td>255</td></tr>
<tr><td>i8</td><td>1 byte</td><td>-128</td><td>127</td></tr>
<tr><td>u32</td><td>4 bytes</td><td>0</td><td>4,294,967,295</td></tr>
<tr><td>i64</td><td>8 bytes</td><td>-2<sup>63</sup></td><td>2<sup>63</sup>-1</td></tr>
</tbody></table>
</div>
<p>Rust's standard library provides handy limit constants for upper and lower bounds, so you don't have to remember these ranges off-hand or reference an exhaustive table:</p>
<pre><code class="language-rust noplaypen">assert_eq!(0, u8::MIN);
assert_eq!(255, u8::MAX);</code></pre>
<p>Exceeding the range of a type causes &quot;wrap around&quot;.
In rare cases, that's desirable behavior.
We made judicious and intentional use of <code>wrapping_add</code> when implementing the RC4 cipher to simulate modular arithmetic.
To demonstrate how that works, consider what would happen if we exceeded the <code>255</code> upper bound of a <code>u8</code>:</p>
<pre><code class="language-rust noplaypen">let x: u8 = 200;
let y: u8 = 100;

assert_eq!(x.wrapping_add(y), 44);</code></pre>
<p><code>44</code> is <code>300 % 256</code>, e.g. total modulo range size.
Outside of cryptographic contexts, silent wraparound is considered an <em>integer overflow</em> bug.
If <code>200</code> represented the number of dollars in a bank account and the account owner deposited another <code>100</code> dollars, they'd be shocked to find a <code>44</code> account balance on their receipt!</p>
<p>This is where we get into some subtleties in Rust.
Had we written <code>assert_eq!(x + y, 44);</code> instead of <code>assert_eq!(x.wrapping_add(y), 44);</code>, the program would have spit out an error warning of an overflow:</p>
<pre><code class="language-ignore">error: this arithmetic operation will overflow
 --&gt; src/main.rs:8:12
  |
8 | assert_eq!(x + y, 44);
  |            ^^^^^ attempt to compute `200_u8 + 100_u8`, which would overflow
  |
  = note: `#[deny(arithmetic_overflow)]` on by default
</code></pre>
<p>We got lucky here in the sense that both <code>x</code> and <code>y</code> are constants, so the overflow could be detected at compile-time.
Rust uses optional runtime checks to catch overflow for variables whose values aren't known beforehand - a topic we'll return to in Chapter 4 when discussing safety in-depth.</p>
<p>There's one more detail to keep in mind about integer overflow in Rust: unlike C/C++, it's not a potential source of UB.
The rules of wrap around are specified and universal across target platforms<sup class="footnote-reference"><a href="#IntWrap">1</a></sup>.</p>
<h3 id="2-host-specific-integers"><a class="header" href="#2-host-specific-integers">2) Host-specific Integers</a></h3>
<p>You have noticed the <code>usize</code> and <code>isize</code> types, unsigned and signed integers respectively, don't specify a bit-width like their counterparts.
That's because their size depends on the specific machine the program is compiled for.</p>
<p>Both are 4 bytes long if compiling for a 32-bit system, and 8 bytes long on a modern 64-bit system.
In theory, they could be 16 bytes long for a 128-bit system - but no commercial processors use 128-bit architectures.</p>
<p>Given what we said about ranges and overflow, machine-dependant (aka host-specific) types might strike you as ambiguous.
Maybe even dangerous.
Per MISRA, you'd be right:</p>
<blockquote>
<p><strong>[RR, Directive 4.6]</strong> Use numeric types of explicit size and signedness<sup class="footnote-reference"><a href="#MISRA_2012">2</a></sup></p>
</blockquote>
<p>While Rust lets us use explicit numeric types were possible, indexing is an exception: <code>usize</code> types are required for collection indexing (e.g. in <code>my_vec[i] = j</code>, <code>i</code> must be a <code>usize</code>).
This is because, under-the-hood, indexing a container often involves computing a memory address<sup class="footnote-reference"><a href="#IndexAside">3</a></sup>.
And the width of an address depends on the target machine.</p>
<p>Now Rust lets us cast from an explicit numeric type, like an <code>u64</code>, into a <code>usize</code>.
Perhaps we need to perform this operation prior to indexing, to comply with the spirit of the above MISRA rule.</p>
<p>Casting between numeric types is one of the very few cases where Rust permits type casting.
Which helps with another rule:</p>
<blockquote>
<p><strong>[AR, Rule 11.3]</strong> Never cast from a reference to one type into a reference to another type<sup class="footnote-reference"><a href="#MISRA_2012">2</a></sup></p>
</blockquote>
<p>Rust does allow safe and explicit conversion between types (not between references), via the concept of <em>traits</em> - specifically traits called <code>From</code><sup class="footnote-reference"><a href="#TraitFrom">4</a></sup> and <code>Into</code><sup class="footnote-reference"><a href="#TraitInto">5</a></sup>.
We'll explain traits in the next section and use <code>From</code> in a later chapter.</p>
<h2 id="type-inference"><a class="header" href="#type-inference">Type Inference</a></h2>
<p>Rust is strongly and statically typed.
Every value has a type known at compile time.
Even generic parameters, whose ultimate type is decided during compilation (more on this later).</p>
<p>Unlike older statically typed languages, Rust uses <em>type inference</em><sup class="footnote-reference"><a href="#TypeInference">6</a></sup> to automatically detect the type of an expression in certain cases. As a rule of thumb, explicitly writing out type annotations is:</p>
<ul>
<li>
<p><em>Always required</em> for function signatures (e.g. parameter and return types), global variables, or exported types (e.g. part of a library's public API).</p>
</li>
<li>
<p><em>Occasionally required</em> within the body of a function.</p>
</li>
</ul>
<p>Consider this example:</p>
<pre><code class="language-rust ignore">#![feature(type_name_of_val)]
use std::any::type_name_of_val;

fn sum(x: u128, y: u128) -&gt; u128 {
    x + y
}

fn main() {
    let a = 1;
    let b = 3;
    let c = sum(a, b);

    println!(&quot;a is a {} with value {:?}&quot;, type_name_of_val(&amp;a), a);
    println!(&quot;b is a {} with value {:?}&quot;, type_name_of_val(&amp;b), b);
    println!(&quot;c is a {} with value {:?}&quot;, type_name_of_val(&amp;c), c);

    let mut list = Vec::new();
    list.push(a);
    list.push(b);
    list.push(c);

    println!(&quot;list is a {} with value {:?}&quot;, type_name_of_val(&amp;list), list);
}</code></pre>
<p>This snippet will print:</p>
<pre><code class="language-ignore">a is a u128 with value 1
b is a u128 with value 3
c is a u128 with value 4
list is a alloc::vec::Vec&lt;u128&gt; with value [1, 3, 4]
</code></pre>
<p>Two instances of automated inference occurred here.</p>
<p>First, primitive types were inferred from a function signature.
If the function <code>sum</code> wasn't part of the program, <code>let a = 1;</code> would be equivalent to <code>let a: i32 = 1;</code>.
<code>i32</code>, a 4-byte signed integer, is Rust's default integer type.
But, because of the line <code>let c = sum(a, b)</code>, the compiler realized that <code>a</code> is actually a <code>u128</code>, a 16-byte unsigned integer.</p>
<p>Second, the type of a dynamic collection was inferred from the type of the item stored.
All three of the below statements are equivalent:</p>
<ul>
<li><code>let mut list = Vec::new();</code> - inferred type (like the above).</li>
<li><code>let mut list: Vec&lt;u128&gt; = Vec::new();</code> - explicit type annotation.</li>
<li><code>let mut list = Vec::&lt;u128&gt;::new();</code> - explicit constructor.</li>
</ul>
<p>We got to use the convenient inferred shorthand because the example program had at least one <code>list.push()</code> statement.
The compiler looked at the type of items being pushed to the vector, <code>u128</code> integers in this case, and decided the type of the vector.</p>
<blockquote>
<p><strong>What about heterogeneous collections?</strong></p>
<p>If we wanted a vector to store items of varying but logically related types, we couldn't rely on type inference.
We'd have to explicitly use the <code>dyn</code> keyword and something called a &quot;trait object&quot;.
That's not a language feature we'll need or cover in this book.</p>
</blockquote>
<h2 id="tuples-vs-arrays"><a class="header" href="#tuples-vs-arrays">Tuples vs. Arrays</a></h2>
<p>Rust provides two ways to represent an ordered, fixed-size sequences of values: tuples and arrays.</p>
<ul>
<li>
<p>Tuples can group multiple values of <em>different</em> types, but can only be indexed by a <em>constant</em>.</p>
</li>
<li>
<p>Arrays can group multiple values of <em>only the same</em> type, but can be indexed by a <em>variable</em>.</p>
</li>
</ul>
<h3 id="tuples"><a class="header" href="#tuples">Tuples</a></h3>
<p>There's no hard-and-fast rule for when to use which, but tuples are particularly useful as a return type.
For cases where a function should return multiple values.</p>
<p>[Slightly contrived] example: say we need to compute lengths for the sides of a 30-60-90 triangle (a special &quot;right triangle&quot;<sup class="footnote-reference"><a href="#Triangle">7</a></sup>) based on its shortest side.
There's a known formula:</p>
<pre><code class="language-rust noplaypen">// Side proportions are 1 : 2 : square_root(3)
fn compute_30_60_90_tri_side_len(short_side: f64) -&gt; (f64, f64, f64) {
  (
    short_side,
    short_side * 2.0,
    short_side * 3_f64.sqrt() // &quot;_f64&quot; is an optional type postfix syntax
  )
}

fn main() {
  let tri_sides = compute_30_60_90_tri_side_len(10.0);

  // Tuple constant indexing
  assert_eq!(tri_sides.0, 10.0);
  assert_eq!(tri_sides.1, 20.0);
  assert_eq!(tri_sides.2, 17.32050807568877);

  // Tuple destructuring
  let (a, b, c) = compute_30_60_90_tri_side_len(10.0);

  assert_eq!(a, 10.0);
  assert_eq!(b, 20.0);
  assert_eq!(c, 17.32050807568877);
}</code></pre>
<p>Function <code>compute_30_60_90_tri_side_len</code> returns three values: the length of 3 sides of a triangle.
In our first call to this function, the inferred type for variable <code>tri_sides</code> is <code>(f64, f64, f64)</code>.
Each float is accessible by constant position, but not by a variable (e.g. <code>tri_sides.1</code> works, but <code>tri_sides.i</code> or <code>tri_sides[i]</code> would not).</p>
<p>We could have defined a structure with named fields, but tuples provide a concise shorthand.
And we can set names with a technique called <em>destructuring</em>, demonstrated by our second call to <code>compute_30_60_90_tri_side_len</code>.
Instead of assigning to a single tuple variable, we destructure and assign each tuple item to its own named variable (e.g. <code>a</code>, <code>b</code>, and <code>c</code>).</p>
<h3 id="arrays"><a class="header" href="#arrays">Arrays</a></h3>
<p>Arrays are a general-purpose data structure you've likely seen in other programming languages, so we won't dwell on them here.
The Rust syntax for arrays declaration is <code>[T; N]</code>.
Each value stored is of type <code>T</code> and <code>N</code> is the length of the array.
It works like so:</p>
<pre><code class="language-rust noplaypen">// Explicit array type declaration
let numbers: [u64; 3] = [42, 1337, 0];

// Inferred array type (`[&amp;str; 4]`, array of read-only string references)
let operating_systems = [&quot;Linux&quot;, &quot;FreeBSD&quot;, &quot;Tock&quot;, &quot;VxWorks&quot;];

// Initialization of all elements (1,000 of them) to a single value (0)
let mut buffer = [0; 1_000];

// Index-based write access
for i in 0..1_000 {
  assert_eq!(buffer[i], 0); // Should have been zero-initialized
  buffer[i] = i; // Overwrite with new value
}

assert_eq!(buffer[0], 0);
assert_eq!(buffer[1], 1);
assert_eq!(buffer[2], 2);

// Iterator-based write access
for num in buffer.iter_mut() {
  *num += 7; // &quot;*&quot; is a dereference for write
}

assert_eq!(buffer[0], 7);
assert_eq!(buffer[1], 8);
assert_eq!(buffer[2], 9);</code></pre>
<p>The above uses two loops to modify the contents of a 1,000 item array.
The first uses traditional, index-based access (e.g. <code>buffer[i]</code>).
The second uses an <em>iterator</em> (e.g. <code>buffer.iter_mut()</code>) to perform a similar operation.</p>
<p>Iterators enable functional programming constructs, like <code>map</code> and <code>filter</code>.
While that entails a performance penalty in many languages, you'll see these constructs used often in idiomatic Rust.
Because they can actually result in <em>faster</em> code.</p>
<p>Why?
There's an implicit contract in the first loop above: <code>i</code> has to be smaller than the length of the array.
Otherwise we'd <em>write out-of-bounds</em>, past the end of the array.
To ensure safety, the compiler has to add a runtime bounds check to the first loop (but not the second).
That check has a cost.
We'll see what failing the check looks like when discussing error handling later in this chapter.</p>
<blockquote>
<p><strong>Arrays vs. Vectors</strong></p>
<p>Unlike the <code>Vec</code> we added items to when discussion type inference, arrays cannot grow dynamically.
Their capacity is fixed.
While that constraint can be inconvenient, it makes arrays portable - don't need to rely on runtime libraries for dynamic memory allocation to use arrays.</p>
</blockquote>
<p>One major difference between Rust and C arrays is that the former have length explicitly encoded as part of the type.
This has several advantages, one of which is compliance with:</p>
<blockquote>
<p><strong>[AR, Rule 17.5]</strong> Arrays used as function parameters must have the correct number of elements<sup class="footnote-reference"><a href="#MISRA_2012">2</a></sup></p>
</blockquote>
<h2 id="references"><a class="header" href="#references">References</a></h2>
<p>We already introduced references in the previous chapter, in the context of a function that increments an integer.
They're a modern alternative to raw pointers:</p>
<pre><code class="language-rust noplaypen">fn incr(a: &amp;mut isize, b: &amp;isize) {
    *a += *b;
}

fn main() {
  let mut x = 3;
  let y = 5;

  incr(&amp;mut x, &amp;y);

  assert_eq!(x, 8);
  assert_eq!(y, 5);
}</code></pre>
<p>References are crucial for systems programming.
Recall that they enable <em>pass-by-reference</em> semantics (hand off a &quot;pointer&quot;), instead of <em>pass-by-value</em> (copy the entire value).
That level of control is essential, it enables performant manipulation of large values.
The programmer can choose when to perform a <em>shallow copy</em> (duplicate only a reference) and when to perform a <em>deep copy</em> (duplicate all data).
The former means less time spent copying bytes and less total memory used.</p>
<p>We'll return to the topic of references when discussing ownership later in this chapter.
When dealing with ownership errors, you'll quickly realize that Rust strongly encourages this MISRA rule:</p>
<blockquote>
<p><strong>[AR, Rule 8.13]</strong> References should be immutable whenever possible<sup class="footnote-reference"><a href="#MISRA_2012">2</a></sup></p>
</blockquote>
<h2 id="slices"><a class="header" href="#slices">Slices</a></h2>
<p>Slices are a concept closely related to references, they also come in immutable and mutable variants:</p>
<ul>
<li>
<p><code>&amp;[T]</code> is an immutable, shared slice of <code>T</code>s.</p>
</li>
<li>
<p><code>&amp;mut [T]</code> is a mutable, exclusive slice of <code>T</code>s.</p>
</li>
</ul>
<p>Both slice types are &quot;partial views&quot; into a sequence of values that are stored within some other, larger value.
Let's make sense of that statement with an example:</p>
<pre><code class="language-rust noplaypen">// Array of 5 items
let mut buffer_overflow_defenses = [
    &quot;stack canary&quot;,
    &quot;ASLR&quot;,
    &quot;NX bit&quot;,
    &quot;CFI&quot;,
    &quot;Intel CET&quot;,
    &quot;ARM MTE&quot;,
];

// Create an immutable slice of the first 3
// [..=2] is inclusive range notation, equivalent to [..3]
let basic_defenses = &amp;buffer_overflow_defenses[..=2];

assert_eq!(basic_defenses, &amp;[&quot;stack canary&quot;, &quot;ASLR&quot;, &quot;NX bit&quot;]);

// Create an mutable slice of the last 2
let advanced_defenses = &amp;mut buffer_overflow_defenses[4..];

assert_eq!(advanced_defenses, &amp;mut [&quot;Intel CET&quot;, &quot;ARM MTE&quot;]);

// Modify via slice
advanced_defenses[1] = &quot;safe Rust!&quot;;

// Notice both slice and it's &quot;backing storage&quot; are updated
assert_eq!(advanced_defenses, &amp;mut [&quot;Intel CET&quot;, &quot;safe Rust!&quot;]);
assert_eq!(buffer_overflow_defenses[5], &quot;safe Rust!&quot;);</code></pre>
<p>Sub-division of a larger sequence is one convenient use of slices, as demonstrated above.
You might recall seeing slice range notation (e.g. <code>[..=2]</code> and <code>[3..]</code>) in the previous chapter as well.
We used it in IETF test vector validation, to grab 16-byte chunks out of the RC4 key stream.</p>
<p>Slices are also useful in creating idiomatic APIs.
We leveraged this approach when defining parameters to our RC4 functions (like <code>new</code> and <code>apply_keystream</code>), but didn't explain the rationale in detail.
Consider the below:</p>
<pre><code class="language-rust noplaypen">fn count_total_bytes(byte_slice: &amp;[u8]) -&gt; usize {
    let mut cnt = 0;

    // Underscore indicates unused variable
    for _ in byte_slice {
        cnt += 1;
    }

    // Oops - we didn't need to loop, there's a built-in length method!
    assert_eq!(cnt, byte_slice.len());

    cnt
}

fn main() {
    let byte_arr: [u8; 4] = [0xC, 0xA, 0xF, 0xE];

    // Vec init shorthand
    let mut byte_vec = vec![0xB, 0xA, 0xD];

    // Push more data dynamically
    byte_vec.push(0xF);
    byte_vec.push(0x0);
    byte_vec.push(0x0);
    byte_vec.push(0xD);

    // Note both types can be borrowed as &amp;[u8]
    assert_eq!(count_total_bytes(&amp;byte_arr), 4);
    assert_eq!(count_total_bytes(&amp;byte_vec), 7);
}</code></pre>
<p>The advantage of slices in parameter signatures is that different kinds of collections can be <em>borrowed as a slice</em>.
In the above, we wrote one function that works for both dynamic vectors of bytes and fixed-size arrays of bytes.</p>
<p>Finally, we'd be remiss if we didn't mention the relationship between strings (<code>String</code> type) and string slices (<code>&amp;str</code> type).
A proper discussion of the topic involves a fair bit of complexity, and strings aren't particularly relevant to code we'll be writing in this book.
Though the data structures we build can certainly store strings, we'll forgo a detailed discussion and recommend section 8.2 of the official Rust book<sup class="footnote-reference"><a href="#TRPL">8</a></sup> - &quot;Storing UTF-8 Encoded Text with Strings&quot; - if you're interested.</p>
<blockquote>
<p><strong>The <code>vec!</code> Macro</strong></p>
<p>The above code includes short-hand notation for initializing a vector of elements.
<code>let mut byte_vec = vec![0xB, 0xA, 0xD];</code> is equivalent to:</p>
<pre><code class="language-rust noplaypen">let mut byte_vec = Vec::new();
byte_vec.push(0xB);
byte_vec.push(0xA);
byte_vec.push(0xD);</code></pre>
<p>In fact, our <code>main</code> function above could have avoided <code>push</code> calls entirely with:</p>
<pre><code class="language-rust noplaypen">let mut byte_vec = vec![0xB, 0xA, 0xD, 0xF, 0x0, 0x0, 0xD];</code></pre>
<p>This syntax may look similar to <code>byte_arr</code>'s initialization, but don't confuse the two: arrays have a fixed capacity, we can't <code>push</code> new items to an array after initialization.</p>
</blockquote>
<h2 id="takeaway"><a class="header" href="#takeaway">Takeaway</a></h2>
<p>We've briefly covered primitives (focusing on integers), tuples, arrays, references, and slices.
And gotten a feel for type inference along the way.
You've now seen low-level techniques for representing and manipulating data in Rust.</p>
<p>Instead of spending dozens more pages on the intricacies, we'll move on to more exciting and interesting features of the language: ways to express higher-level constructs.</p>
<p>You'll master all of these topics through hands-on experience as we progress through the book.
Our present goal is to rapidly survey Rust's fundamentals.</p>
<hr />
<div class="footnote-definition" id="IntWrap"><sup class="footnote-definition-label">1</sup>
<p><a href="https://huonw.github.io/blog/2016/04/myths-and-legends-about-integer-overflow-in-rust/"><em>Myths and Legends about Integer Overflow in Rust</em></a>. Huon Wilson (2016).</p>
</div>
<div class="footnote-definition" id="MISRA_2012"><sup class="footnote-definition-label">2</sup>
<p><em>MISRA C: 2012 Guidelines for the use of the C language in critical systems (3rd edition)</em>. MISRA (2019).</p>
</div>
<div class="footnote-definition" id="IndexAside"><sup class="footnote-definition-label">3</sup>
<p>Well, that's true in the case of a <code>Vec</code>. Under-the-hood <code>Vec</code> is a <em>fat pointer</em> (memory address, length, and capacity) to an array allocated on the heap. Indexing <code>my_vec[i]</code> involves computing an offset to a memory location. But for custom containers you define, overloading the index operator can perform any operation that makes logical sense in the context of your container. We'll implement our own indexing logic for ordered maps and sets later in the book.</p>
</div>
<div class="footnote-definition" id="TraitInto"><sup class="footnote-definition-label">5</sup>
<p><a href="https://doc.rust-lang.org/std/convert/trait.Into.html"><em>Trait <code>std::convert::Into</code></em></a>. The Rust Team (Accessed 2022).</p>
</div>
<div class="footnote-definition" id="TraitFrom"><sup class="footnote-definition-label">4</sup>
<p><a href="https://doc.rust-lang.org/std/convert/trait.From.html"><em>Trait <code>std::convert::From</code></em></a>. The Rust Team (Accessed 2022).</p>
</div>
<div class="footnote-definition" id="TypeInference"><sup class="footnote-definition-label">6</sup>
<p><a href="https://rustc-dev-guide.rust-lang.org/type-inference.html#type-inference"><em>Type inference</em></a>. Guide to Rustc Development (Accessed 2022). Rust uses an extension of the Hindley-Milner type inference algorithm<sup class="footnote-reference"><a href="#HMT">9</a></sup>.</p>
</div>
<div class="footnote-definition" id="Triangle"><sup class="footnote-definition-label">7</sup>
<p><a href="https://www.mathopenref.com/triangle306090.html"><em>30 - 60- 90 Triangle</em></a>. Math Open Reference (Accessed 2022).</p>
</div>
<div class="footnote-definition" id="HMT"><sup class="footnote-definition-label">9</sup>
<p><a href="https://en.wikipedia.org/wiki/Hindley%E2%80%93Milner_type_system"><em>HindleyMilner type system</em></a>. Wikipedia (Accessed 2022).</p>
</div>
<div class="footnote-definition" id="IEEEFloat"><sup class="footnote-definition-label">10</sup>
<p><a href="https://en.wikipedia.org/wiki/IEEE_754-2008_revision"><em>IEEE 754-2008 revision</em></a>. Wikipedia (Accessed 2022).</p>
</div>
<div class="footnote-definition" id="TRPL"><sup class="footnote-definition-label">8</sup>
<p><a href="https://doc.rust-lang.org/book/ch08-02-strings.html"><em>Storing UTF-8 Encoded Text with Strings</em></a>. by Steve Klabnik, Carol Nichols (Accessed 2022).</p>
</div>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../chp3/undef.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../chp3/rust_2_high_data_rep.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../chp3/undef.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../chp3/rust_2_high_data_rep.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
